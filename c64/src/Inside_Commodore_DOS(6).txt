INSIDE

COMMODORE

DOS

-----------------------------------------------------Page 1-----------------------------------------------------
﻿

-----------------------------------------------------Page 2-----------------------------------------------------
﻿
INSIDE

COMMODORE

DOS

by

Richard immers, Ph.D.

Adrian Public Schools

Adrian, Michigan

and

Gerald G. Neufeld, Ph.D.

Brandon university Brandon, Manitoba

Canada

Technical Illustrations by

Diane M. corralejo

UDATAMOST

19821 Nordhoff Street, Northridge, CA 91324

(818) 709-1202

-----------------------------------------------------Page 3-----------------------------------------------------
﻿
First Printing, July 1984

Second Printing, February 1985

RESTON PUBLISHING COMPANY, INC.

A Prentice-Hall Company Reston, Virginia

ISBN 0-8359-3091-2

Copyright © 1984 by DATAMOST, Inc.

All Rights Reserved

This manual is published and copyrighted by DATAMOST, Inc. All rights are reserved by DATAMOST, Inc. Copying, duplicating, selling or otherwise distributing this pro¬ duct is hereby expressly forbidden except by prior written consent of DATAMOST, Inc.

The words COMMODORE, CBM, COMMODORE 64, VIC-20, VIC-1541 and the Com¬ modore logo are registered trademarks of Commodore Business Machines, Inc.

Commodore Business Machines was not in any way involved in the writing or other preparation of this manual, nor were the facts presented here reviewed for accuracy by them.

The information presented in this manual is the result of intensive study of the disassembly of the 1541 DOS. Every effort has been made to provide error-free infor¬ mation. However, neither the authors nor DATAMOST, Inc. can accept responsibility for any loss or damage, tangible or intangible, resulting from use or improper or un¬

intended use of this information.

Printed in U.S.A.

-----------------------------------------------------Page 4-----------------------------------------------------
﻿
ACKNOWLEDGEMENTS

A manual like this one would not be possible without a great deal of technical assistance. Mike Todd's Disk File column in the ICPUG Newsletter proved to be an invaluable source of insight into the inner workings of Commodore's DOS. Raeto West's book, Program¬ ming the PET/CBM, was a constant companion. Jim Butterfield's numerous articles

also provided valuable bits and pieces of information. Brad Templeton's POWER™ system and PAL™ assembler made the development of the programs in this manual

a real joy. These packages are commercially available from Professional Software Inc. In addition, both the PAL disassembler and MICROMON were used as tools for disassembling the 1541 DOS.

We would also like to acknowledge the patience and forebearance of our families and friends. Without their support, producing this manual would have been considerably more difficult. Mike Louder of DATAMOST, Inc. also provided tremendous support for its production.

Finally, we would like to extend a special note of thanks to Dr. Tom MacNeil and Nancy Neufeld for their diligent work in proofreading this manual.

This manual was written on a Commodore computer system using the WordPro 4 Plus word processing system. The WordPro Plus™ Series is commercially available from Professional Software Inc. This sophisticated word processing system made editing and

last minute revisions much easier.

-----------------------------------------------------Page 5-----------------------------------------------------
﻿

-----------------------------------------------------Page 6-----------------------------------------------------
﻿
TABLE OF CONTENTS

Chapter 1 - INTRODUCTION A Brief Word About the Programs

How to Type in the Programs

Chapter 2 - USING THE 1541'S DOS

The Purpose of DOS

Communicating with the 1541

The Command Channel

Using the Command Channel Diskette Housekeeping

Chapter 3 - DISKETTE FORMATTING

Layout of Tracks and Sectors Layout of a Sector

The Header Block The Data Block

Chapter 4 - DISKETTE ORGANIZATION

Information Management The Directory You See

The Block Availablity Map The Directory Entries Program File Storage Sequential File Storage Relative File Storage

User File Storage . 69 Deleted File Storage

Locked Files

Chapter 5 - DIRECT-ACCESS PROGRAMMING

Introduction to Direct-Access Programming Beginning Direct-Access Programming

Block-Read Command

Buffer-Pointer Command Block-Write Command

Memory-Read Command Memory-Write Command

Block-Allocate Command Block-Free Command

Memory-Execute Command

Block Execute Command

Direct-Access Entomology

-----------------------------------------------------Page 7-----------------------------------------------------
﻿
Chapter 6 - INTERMEDIATE DIRECT-ACCESS PROGRAMMING

Chapter 7 - DOS PROTECTION Commodore's Data Encoding Scheme

Checksums

Description of DOS Error Messages Analyzing a Protected Diskette Duplicating a Protection Scheme

How to Create 21 Errors on a Full Track

How to Create a 21 Error on a Single Sector How to Create a 23 Error on a Single Sector How to Duplicate a 23 Error on a Single Sector

How to Create 23 Errors on a Full Track How to Create 20 Errors on a Full Track How to Create 27 Errors on a Full Track

How to Create a 22 Error on a Single Sector How to Duplicate a 22 Error on a Single Sector How to Format a Diskette with Multiple IDs How to Backup a DOS Protected Diskette How to Copy a File

Chapter 8 - GETTING OUT OF TROUBLE

Unscratching a File

Recovering a Soft Sector Recovering a Hard Sector Recovering a Relative File

Recovering an Entire Diskette

Recovering a Physically Damaged Diskette Recovering an Unclosed File Recovering from a Short New Recovering from a Full New

Chapter 9 - OVERVIEW OF THE 1541 DOS

Introduction to 1541 DOS

The Hard Working 6502 Major IP Routines

Using the IP Routines Major FDC Routines

Using the FDC Routines The Recording Process

Block Diagram of the 1541 Writing Data to a Diskette

Reading Data From a Diskette Summary Bugs in DOS 2.6

Write Incompatability with 4040

Late News

-----------------------------------------------------Page 8-----------------------------------------------------
﻿
Appendix A - 1541 RAM VARIABLE DEFINITIONS

Appendix B - ANALYSIS OF THE 1541's ROM

Appendix C - PROGRAM LISTINGS

Appendix D - MATHEMATICAL CONVERSION ROUTINES

Index

-----------------------------------------------------Page 9-----------------------------------------------------
﻿
Ignorance is a precious thing.

Once lost, it can never be regained.

-----------------------------------------------------Page 10-----------------------------------------------------
﻿
CHAPTER 1

INTRODUCTION

This manual is intended to supplement the documentation provided in the 15U1 User's Manual. Although this manual is primarily designed to meet the needs of the in¬ termediate to advanced programmer, it will also be of interest to the novice Commodore

user who wants to know more about how his 1541 disk drive works. This manual is not

intended to replace the documentation provided by Commodore Business Machines, Inc. and the reader is assumed to be relatively familiar with the contents of the 15kl User's Manual. For the sake of continuity and clarity, some of the information covered in the 15U1 User's Manual is also presented here. However, the majority of the information presented in this manual is original and is the result of intensive disassembly and an¬ notation of the 1541's DOS by the authors. Some information is based on articles and notes published in a variety of publications as well as discussions with other knowledgeable disk experts.

This manual was not prepared with the assistance of Commodore Business Machines, Inc. Although we cannot guarantee the accuracy of all the information presented in this manual, the material has been thoroughly researched and tested.

There were several reasons for writing Inside Commodore DOS:

1. To correct errors and omissions in the 15kl User's Manual.

2. To help you make more effective use of your disk drive. 3. To provide complete information on diskette formatting. 4. To provide complete information on the storage of files. 5. To allow you to read and write data in non-standard ways. 6. To help you make a backup copy of your "protected" diskettes. 7. To help you recover damaged diskettes.

8. To help you understand the operation of your disk drive.

Although this manual focuses primarily on the 1541 disk drive, much of the information also applies to other Commodore disk drives.

1.1 A Brief Word About the Programs

This book contains listings for 46 ready-to-use programs written in BASIC. These pro¬ grams are copyrighted. They may NOT be used commercially, in whole or in part, period. Since many of the programs are long, typing them all in would be a time consuming, tedious task. Feel free to share your typing efforts with a friend who has also purchased a copy of this book. In return, we simply ask that you do not share a program with some¬ one who does not own a legitimate copy of this book.

11

-----------------------------------------------------Page 11-----------------------------------------------------
﻿
The programs in this book are disk utilities. They do not use flashy graphics or sound. Rather, they are extremely powerful tools. Remember, any tool can be dangerous if it is used improperly. Be sure that you know what you are doing before you use a given program. Always experiment with a program on a test diskette before you actually use it on one that contains valuable programs or data. Practice makes perfect.

Each program was individually tested on a variety of 1541 disk drives having a wide range of serial numbers. Moreover, each program always worked perfectly. Unfortunately, it is impossible to guarantee that a particular program will work with your model. If a given program does not seem to work properly, check your typing carefully. Any er¬ rors, especially in the DATA statements which contain a machine language program, will produce problems.

As a courtesy to the more advanced programmer, we have also included the source listings for each machine language routine A source listing immediately follows a related BASIC program listing and has a file name ending in ".PAL". It is for use with the PAL assembler. Note: If you are using a different assembler, you may have to make some minor changes.

The programs in this book were designed to be not only useful and beneficial, but in¬ structive as well. Many of them illustrate the "state of the art" in the use of Commodore's direct-access disk commands. Enjoy!

1.2 How to Type in the Programs

Program listings in books and magazines often suffer from two problems: typographical errors that occur when the program is retyped into a word processor and the readabili¬ ty of Commodore's control characters (e.g., the reverse field heart that means Clear Screen). To overcome these problems, the program listings for this book were created using a special "lister" program. This lister program took a working BASIC program and converted it into a WordPro™ file At the same time, control characters were spell¬ ed out in words and surrounded by curly brackets. For example, a reverse field heart was converted to {CLR}. The table below summarizes the listing conventions, the cor¬ responding control characters, and the proper key/keys to press on your C64 or VIC-20.

When You See

{CLR}

{HOME} {DOWN} {UP}

{RIGHT} {LEFT}

{RVS}

{ROFF}

What It Represents

Clear Screen

Home Cursor Cursor Down

Cursor Up

Cursor Right

Cursor Left

Reverse Field ON Reverse Field OFF

12

What You Type

Hold down SHIFT and press

CLR/HOME

Press CLR/HOME Press CRSR/DOWN

Hold down SHIFT and press

CRSR/UP

Press CRSR/RIGHT

Hold down SHIFT and press

CRSR/LEFT

Hold down CTRL and press 9 Hold down CTRL and press 0

-----------------------------------------------------Page 12-----------------------------------------------------
﻿
NOTE 1: When a number appears inside the curly brackets, it means you repeat the

control character immediately to the left of the number that many times. For example:

{DOWN 5} means to press CRSR/DOWN five (5) times.

NOTE 2: All programs have been listed in a column 40 characters wide. Except where

special characters have been spelled out between curly brackets, the lines are listed exactly as they appear on a Commodore 64 display. Spaces must be typed in as listed. Where necessary, count the character columns to determine the appropriate number of spaces.

Happy hunting and pecking!

13

-----------------------------------------------------Page 13-----------------------------------------------------
﻿

-----------------------------------------------------Page 14-----------------------------------------------------
﻿
CHAPTER 2

USING THE 1541'S DOS

2.1 The Purpose of a DOS

A disk operating system (DOS) is a machine language program that controls a disk drive.

It does several different tasks:

1. Handling communications between a disk drive and a computer. 2. Carrying out housekeeping chores such as formatting a diskette. 3. Managing the storage of information on a diskette.

4. Reading and writing information onto a diskette's surface.

In many computer systems, a DOS is loaded into the main computer's memory from diskette when the computer is first switched on. In this type of system many of the tasks are carried out using the computer's microprocessor and RAM. Commodore uses a different approach. All of Commodore's disk drives are intelligent peripherals. They do not have to use the computer's resources; they have their own. For example, the 1541 disk drive contains its own 6502 microprocessor, 2K of RAM, two 6522 I/O chips, and a DOS program permanently stored in 15.8K of ROM.

The advantages of having an intelligent disk drive are:

1. The DOS does not use any of the computer's memory.

2. Some disk operations can be carried out independently from the CPU. 3. Disk operations do not slow down processing.

4. One disk drive can be shared among several computers.

The disadvantages of having an intelligent disk drive are:

1. It is very difficult to customize DOS routines.

2. You must replace the ROMs to convert to a new version of DOS.

2.2 Communicating with the 1541

Your Commodore 64 or VIC-20 can communicate with your 1541 disk drive in several

ways:

1. Through the LOAD, SAVE, and VERIFY commands. 2. Through I/O using the command channel.

3. Through I/O using data communication channels.

15

-----------------------------------------------------Page 15-----------------------------------------------------
﻿
Let's examine each of these in greater detail.

1. LOAD, SAVE, and VERIFY commands:

These BASIC commands are used to store and retrieve programs on the Commodore tape and disk drives. They are designed for ease of use, even by the novice. The BASIC interpreter in the computer interprets these commands and sends the disk drive the necessary information over the serial bus.

2. I/O using the command channel:

The command channel is used to send messages to the disk drive to carry out disk opera¬ tions like: formatting a blank diskette, erasing an unwanted file, renaming a file, etc. These operations are often referred to as disk housekeeping. The command channel is also used to input messages, such as the current error status of the drive, generated by the DOS. For more details on how to use the command channel, see Section 2.4.

3. I/O using data communication channels:

The 1541 DOS supports a variety of kinds of files: program files, sequential files, relative files, user files, and direct-access files. The storage and retrieval of information in files is carried out using a data communication channel. Although this manual provides detailed information regarding how files are stored and organized, no attempt is made to teach you how to develop programs that make extensive use of file handling. We would en¬ courage readers who are interested in file handling techniques to refer to Jim Butter- field's series of articles in COMPUTE!. The only I/O applications discussed in this manual are those relating to direct-access programming (see Chapter 5).

Since the rest of this manual makes extensive use of the command channel, let's ex¬

amine it in some detail.

2.3 The Command Channel

The command channel (channel number 15) is an important communication link between your computer and the 1541 disk drive. It has several important functions. You can use

it to:

1. Monitor the error status of the drive to ensure that everything is operating properly. 2. Send commands that direct the DOS to perform various housekeeping chores

associated with disk handling.

3. Send commands that direct the DOS to read or write information to specific areas

on a diskette.

This chapter focuses on the first two of these uses. Chapter 5 provides more detail on reading or writing to a diskette.

16

-----------------------------------------------------Page 16-----------------------------------------------------
﻿
2.4 Using the Command Channel

Using the command channel is easy. Just follow these steps:

1. Establish communications using an OPEN statement. 2. Send commands to the DOS using a PRINT# statement. 3. Read DOS messages using a GET# or INPUT* statement.

4. Close the channel using a CLOSE statement when you are finished.

Let's go over each step to ensure that you know exactly what to do.

1. Establishing communications using an OPEN statement.

In order to establish a communication channel between your computer and your 1541 disk drive, you use an OPEN statement. An OPEN statement is a BASIC command

which looks like this:

SYNTAX: OPEN -file*, device*, channel*

EXAMPLE: OPEN 15, 8, 15

where

file# = the logical file number (1-127)

device* = the device number (8 for a stock 1541)

channel* = the channel number or secondary address (2-15)

NOTE: Channel numbers 0 & 1 are reserved for use by the DOS.

Channel numbers 2-14 are data communications channels. Channel number 15 is the command channel.

The OPEN statement can be used either in immediate mode (typed and executed directly from the keyboard) or under program control (embedded in a program).

In the example above (OPEN 15, 8, 15) we opened logical file number 15 on the C64 to device number 8 (the disk drive) through channel 15 (the command channel).

2. Sending commands to the DOS using a PRINT* statement.

In order to send commands from your computer to the 1541, you use a PRINT* state¬

ment. A PRINT* statement is a BASIC command which looks like this:

SYNTAX: PRINT* file*, "command"

EXAMPLE: PRINT*15, "NO:MY DISKETTE,MD"

17

-----------------------------------------------------Page 17-----------------------------------------------------
﻿
where

file* = the logical file number you used when you opened the command channel

command = the disk command to be sent to the DOS

NOTE: The statement is PRINT* not PRINT #. You must not put a space before the # sign. Spaces following the # sign are always optional. DO NOT use ?# as an abbrevia¬ tion either. The correct abbreviation is pR(p then SHIFTED R).

In this example, the disk command is "N0:MY DISKETTE,MD". This command causes the DOS to prepare the blank diskette in the drive for first-time use.

Although there are many different disk commands, they fall into two groups:

1. Commands related to disk housekeeping.

2. Commands to read or write data to a diskette or the disk drive's RAM.

The disk housekeeping commands are discussed in the next part of this chapter. The commands relating to reading or writing data are discussed in Chapter 5 on Direct-Access Programming.

3. Reading DOS messages using a GET* or an INPUT* statement.

You may use either an INPUT* or a GET* statement to read the command channel and access any messages or data prepared for the computer by the DOS. Both INPUT* and GET* statements are BASIC commands. They look like this:

SYNTAX: INPUT* file*, variable list

GET* file*, variable list

EXAMPLE: INPUT* 15, EN, EM*, ET, ES

GET* 15, A*

where

file* = the logical file number you used when you opened the command channel

variable list = one or more variable names separated by commas

NOTE: As was noted for PRINT* above, the BASIC statements are INPUT* and GET*, not INPUT # and GET #. You must not put a space before the # sign. Spaces following the # sign are always optional. Neither the INPUT* statement nor the GET* state¬ ment can be used in immediate mode (typed and executed directly from the keyboard). They must be included within a program.

The INPUT* command and the GET* command operate in much the same way as the more familiar INPUT and GET commands. INPUT* always reads as far as the next carriage return character while GET* reads a single byte of information. Generally, GET* is used in direct-access programming and INPUT* is used only for monitoring the drive's error status as indicated immediately below.

18

-----------------------------------------------------Page 18-----------------------------------------------------
﻿
You can check the error status of your disk drive using the command channel. The DOS monitors every disk operation as it is carried out and prepares a status report indicating whether or not the operation was completed successfully. The report consists of an er¬ ror code number, an English language message, and the track and sector where the problem, if any, was encountered. Here is a subroutine that checks the error status.

100 OPEN 15,8,15 : REM

THE OPEN COMMAND CHANNEL

500 INPUT*15,EN,EM*,ET,ES : REM

INPUT THE ERROR STATUS

51O IF EN < 20 THEN RETURN : REM

NO ERROR ENCOUNTERED

520 print en;EM*;et;es : rem

PRINT THE ERROR STATUS ON SCREEN

530 CLOSE 15 : END : REM

ABORT ON BAD STATUS

Line 100 opens the command channel. It is a good idea to open the command channel at the beginning of your program and leave it open until the end. Line 500 inputs the status report. The error code number is stored in EN, the message in EM$, the track in ET, and the sector in ES. Error codes less than 20 may be ignored (line 510). A com¬ plete list of the error codes and messages is contained in the back of your 15kl User's Manual. A detailed explanation of the nature and cause of many of these errors is pro¬ vided in Chapter 7 on Disk Protection.

4. CLOSE the command channel when you are done.

After you have finished using the command channel, it should be closed. Recall that the open command has three parameters: the logical file number, the device number, and the channel number. The close command has only one, the logical file number. It

looks like this:

SYNTAX: CLOSE file*

EXAMPLE: CLOSE 15

where

file* = the logical file number you used when you opened the command channel

NOTE: Loading, running, or editing a program closes down all communication channels automatically. The command channel is closed properly in each instance. However, data channels are aborted rather than closed. When a data channel is aborted, the file is NOT CLOSED properly on the disk drive. You do not have to close the command channel after the issuance of every command. If you forget to close it, the worst that can hap¬ pen is a ?FILE OPEN ERROR when you attempt to open it again. However, you should get into the habit of always closing a file when you are finished using it. You won't get into trouble leaving the command channel open, but you may lose an important data file if you leave a data communication channel open.

19

-----------------------------------------------------Page 19-----------------------------------------------------
﻿
2.5 Disk Housekeeping

As your collection of programs grows, you will have to do some housekeeping to keep things in shape. Disk housekeeping chores include the following:

1. Preparing a blank diskette for first-time use.

2. Erasing the contents of a diskette currently in use. 3. Initializing a diskette. 4. Renaming a file.

5. Scratching or erasing a file. 6. Copying a file.

These operations are carried out by the DOS in response to commands sent to the drive using the command channel as indicated above. Once a disk housekeeping command is issued, the disk drive will carry out the task without further intervention by the com¬ puter. This means that you could edit or even RUN a program in RAM while the disk drive busily formats or validates a diskette. This is not really spooling. It occurs because the 1541 is an intelligent peripheral. The only thing that will cause your computer to wait for the disk drive to complete its task is your attempting to perform another disk operation. This includes closing the command channel.

Let's take a look at the disk commands used for housekeeping. NOTE: If you are using the DOS SUPPORT program that came on your 1541TEST/DEMO, the syntax for these disk commands is remarkably shorter. The > or @ keys are used to send a command to the disk drive. They take the place of the PRINT* statement. In addition, you do not have to open or close the command channel or embed the disk command in quota¬ tion marks. The DOS SUPPORT program will do this automatically for you. The DOS 5.1 syntax can be used only in immediate mode, however. It cannot be used in a pro¬ gram or a 7SYNTAX ERROR will result.

The New Command

When a fresh diskette is taken from its storage envelope, the 1541 cannot recognize it. The diskette must be formatted or newed prior to first-time use. Formatting or new- ing a diskette is performed by the DOS. The DOS proceeds to write concentric tracks made up of blocks/sectors to the diskette. In addition, a directory is set up, wherein the drive records information about all the files stored on the diskette. Chapter 3 pro¬ vides a much more detailed account of this operation. The syntax for formatting a diskette is really quite simple:

SYNTAX: OPEN 15, 8, 15 PRINT#15, "NO:DISK NAME,ID-

CLOSE 15

ALTERNATE: PRINT#15, "N:DISK NAME,ID"

EXAMPLE: OPEN 15, 8, 15

PRINT#15, "NO:MY DISKETTE,MD"

CLOSE 15

DOS 5.1: >NO:DISK NAME,ID

>N:DISK NAME,ID

20

-----------------------------------------------------Page 20-----------------------------------------------------
﻿
The disk command, "NO:MY DISKETTE,MD", is sent to the drive by the PRINT#15 statement. The command has three parameters. The first parameter within quotes is NO:. The N stands for NEW. The 0 is a holdover from the dual drive system and in¬ dicates which drive. The 0 is optional on the 1541 and may be omitted. The colon ter¬ minates the DOS command. The second parameter is the disk name. It is limited to 16 characters in length. Generally these are alphanumeric characters. In the example above, we named the diskette: MY DISKETTE. The disk name is cosmetic and appears in the directory for reference purposes only. It is not written anywhere else on the diskette. The disk name is followed by a comma. The DOS looks or parses for this. After the comma are two alphanumeric characters for the disk ID. In the above example we selected MD as our disk identifier. The ID is written to every block or sector on the diskette. It is impossible to alter. The DOS repeatedly looks at the ID of a sector to be sure that you have not switched diskettes on it. Each diskette should be formatted with a unique ID. This will prevent the DOS from inadvertently overwriting programs on what appears to be an identical diskette.

A "full" new on a diskette takes roughly 2-3 minutes. There is a quicker way to erase a diskette that has already been used. This is accomplished by leaving off the disk ID. For example:

SYNTAX: OPEN 15, 8, 15 PRINT*15, "NO:DISK NAME-

CLOSE 15

ALTERNATE: PRINT*15, "N:DISK NAME"

EXAMPLE: OPEN 15, 8, 15

PRINT*15, "NO:TEST DISKETTE"

CLOSE 15

DOS 5.1: >NO:DISK NAME

>N:DISK NAME

Notice that no comma or ID follows the disk name. This command will work only on a diskette that has previously been formatted. It is referred to as a "short" new. A "short" new simply erases the first sector in the directory and writes an empty BAM (block availability map) to tell the DOS that we have a fresh diskette in use. NOTE: A diskette that is plagued by read or write errors does not have to be pitched. Copy the files to another diskette first. Then do a "full" new on the offending diskette. This will erase and reformat the entire diskette. A "short" new rewrites only sectors 0 and 1 of track 18 and will not eliminate any read or write errors. See Chapter 8 about

how to recover from both a "short" new and a "full" new.

The Initialize Command

Initialization has nothing to do with formatting. APPLE™ owners format a diskette by "initializing" it. This is NOT TRUE with Commodore. Initializing a diskette forces the

DOS to read the disk ID and the contents of the BAM and store them in the drive's

internal memory. The BAM establishes where the next available sector is for writing. Without it files would be overwritten. To initialize a diskette perform the following:

21

-----------------------------------------------------Page 21-----------------------------------------------------
﻿
SYNTAX: OPEN 15, 8, 15

PRINT*15, "10"

CLOSE 15

ALTERNATE: PRINT*15, "I"

DOS 5.1: >I0

>I

The I is short for INITIALIZE. The drive number can be ignored if you are using only one 1541. The drive motor purrs for a few seconds and then settles down. It's that sim¬ ple. It is a good habit to initialize a diskette each time you insert it into your 1541 drive. This point cannot be overemphasized. Do it yourself. Do not rely upon the "autoinit" feature of the drive. Initialization prevents the DOS from overwriting files in the event that two diskettes with identical IDs are swapped. The drive cannot tell the difference

between two diskettes with identical IDs since it is the ID that the DOS uses to iden¬

tify a diskette. Initialization also assures you that a diskette is properly seated in the

drive before use.

The 1541 drive has a built in autoinitialization feature. Once it encounters an error it

will retry a disk operation several times. Often it can recover from an error on its own. If it fails, it gives up. Before doing so, though, it will do a "bump." On a bump the read/write head is stepped outwards 45 tracks (slight overkill) to assure that it is on track 1. The drive clatters when a protrusion on the stepper motor's drive pulley bumps up against a mechanical stop. (It really isn't a melt down.) The head then steps inwards

to track 18 and the DOS awaits further instructions. Self initialization avoids this scenario.

Initialize every time you insert a diskette into the drive.

Initialization clears the error channel and turns off the flashing red LED. Unless, of course, you are trying to initialize an unformatted diskette or forgot to put one in the drive to begin with. Clearing the error channel destroys the error status the DOS prepared for you. If error checking is important, retrieve the error message first; then

initialize the drive.

The Rename Command

Occasionally you will want to change the name of a file stored on a diskette. To rename a file you first open the command channel and then send the rename command like this:

syntax: OPEN 15, 8, 15

PRINT*15, "RO:NEW NAME=OLD NAME"

CLOSE 15

ALTERNATE: PRINT*15, "R:NEW NAME=OLD NAME"

EXAMPLE: OPEN 15, 8, 15

PRINT#15, "RO:DISPLAY T&S=DTS"

CLOSE 15

DOS 5.1: >RO:NEW NAME=OLD NAME

>R:NEW NAME=OLD NAME

22

-----------------------------------------------------Page 22-----------------------------------------------------
﻿
Again the syntax is exacting but simple to follow. The RO: means to rename on drive 0. It is short for RENAMEO:. As before, the 0 is optional on the 1541. The next parameter is the new file name. A file name is generally alphanumeric in nature and 16 characters are allowed at the maximum. (Commas, colons, semicolons, and wild cards are not per¬

mitted. Cursor control and reverse video characters should be avoided.) The new file name is followed by an " = " sign. The last parameter is the existing or old file name. It must be spelled out exactly as it appears in the directory. Wild cards (*,?) are not allowed. If you make a typo on this parameter or the file does not appear in the direc¬ tory, the rename command fails. No damage is done, so relax. In the above example our new file name is DISPLAY T&S. It replaces the old file name DTS. One final point. You cannot rename a file that is currently open for a read or write.

The Copy Command

The copy command allows you to easily backup an existing file on your diskette. There are three restrictions attached. First, the new file must have a different name. Second, the copy command will not work on a relative file. Third, you must have enough room on the diskette. The copy command looks like this:

SYNTAX:

OPEN 15, 8, 15

PRINT*15, "CO:BACKUP=0:ORIGINAL-

CLOSE 15

ALTERNATE:

PRINT*15, "C:BACKUP=ORIGINAL"

EXAMPLE:

OPEN 15, 8, 15

PRINT*15, "CO:MY PROGRAM B/U=0:MY PROGRAM"

CLOSE 15

DOS 5.l:

>CO:BACKUP=0:ORIGINAL >C:BACKUP=ORIGINAL

The C is short for COPY. The new file above is called MY PROGRAM B/U. It is a backup copy of a previous program called MY PROGRAM. Note that we must specify the drive number twice. Again this is a holdover from a dual drive configuration. The C does not appear twice, however. The same restrictions that apply to the rename command are also in effect here, i.e., 16 character file name limit, use of restricted characters, etc. The drive number is optional. See the alternate syntax to save a few keystrokes.

It is also possible to merge two or more sequential data files using the copy command. The syntax for this is as follows:

SYNTAX:

OPEN 15, 8, 15

PRINT*15, "CO:COMBINED=0:FILE1,O:FILE2,

0:FILE3" CLOSE 15

23

-----------------------------------------------------Page 23-----------------------------------------------------
﻿
ALTERNATE:

PRINT*15, "C:C0MBINED=FILE1,FILE2,FILES-

EX AMPLE:

OPEN 15, 8, 15

PRINT*15, "CO:MAILFILE=0:NAME,O:ADDRESS,

0:CITY"

CLOSE 15

DOS 5.l:

> CO:COMBINED=0:FILE1,O:FILE2,0:FILE3 >C:COMBINED=FILEl,FILE2,FILE3

Our large file now consists of several files appended together. While this feature of the copy command is available, it is rarely used. Few programming techniques would re¬ quire or ever utilize this feature. Note that this technique cannot be used to append a subroutine onto a BASIC program; the subroutine cannot be merged into the main program by the disk drive. You will need to use a programmer's aid like POWER™,

SYSRES™, or BASIC AID™ for the C64 to do this.

The Scratch Command

To get rid of an unwanted file, we scratch it. The only exception is an unclosed file. An unclosed file is one that appears in the directory as having zero blocks and whose file type is preceded by an asterisk (*SEQ, *PRG, etc.). This will be explained below. To scratch a file, first remove the write protect tab and key in:

SYNTAX: OPEN 15, 8, 15 PRINT*15, "SO:FILE NAME"

CLOSE 15

ALTERNATE: PRINT#15, "S:FILE NAME-

EXAMPLE: OPEN 15, 8, 15 PRINT#15, "SO:TESTING 123"

CLOSE 15

DOS 5.1: >SO:FILE NAME

>S:FILE NAME

The scratch command requires a single parameter, the file name, preceded by S or SCRATCH. As before, the drive number is optional.

There are some variations that incorporate wild cards. Wild cards in a file name are asterisks (*) or question marks (?). They should be used with utmost caution since more

than one file can be scratched at a time.

EXAMPLE: OPEN 15, 8, 15

PRINT*15, "SO:T*"

CLOSE 15

DOS 5.l: >so:T*

24

-----------------------------------------------------Page 24-----------------------------------------------------
﻿
In the above example all files beginning with the letter T, regardless of file type, will be scratched. In the event that no file starts with the letter T, none will be affected. Careless use of a wild card can have catastrophic results. For example:

EXAMPLE: OPEN 15, 8, 15

PRINT*15, "SO:*" CLOSE 15

DOS 5.l: >so:#

The above command will scratch every file on the diskette. It is the equivalent of per¬ forming a short new on a diskette. Be careful!

The second wild card is the question mark. It is used to mask out characters that are not of importance. Suppose we want to scratch a number of files whose names are all eight characters long and end in .C64. We could not use .C64* to scratch them since the match falls at the end of the file name. However, we could use:

EXAMPLE: OPEN 15, 8, 15 PRINT*15, "SO:????.C64"

CLOSE 15

DOS 5.1: >SO:????.C64

Note that we used four question marks in the above example. An exact match of .C64 must occur on characters 5 through 8 of the file name. No match — no scratch. If we had 1541.C64 and C100.C64 on the disk, both would be scratched by the previous com¬ mand. However, BACKUP.C64 would not be affected.

More than one wild card can be used within the same command. For example:

EXAMPLE: OPEN 15, 8, 15

PRINT*15, "SO:T7ST*"

CLOSE 15

DOS 5.1: >SO:T?ST*

This command would scratch files with these names: TEST, TASTY, TESTING123. The

file TOAST would not be affected. Note that it makes no sense to send a command like

this: "S0:T*ST???". The asterisk has priority over the question mark. All characters that appear after the asterisk are ignored.

A file type that begins with a * is unclosed: *SEQ, *PRG, etc. It was never closed proper¬ ly. This can happen for a variety of reasons:

1. The diskette may have been at its physical capacity and a disk-full situation occurred

during a save or write to a diskette.

2. A bad sector may have been encountered during a write to a diskette.

25

-----------------------------------------------------Page 25-----------------------------------------------------
﻿
3. The file may have been left open following a write operation because you forgot to CLOSE the file, or you aborted the program by hitting either the RUN/STOP key or the RUN/STOP and the RESTORE keys.

4. Your program had a syntax error in it and the BASIC interpreter returned you to

immediate mode.

(See Chapter 8 about how to recover an unclosed file.)

Whatever the cause, an unclosed file should never be scratched! Since the write opera¬ tion was aborted, the internal organization of the diskette (i.e., the BAM), has been left in disarray. It does not match the actual file contents of the diskette. Any further at¬ tempt to write to that diskette will probably cause a loss of one or more files. Files can actually overlap one another now and you will be left with a poisoned diskette. The DOS does have a command to decorrupt itself. This is the validate command. When in doubt, validate your diskette!

The scratch command does not actually erase the file on your diskette. Rather it traces the file across the surface of the diskette and frees any sectors the file occupied. The file-type byte is also changed to a zero in the directory which indicates to the DOS that it is no longer active. If you inadvertently scratch a file that you didn't mean to, stop right then and there! You can recover it. Do not attempt to write to the diskette. The sectors just freed will be used on subsequent writes to the diskette. Once you write to the diskette, recovery is impossible. Chapter 8 on Getting Out of Trouble shows you

how to recover a scratched file.

The Validate Command

This command tells the DOS to reconstruct its map which shows where information is stored on the diskette, so it conforms to the files listed in the directory. This is a simple way to decorrupt a damaged diskette. However, it is not a failsafe command as will be explained shortly. A validate command looks like this:

SYNTAX: OPEN 15, 8, 15

PRINT#15, "VO"

CLOSE 15

ALTERNATE: PRINT*15, "V"

DOS 5.1: >VO

>V

The V is an abbreviation for VALIDATE. As before, the 0 is optional for the 1541 drive.

What does a validate do? The DOS keeps a map that indicates which sectors on a diskette are currently in use. This map is stored on track 18, sector 0. It is referred to as the Block Availability Map or just the BAM for short. When the validate command is issued, all blocks are freed in the BAM on the diskette simulating a newly formatted blank diskette. The drive then picks up the first file in the directory and chains through the

26

-----------------------------------------------------Page 26-----------------------------------------------------
﻿
entire file. As sectors are picked up along the way, they are allocated in the BAM as currently in use. If the file is traced successfully, all blocks associated with it are put back into the BAM as in use. The next file is then picked up out of the directory and the process continues. When all files have been traced, the new BAM is written to the diskette and the internal count now matches the directory contents.

So far so good. Now let's see what happens to an unclosed file. When the DOS encounters an unclosed file in the directory during a validate command, all it does is change the file type byte in the directory entry to a 0 (scratched file). No attempt is made to trace the file. When the validate operation is complete, the unclosed file will no longer appear in a directory listing and any blocks associated with it will be free. This is what you want to happen. Now let's see what happens if you attempt to SCRATCH an unclosed

file.

When you scratch a file, two things happen: the file-type byte in the directory for this file is set to 0 (scratched file) and the DOS traces through the chain of sectors that make up the file and marks each sector it encounters as available for use (free) in the BAM. This is just what you want to have happen for a normal file, but it can poison the diskette when you try it on an unclosed file. Here's why. The last sector of an unclosed file was never written out to the diskette. As a result, the second to the last sector points to a sector that is not really part of the file. The DOS doesn't realize this and continues to follow the "chain." If you are lucky, the "unwritten sector" will be a empty sector (never used since the disk was formatted). If this happens, the DOS will stop because pointers point to a non-existent track and sector (75,1). If you are unlucky, the "unwrit¬ ten sector" will be part of a file that you scratched last week and the pointer will just happen to point into the middle of that very important file you just saved yesterday. When this happens, the DOS will merrily deallocate the remaining sectors in your file. The next write operation to the diskette will see this nice big open space and the new information will be saved right on top of your active file. Now the situation has gone from bad to worse and is in fact pathological — hence a poisoned disk. The only solution is to inspect each file first to ensure that it is not tainted and then copy it onto another

diskette.

The validate routine is aborted if an error (an unreadable sector) is encountered. When it aborts, nothing radical occurs. The new BAM is not written to the disk until the valida¬ tion process has been completed. Don't worry about the blank BAM getting you in trou¬ ble; the DOS will read the old one back in before it allows you to write to the disk. However, the diskette still remains corrupted with no quick remedy in sight. Chapter 8 on recovery deals with this and other disasters.

27

-----------------------------------------------------Page 27-----------------------------------------------------
﻿

-----------------------------------------------------Page 28-----------------------------------------------------
﻿
CHAPTER 3

DISKETTE FORMATTING

When you take a new floppy diskette out of the package, it is blank. Before the drive can store data onto it, it must be formatted. This is done by inserting the diskette into the drive and sending a NEW command to the DOS (see Section 2.5). During "format¬ ting" or "newing," 35 concentric tracks are written to the diskette. Each track is made up of varying numbers of sectors/blocks where programs and data will eventually be stored. In addition to laying down empty blocks/sectors, the DOS creates a directory and a block availability map (BAM) and records them on track 18.

This chapter describes the formatting process and the tracks and sectors of a diskette. Chapter 4 describes the directory and the block availability map (BAM).

3.1 Layout of Tracks and Sectors

During the formatting (newing) process, the DOS divides the diskette into tracks and sectors. A track is a circular path on the diskette along which information is stored.

Each track is concentric with the hole in the center of the diskette. There are a total of 35 tracks numbered from 1 to 35. Track 1 is the outermost track and track 35 is the

innermost track. The read/write head may be positioned to any given track. The posi¬ tion of track 1 is determined by a mechanical stop that limits the outward movement of the read/write head. The other tracks are identified by their distance from track 1. The diagram below indicates the layout of the tracks on a formatted diskette.

29

-----------------------------------------------------Page 29-----------------------------------------------------
﻿
Although there are only 35 tracks, the stepper motor can position the read/write head to more than 70 different positions. This might seem to imply that additional tracks could be recorded on the surface of the diskette to increase its storage capacity. Unfortunate¬ ly, the accuracy of the head positioning mechanism and the width of the path of magnetiza¬ tion produced by the read/write head makes the use of these "phantom" tracks unreliable. If you would like to experiment with this, the programs described in Chapter 9 allow you to experiment with stepping the head around.

Each track is divided into seventeen or more sectors (blocks). Each sector holds 256

bytes of data. (Some manufacturer's record data in 512 or 1024 byte sectors.) Whenever data is read from or written to a diskette, it is done one complete sector at a time.

On Commodore disk drives, the tracks are not divided into a fixed number of sectors. The number of sectors depends on the track number. The outer tracks flower numbers) are longer and are divided into more sectors than the inner (higher numbered) tracks. The table below summarizes how the diskette is organized.

Organization of Tracks and Sectors on a 1541 Formatted Diskette

Track Range of Sector Total Sectors Total Bytes

Zone
 Numbers Numbers Per Track Per Track

1 2 3 4

1 to 17 18 to 24 25 to 30 31 to 35

0 to 20 0 to 18 Oto 17 0 to 16
 21 19 18 17
 5376 4864 4608 4352

A total of 683 sectors are written at the time of initial formatting. Since the disk rotates at a constant speed of 300 rpm, you may wonder how Commodore manages to vary the number of sectors from zone to zone. This is accomplished by varying the rate at which data is read or written (changing the clock rate). Each of the four zones uses a different

30

-----------------------------------------------------Page 30-----------------------------------------------------
﻿
clock rate. This is accomplished by using a high speed clock and dividing the clock by N, where the value of N is determined by the zone. The table below summarizes the

clock rates for each zone.

Zone

1 2 3

4

Tracks

1 to 17 18 to 24 25 to 30 31 to 35

Divisor

13 14 15 16

Clock Rate

307,692 bits/sec 285,714 bits/sec 266,667 bits/sec 250,000 bits/sec

Bits/Rotation

61,538.4 57,142.8 53,333.4 50,000.0

This scheme provides a recording density that varies from about 4000 bits/inch on the

outer tracks to almost 6000 bits/inch on the inner tracks.

If all of the possible bits could be used for data alone, we would be able to store a total of 2,027,676 bits or 253,459 bytes on a diskette. Unfortunately, not all of these bytes can be used for data. The total storage capacity of a diskette formatted on the 1541 is 174,848 bytes. The need for space to store a directory to keep track of the location of the files on a diskette (see Chapter 4) further reduces us to an effective storage capacity of 169,984 bytes (256 bytes * 664 sectors).

3.2 Layout of a Sector

During the formatting (newing) process, the DOS creates and records onto the diskette all 683 sectors/blocks that will eventually be used for storing information. Each sector is comprised of two parts:

1. A header block that identifies the sector.

2. A data block that holds the 256 bytes of data.

The diagram below illustrates how these parts are arranged.

SECTOR #0
 SECTOR #1

SECTOR #2

HEADER BLOCK

DATA BLOCK

I

HEADER BLOCK
 DATA BLOCK

I

HEADER BLOCK

= sync mark

= inter-sec gap

The sectors are recorded in numerical sequence along the circular track. Each sector consists of an identifying header block followed by a data block. The sectors are separated from each other by an inter-record gap. A special character called a SYNC MARK is used to mark the beginning of each header or data block.

31

-----------------------------------------------------Page 31-----------------------------------------------------
﻿
A SYNC MARK is a very special character. It consists of 10 or more 1 bits in a row (normally 40 of them). This particular pattern of bits only occurs at the start of a header or data block. The hardware in the 1541 drive can detect this character and signal the DOS that a new data or header block is coming.

If you are puzzled about why several $FF characters in a row in the data block are not interpreted as a sync character, you may want to skip ahead to the section on Com¬ modore's GCR encoding scheme in Chapter 7.

3.3 The Header Block

The header block of a sector allows the DOS to identify which track and sector is being read. It is composed of a sync mark, eight bytes of identifying information, and a header gap. The diagram below shows the layout of a header block.

SYNC

MARK

HEADER BLOCK
 HEADER BLOCK
 SECTOR

NUMBER

TRACK

NUMBER

ID

CHARACTER

ID

CHARACTER

JOF

BYTE

SOF

BYTE

HEADER GAP

ID
 CHECKSUM
 NUMBER 2

NUMBER 1

NOTE: The header is recorded on disk exactly as indicated above. The diagram on page

54 of the 15�1 User's Manual is incorrect.

Let's examine the bytes that make up the header block:

Sync Mark: This consists of 10 or more 1 bits as described above. It warns the DOS that either a data block or a header block is coming.

Header Block ID: This is normally a $08 byte. It serves to indicate to the DOS that

this is a header block and not a data block.

Header Block Checksum: This is a checksum character used by the DOS to ensure that the header block was read correctly. It is found by EORing the track number, the sector number, and the two ID characters. If you are not sure what an EOR is, you may want to read through Section 7.1.

Sector Number: This byte is the number of this particular sector. The sectors are numbered consecutively around a track.

Track Number: This byte is the number of this particular track. The DOS uses this byte to check to be sure that the record/play head is positioned to the correct track.

ID Character # 2:This is the second ID character that you specified in the NEW com¬ mand when the diskette was formatted (e.g., the 1 in "N0:GAMES,V1"). It is sometimes referred to as the ID HI. The DOS checks this byte against a master disk ID to ensure that you have not swapped diskettes.

32

-----------------------------------------------------Page 32-----------------------------------------------------
﻿
ID Character #1: This is the first ID character that you specified in the NEW com¬ mand when the diskette was formatted (e.g., the V in "N0:GAMES,V1"). It is sometimes referred to as the ID LO. The DOS checks this byte against a master disk ID to ensure that you have not swapped diskettes.

$0F Bytes: These bytes are used as padding (spacing) by the DOS during initial format¬ ting. They are called "OFF" bytes. Once formatting is complete OFF bytes are never referenced again.

Header Gap: The header gap consists of eight $55 bytes. These eight bytes are used to provide breathing room between the header block and the data block. The DOS never reads these bytes. They allow the DOS time to set-up for reading the data block that follows. NOTE: The 4040 drive uses a nine byte header gap. This is one of the reasons why 1541 drives and 4040 drives are NOT WRITE COMPATIBLE! See Chapter 9 for

more information.

NOTE: A header block is written only during the formatting process. It is never rewrit¬ ten again, period.

3.4 The Data Block

The data block of a sector stores the 256 data bytes for this sector. It is composed of a sync mark, a data block ID character, the 256 bytes of data, a data block checksum byte, two off bytes, and an inter-sector gap. The diagram below depicts the layout of

a data block.

SYNC

MARK

DATA

BLOCK

256

DATA BYTES

DATA

BLOCK

S00 BYTE

$00 BYTE

INTER-

SECTOR

SYNC

MARK

HEADER BLOCK

ID
 CHECKSUM
 GAP
 ID

Let's examine the bytes that make up the data block:

Sync mark: This consists of 10 or more 1 bits as previously described. It warns the DOS that either a data block or a header block is coming.

Data Block ID: This byte is normally a $07. It serves to indicate to the DOS that this is a data block and not a header block ($08).

256 Data Bytes: This is the actual data stored in the sector. See Chapter 4 about how Commodore uses the first two bytes as a forward track and sector pointer instead of

actual data.

Data Block Checksum: This is a checksum character used by the DOS to ensure that the data block was read correctly. It is found by EORing all 256 data bytes together.

$00 Bytes: These two bytes are also called OFF bytes. They are used to pad a data block before it is written. They are not referenced again by the DOS.

33

-----------------------------------------------------Page 33-----------------------------------------------------
﻿
Inter-sector Gap: This is also known as the "tail gap." Its purpose is to provide breathing room between the end of the data block and the start of the next sector. The length of the gap varies from zone to zone and from one drive to another (see the chart in Sec¬ tion 7.1). Between consectutive sectors the gap is normally 4 to 12 bytes long. The gap between the last sector on a track and sector zero is often longer — up to 100 bytes in length. The gap is designed to be long enough so that if you write a data block on a day when your drive is turning slightly faster than 300 rpm, you won't overwrite the start of the next sector. (Your drive may not be turning at exactly 300 rpm all the time because of fluctuations in the power supplied to your home or office, mechanical wear, belt slippage, changes in temperature, etc.) Note that the DOS never reads these bytes.

The entire data block (including the preceding sync mark) is rewritten each time data

is recorded on a diskette.

This concludes our overview on how a diskette is formatted. Additional details about

how bytes are encoded on the surface of a diskette are provided in Section 7.1. The ac¬ tual recording process is described in Section 9.7.

34

-----------------------------------------------------Page 34-----------------------------------------------------
﻿
CHAPTER 4

DISKETTE ORGANIZATION

4.1 Information Management

The information that is stored on a floppy disk is virtually useless unless it can be retriev¬ ed quickly. As a result, the organization and management of information is one of the most important tasks of the DOS. To do an efficient job of management, the DOS must

be able to:

1. Keep track of which sectors contain data and which are still empty (available for use).

2. Assign names and storage locations to large blocks of related information (files).

3. Keep track of the sequence of sectors that were used to store a file.

The DOS stores most of this information in the directory on track 18, halfway between the outermost track (1) and the innermost track (35). Centering the directory serves

to minimize head movement across the diskette and extends the life of both the drive

and the media. The directory is subdivided into two areas—the map showing which sec¬ tors are in use and which are free (the Block Availability Map or BAM) and directory entries. The BAM resides solely on sector 0 of track 18. It informs the drive as to what sectors are currently in use and where subsequent writing to the diskette can safely take place. The remaining sectors (1-18) of track 18 contain directory entries (file names, file types, and pointers to where files are stored on the diskette).

4.2 The Directory You See

Let's examine the directory of the 1541TEST/DEMO diskette that came with your drive. Insert it in your drive and type on your keyboard:

LOAD "*0",8

then type

LIST

35

-----------------------------------------------------Page 35-----------------------------------------------------
﻿
After a brief pause you should see the following on your screen:

0 " 13 5 4

1 4

11

9 4 4 6 4

14

9 5

13

558

1541TEST/DEM0 " ZX

"HOW TO USE"

"HOW PART TWO" "VIC-20 WEDGE" "C-64 WEDGE" "DOS 5.1"

"COPY/ALL"

"PRINTER TEST"

"DISK ADDR CHANGE" "DIR"

"VIEW BAM"

"CHECK DISK" "DISPLAY T&S"

"PERFORMANCE TEST" "SEQUENTIAL FILE" "RANDOM FILE" BLOCKS FREE.

2A

PRG PRG PRG PRG PRG PRG PRG PRG PRG PRG PRG PRG PRG PRG PRG

The 0 refers to which drive was accessed. This is a holdover from the 4040 dual drive

system. Next you see the diskette name — 1541TEST/DEMO. In the event that the diskette name is less than 16 characters in length, blank spaces are appended to the end of the name. This forced spacing is known as padding. Following the name of the diskette is the disk ID — ZX in this instance. These two characters are generally (but not always) the unique alphanumeric characters under which the diskette in question was formatted originally. The diskette name and ID are cosmetic in nature and appear in the directory for your reference purposes only. The 2A indicates the DOS version and format, 4040 in this instance — again a holdover. Next we see the active file entries on the diskette itself. Each directory entry has three fields:

1. The number of blocks/sectors the given file occupies.

2. The file name.

3. The file type.

Your demo diskette came with 15 active files on it. Moreover, they are all program files denoted by PRG. The last entry in the directory is the remaining number of available blocks/sectors left on the diskette for storage. It is the difference between 664 blocks available at the time of original formatting and the sum of the blocks of the active files (664 - 106 = 558).

What you see on your screen is not necessarily how the directory is stored on your diskette, however. Let's begin our look at the directory with the Block Availability Map (BAM).

4.3 The Block Availability Map (BAM)

The BAM is where the DOS keeps track of which sectors (blocks) on the diskette con¬ tain information (are in use) and which ones can be used for storing new information (are free). This map is stored on track 18, sector 0. Here is a hex dump of that sector

on the 1541TEST/DEMO disk so we can examine it in detail.

-----------------------------------------------------Page 36-----------------------------------------------------
﻿
1541TEST/DEMO

TRACK 18 - SECTOR O

oo 12 Ol 41 OO 15 FF FF IF ..A ..... BAM 08 15 FF FF IF 15 FF FF IF ........ lO 15 FF FF IF 15 FF FF IF ........ 18 15 FF FF IF 15 FF FF IF ........ 20 15 FF FF IF 15 FF FF IF ........ 28 30 38 40 48 50 58 60 68 70 78 80 88

90 98 AO A8 BO B8 CO C8 DO D8 EO E8 FO F8
 31 35 34 31 54 45 53 54 1541TEST DISK NAME 2f 44 45 4D 4F AO AO AO /DEMO

AO AO 5A 58 AO 32 41 AO ZX 2A DOS TYPE & DISK ID AO AO AO 00 OO 00 00 00 ..... 00 OO OO 00 OO OO 00 OO 00 00 00 00 00 00 OO 00 OO OO OO 00 00 00 OO OO 00 OO 00 OO OO 00 00 OO OO OO OO OO OO OO OO OO 00 OO OO 00 00 OO OO OO OO 00 OO 00 OO 00 OO OO OO OO OO OO OO 00 OO OO 00 00 OO 00 00 00 00 OO OO OO OO OO 00 00 00 OO

As indicated above, the BAM does not take up all 256 bytes on this sector. There are several other things stored here as well. The table below identifies the various parts. Note that the sector dump above uses hexadecimal notation while the table below gives the decimal equivalents.

Bytes

0/1

2 3

4-143

144-159 160-161

Contents

18/1

65

0

160

Purpose

Pointer to first sector of directory entries

ASCII character A indicating 1541/4040 format

Unused

Block Availability Map (BAM)

Diskette name padded with shifted spaces Shifted spaces

37

10 EC FF 07 00 00 00 OO ........ BAM TRACKS

00 00 00 00 12 BF FF 07 ..... ?. . BAM TRACKS

13 FF FF 07 13 FF FF 07 ........ BAM TRACKS

13 FF FF 07 12 FF FF 03 ........ BAM TRACKS

12 FF FF 03 12 FF FF 03 ........ BAM TRACKS

12 FF FF 03 12 FF FF 03 ........ BAM TRACKS

12 FF FF 03 11 FF FF 01 ........ BAM TRACKS

11 FF FF Ol 11 FF FF 01 ........ BAM TRACKS

11 FF FF 01 11 FF FF Ol . BAM TRACKS

TRACKS

-----------------------------------------------------Page 37-----------------------------------------------------
﻿
162-163 Diskette ID

164 160 Shifted space

165-166 50/65 DOS version and format type (2A)

160

170-255 1 Unused

In the BAM four bytes are used to describe the status of each track. As a result, the BAM takes up a total of 4 x 35 = 140 bytes (bytes 4-143 or $04-$8F). Let's examine the entry for track 14 to see what these four bytes mean. The entry for track 14 begins at byte 14 x 4 = 56 ($38). It looks like this:

** *# ** ♦*

The first byte for track 14 (location $38 = 56) indicates the number of blocks free on

this track.

In this case there are $11 or 17 (1 * 16 + 1) blocks free.

When the DOS calculates the number of blocks free on a diskette, it sums this byte from each track's entry in the BAM. Let's do our own blocks free calculation to see how it is done. All we have to do is sum up the decimal values of every fourth byte starting with byte 4 like this:

HEX

DECIMAL

ZONE

1

BYTE

4 8 12 16 20 24 28 32 36 40 44 48 52 56 60 64 68

TRACK

1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17

VALUE

$1F $1F $1F $1F $1F $1F $1F $1F $1F $1F $1F $1F $1F $11 $00 $00 $00

VALUE

21 21 21 21 21 21 21 21 21 21 21 21 21 17

0 0 0

38

. 38: 11 D7 5F IF OO OO OO OO .W ...... BAM TRACKS

. 38: 11 D7 5F IF OO OO OO OO .W ...... BAM TRACKS

167-170 Shifted spaces

-----------------------------------------------------Page 38-----------------------------------------------------
﻿
72 76 80 84 88 92 96

100 104 108 112 116 120

124 128 132 136 140

18 19 20 21 22 23 24

25 26 27 28 29 30

31 32 33 34 35

$10 $13 $13 $13 $13 $13 $13

$12 $12 $12 $12 $12 $12

$11 $11 $11 $11 $11

16 19 19 19 19 19 19

18 18 18 18 18 18

17 17 17 17 + 17

574

BLOCKS FREE

Wait a minute! We calculated 574 blocks free hut the directory shows 558. How do we explain this discrepancy? Easy. Remember that the DOS reserves track 18 for its own use. Therefore the blocks free on that particular track are not returned to us (574 - 16 = 558). Sixteen sectors on track 18 are still free, but available only to the DOS.

Now that you have seen how to calculate the number of blocks free on a diskette, let's get back to our analysis of track 14. The BAM entry looked like this:

58: 11 D7 5F IF OO OO OO OO .W.

BAM TRACKS 14-15

** *# ** **

The first byte was easy to interpret. The remaining three bytes are a bit trickier (no pun intended). They are a bit map showing the status of the sectors on a given track. Bit mapping is used to save space. If one byte were used for each of the 683 sectors, the BAM would take up three sectors (683 / 256). This would be inefficient. By using bit mapping, each byte describes the status of eight sectors. This way only three bytes are needed for each track. Let's examine the bit map for track 14 of our 1541

TEST/DEMO.

38: 11 D7 5F IF 00 00 00 00 -W.

** ** #* **

BAM TRACKS 14-15

LOCATION

BYTE VALUE

BINARY

SECTOR NUMBER

*39=57

*D7

11010111

76543210

*3A=58

*5F

OlOlllll

111111

54321098

*3B=59

*1F

OOOlllll *

21111

xxx09876

* 1 = FREE

O

ALLOCATED

39

-----------------------------------------------------Page 39-----------------------------------------------------
﻿
Sectors 0 to 7 are represented by the byte at location 57. Sectors 8 through 15 are stored in the byte at location 58. Finally, sectors 16 through 20 are depicted by the byte at location 59. When decoded, a bit that is high or a 1 indicates that a sector is not current¬ ly in use (free) and can be written to. A bit that is low or a 0 is currently in use (allocated) and will be overlooked by the DOS when writing subsequently takes place to the diskette. The third byte is always incomplete since a maximum of 21 sectors are written to any track. This particular byte is automatically adjusted by the DOS during initial format¬ ting to indicate the proper number of sectors for this track. Three bytes are still used irregardless of the zone, however. If you count up the Is in the bit map for track 14, you will find that there are 17 free sectors on track 14. This agrees with the blocks free count for the track stored at byte location $38 (56) in the BAM, i.e., $11 or 17 decimal.

To ensure that you understand how the bit mapping works, let's take a look at track 18. Since track 18 is used for storing the directory we would expect some allocation of sectors here. Byte 72 shows $10 or 16 sectors available here. They are bit mapped in bytes 73, 74, and 75 as follows:

48: 10 EC FF 07 00 OO OO OO

*# »* ** **

BAM TRACKS 18-19

LOCATION

BYTE VALUE

BINARY

SECTOR NUMBER

*49=73 *4A=74 *4B=75

*EC *FF *07

lllOHOO 11111111 OOOOOlll *

111111 21111

76543210 54321098 xxx09876

* 1 = FREE

O = ALLOCATED

If you are still unsure of yourself, don't be too concerned. The DOS looks after the BAM. Let's move on and explore the actual directory entries themselves. Sectors 1 through 18 on track 18 are reserved specifically for them.

4.4 The Directory Entries

Recall that bytes 0 and 1 of track 18, sector 0 point to the next track and sector of the directory. In this particular instance, the BAM points to track 18, sector 1. Let's ex¬

amine this sector in detail.

1541TEST/DEMO

TRACK 18 - SECTOR Ol

00: 12 04 82 11 OO 48 4F 57

08: 20 54 4F 20 55 53 45 AO TO USE

lO: AO AO AO AO AO OO 00 OO

40

FILE ENTRY #1

-----------------------------------------------------Page 40-----------------------------------------------------
﻿
18 20 28 30 38 40 48 50 58 60 68 70 78 80 88 90 98 AO A8 BO B8 CO C8 DO D8 EO E8 FO F8

00 OO 00 OO OO 00 OD OO

00 OO 82 11 03 48 4F 57 .....HOW FILE

20 50 41 52 54 20 54 57 PART TW 4F AO AO AO AO OO OO 00 O OO OO OO OO 00 OO 05 OO

OO OO 82 11 09 56 49 43 .....VIC FILE 2D 32 30 20 57 45 44 47 -20 WEDG 45 AO AO AO AO OO OO 00 E 00 OO 00 OO OO OO 04 OO

OO OO 82 13 OO 46 2D 36 .....C-6 FILE 34 20 57 45 44 47 45 AO 4 WEDGE. AO AO AO AO AO OO OO OO 00 OO OO 00 OO 00 Ol 00

OO OO 82 13 01 44 4F 53 .....DOS FILE 20 35 2E 31 AO AO AO AO 5.1 AO AO AO AO AO 00 OO 00 00 OO OO 00 00 00 04 00

00 OO 82 13 03 43 4F 50 .....COP FILE 59 2F 41 4C 4C AO AO AO Y/ALL AO AO AO AO AO OO 00 00 OO OO OO OO OO OO OB OO

00 OO 82 13 09 50 52 49 .....PRI FILE 4E 54 45 52 20 54 45 53 NTER TES 54 AO AO AO AO 00 OO 00 T OO OO OO 00 OO OO 09 OO

00 00 82 10 OO 44 49 53 .....DIS FILE 4B 20 41 44 44 52 20 43 K ADDR C 48 41 4E 47 45 00 OO 00 HANGE 00 00 00 00 00 OO 04 OO

The contents of any directory sector can be tabled as follows:

Byte

0 1

2-31

32-33 34-63

64-65 66-95

96-97

98-127 128-129 130-159

Contents

0

0

0

0

Purpose

Track of the next directory block Sector of the next directory block

File entry #1 in the directory block

Unused

File entry #2 in the directory block

Unused

File entry #3 in the directory block

Unused

File entry #4 in the directory block

Unused

File entry #5 in the directory block

41

-----------------------------------------------------Page 41-----------------------------------------------------
﻿
160-161 0 Unused

162-191 File entry #6 in the directory block

192-193 0 Unused

194-223 File entry #7 in the directory block

224-225 0 Unused

226-255 File entry #8 in the directory block

Eight file entries are recorded per sector. Let's examine the contents of a single direc¬ tory file entry.

. OO: 12 04 82 11 00 48 4F 57

. 08: 20 54 4F 20 55 53 45 AO TO USE . lO: AO AO AO AO AO 00 OO OO . 18: 00 OO OO 00 00 00 OD OO

Because this is the first entry in the directory, bytes 0 and 1 are significant. They point to track 18, sector 4 (converts to 18). This indicates that there are further directory en¬ tries. You will note that the sectors are not sequential in nature, i.e., sector 1 does not point to sector 2, etc. Remember that the diskette itself is rotating at 300 rpm. Stagger¬ ing the use of the sectors allows quicker access and fewer rotations of the drive mechanism and the media. Typically sectors are staggered in increments of 10. The direc¬ tory track is staggered in increments of 3, however. The table below indicates the se¬ quence in which a full directory containing 144 files is stored:

SECTOR FILLING SEQUENCE

FOR THE DIRECTORY

0 (BAM)

1, 4, 7, 10, 13, 16 2, 5, 8, 11, 14, 17 3, 6, 9, 12, 15, 18

When a diskette is initially formatted, sector 1 is set up with 8 null entries. As you store files on the diskette the directory grows. It soon becomes a long chain of directory sec¬ tors. The first two bytes in a sector point to the next directory sector in the chain (this is known as a forward pointer). But, what about the last sector in the chain? It has nothing to point to! In the last sector in the chain, there is no forward pointer; byte 0 contains a 0 ($00) and byte 1 contains a 255 ($FF) as indicated below. This indicates to the DOS that there are no more sectors in the directory.

. OO: OO FF xx xx xx xx xx xx

One final note about chaining. Commodore uses only forward pointers. A sector does not show where it came from, only where it is going. This makes recovery of corrupted files much more difficult, but more about that later.

42

-----------------------------------------------------Page 42-----------------------------------------------------
﻿
Back to our example:

OO: 12 04 82 11 OO 48 4F 57

08: 20 54 4F 20 55 53 45 AO

HOW

TO USE

lO: AO AO AO AO AO OO OO OO 18: 00 OO 00 00 00 00 OD 00

The first byte in the file entry is the file-type byte. In this instance we see an $82. This is interpreted by the DOS to mean that the file entry is a program. The following table outlines Commodores file types.

HEX

$00

$80 $81 $82 $83 $84

$00 $01 $02 $03 $04

$A0 $A1 $A2 $A3 $A4

$C0 $C1 $C2 $C3 $C4

ASCII

0

128 129 130 131 132

0 1 2 3 4

160 161 162 163 164

192 193 194 195 196

FILE TYPE

Scratched

Deleted

Sequential Program

User

Relative

Unclosed deleted

Unclosed sequential Unclosed program

Unclosed user

Unclosed relative

Deleted @ replacement

Sequential @ replacement Program @ replacement User @ replacement

Relative @ replacement

Locked deleted

Locked sequential Locked program

Locked user

Locked relative

DIRECTORY SHOWS

Does not appear

DEL

SEQ

PRG USR REL

Same as scratched

*SEQ

*PRG *USR

Cannot occur

DEL

SEQ

PRG USR

Cannot occur

DEL <

SEQ <

PRG < USR < REL <

Note: It is possible to edit the file-type byte and get very unusual file types appearing in the directory (SR?< is one possibility). However, these file types have no practical use.

Enough esoterica for now. Let's get back to our example:

The next two bytes in the file entry are a pointer to where the first sector of that par¬

ticular file is stored on the diskette.

43

-----------------------------------------------------Page 43-----------------------------------------------------
﻿
. OO: 12 04 82 11 OO 48 4F 57

♦* **

. 08: 20 54 4F 20 55 53 45 AO TO USE . 10: AO AO AO AO AO OO OO OO . 18: OO OO 00 00 00 00 OD OO . .'

This file starts on track 17 ($11), sector 0 ($00).

Next we have the file name.

. OO: 12 04 82 11 OO 48 4F 57

** ** *«-

. 08: 20 54 4F 20 55 53 45 AO TO USE

** ** ** ** ** ** ** **

. 10: AO AO AO AO AO 00 00 00

*♦ ** ** ** **

. 18: 00 OO OO OO OO 00 OD 00

In this case our file is named "HOW TO USE". Note that file names are padded out to 16 characters with shifted spaces ($A0) just like the diskette name. The shifted spaces do not show as part of the file name, however, when the directory is displayed.

. 00: 12 04 82 11 00 48 4F 57

. 08: 20 54 4F 20 55 53 45 AO TO USE . 10: AO AO AO AO AO 00 OO OO

** ** **

. 18: OO 00 00 00 00 OO OD OO

The next three bytes are unused except for relative file entries. For a relative file bytes $15 (21) and $16 (22) point to the first set of side sectors. Byte $17 (23) gives the record size with which the relative file was created. This special file type will be examined in

detail later.

The next four bytes are always unused and therefore null ($00).

. OO: 12 04 82 11 00 48 4F 57

. 08: 20 54 4F 20 55 53 45 AO TO USE . 10: AO AO AO AO AO OO OO OO . 18: OO 00 00 00 00 00 OD 00

** ** ♦* ♦*

The following two bytes are reserved for use by the DOS during the save and replace operation (@ replacement). Their function can only be viewed by interrupting the drive during a SAVE "@0:file name",8 routine. This is not recommended for obvious reasons. (During an @ replacement the file-type byte is ORed with $20 first. A new copy of the file is then written to the disk. Bytes 28 ($1C) and 29 ($1D) contain the track and sector pointer to the start of the new replacement file. At the end of the @ operation the sec¬

tors that held the old file are marked as free in the BAM. The new track and sector

44

-----------------------------------------------------Page 44-----------------------------------------------------
﻿
pointer is then moved from bytes 28 and 29 to bytes 3 ($03) and 4 ($04) respectively and bytes 28 and 29 are zeroed again. The proper file type is then restored at byte 2. See Chapter 9 about the bug in the @ replacement command.)

00: 12 04 82 11 OO 48 4F 57

08: 20 54 4F 20 55 53 45 AO TO USE

10: AO AO AO AO AO 00 00 00 18: OO 00 00 00 00 00 OD OO

*♦ **

The final two bytes in a file entry are the number of blocks it occupies on the diskette. It is the sum of the leftmost byte (lo-byte) + the rightmost byte (hi-byte) * 256.

. OO: 12 04 82 11 00 48 4F 57

. 08: 20 54 4F 20 55 53 45 AO TO USE . 10: AO AO AO AO AO 00 00 OO . 18: OO OO OO OO OO OO OD OO

♦* **

LO HI

In our example, the file is (13 + 0 * 256) = 13 blocks long.

To be sure you understand the file entries work let's break out the first sector of the test/demo directory to show each file entry. Remember that bytes 0 and 1 of each entry are unused with the exception of the first entry. Here they represent a forward track and sector chain and have nothing to do with that file in particular.

1541TEST/DEMO

TRACK 18 - SECTOR 01

DIRECTORY ENTRY 1

OO: 12 04 82 11 00 48 4F 57 ..... HOW File type = $82 = 08: 20 54 4F 20 55 53 45 AO TO USE Starts on 17/1 ($ll/$00)

10: AO AO AO AO AO 00 OO 00 ... Name: HOW TO USE

18: OO OO OO OO OO 00 OD OO ........ File length: 13

DIRECTORY ENTRY 2

20: OO OO 82 11 03 48 4F 57 ..... HOW File type = $82 = 28: 20 50 41 52 54 20 54 57 PART TW Starts on 17/3 ($ll/$03) 30: 4F AO AO AO AO 00 00 00 O ... Name: HOW PART TWO 38: OO OO OO 00 00 00 05 OO ........ File length: 5

45

-----------------------------------------------------Page 45-----------------------------------------------------
﻿
DIRECTORY ENTRY 3

40: 00 00 82 11 09 56 49 43 ..... VIC File type = $82 = 48: 2D 32 30 20 57 45 44 47 -20 WEDG Starts on 17/9 ($11/09)

SO: 45 AO AO AO AO 00 OO OO E ... Name: VIC-20 WEDGE

58: OO OO OO OO OO OO 04 00 ........ File length: 4

DIRECTORY ENTRY 4

60: OO OO 82 13 00 46 2D 36 ..... C-6 File type = $82 = 68: 34 20 57 45 44 47 45 AO 4 WEDGE Starts on 19/0 ($13/$00) 70: AO AO AO AO AO 00 OO OO ___ Name C-64

78: OO OO 00 00 00 OO Ol OO ........ File length: 1

DIRECTORY ENTRY 5

80: OO OO 82 13 01 44 4F 53 ..... DOS File type = $82 = 88: 20 35 2E 31 AO AO AO AO 5.1 Starts on 19/1 ($13/$01)

90: AO AO AO AO AO OO OO OO ___ Name: DOS

98: OO OO OO 00 OO OO 04 OO ........ File length: 4

DIRECTORY ENTRY 6

AO: OO OO 82 13 03 43 4F 50 ..... COP File type = $82 = A8: 59 2F 41 4C 4C AO AO AO Y/ALL Starts on 19/3 ($13/03)

BO: AO AO AO AO AO OO 00 00 ___ Name:

B8: OO OO OO 00 00 OO OB OO ........ File length: 11

DIRECTORY ENTRY 7

CO: 00 OO 82 13 09 50 52 49 ..... PRI File type = $82 = C8: 4E 54 45 52 20 54 45 53 NTER TES Starts on 19/9 ($13/09)

DO: 54 AO AO AO AO 00 OO OO T ___ Name:

D8: OO OO OO OO OO OO 09 OO ........ File length: 9

DIRECTORY ENTRY 8

EO: OO 00 82 10 00 44 49 53 ..... DIS File type = $82 = E8: 4B 20 41 44 44 52 20 43 K ADDR C Starts on 16/0 ($10/00)

FO: 48 41 4E 47 45 OO OO OO HANGE. . . Name:DISK ADDR CHANGE

F8: OO OO OO OO OO OO 04 OO ........ File length: 4

46

-----------------------------------------------------Page 46-----------------------------------------------------
﻿
We will end our tour of the directory by displaying the next sector (track 18, sector 4) which happens to end the directory chain ($00, $FF in bytes 0 and 1, respectively). Notice that only seven directory entries are present in this block. The last directory entry is a null entry. It will be converted into a valid entry when the directory is expanded.

1541TEST/DEMO

TRACK 18 - SECTOR 04

00: OO FF 82 10 01 44 49 52 ..... DIR File type = $82 = 08: AO AO AO AO AO AO AO AO Starts on 16/1 ($10/01) lO: AO AO AO AO AO OO OO OO ___

18: 00 00 00 00 00 00 04 OO ........ File length: 4

20: OO 00 82 10 03 56 49 45 ..... VIE File type = $82 = 28: 57 20 42 41 4D AO AO AO W BAM Starts on 16/3 ($10/03)

38: 00 00 00 00 00 OO 06 OO ........ File length: 6

40: OO 00 82 10 07 43 48 45 ..... CHE File type = $82 = 48: 43 4B 20 44 49 53 4B AO CK DISK Starts on 16/7 ($10/07)

50: AO AO AO AO AO OO OO 00 ... Name: CHECK DISK

58: OO 00 00 00 OO OO 04 OO ........ File length: 4

60: OO OO 82 10 OF 44 49 53 ..... DIS File type = $82 = 68: 50 4C 41 59 20 54 26 53 PLAY T&S Starts on 16/15 ($10/$0F)

70: AO AO AO AO AO OO OO OO ... Name: DISPLAY T&S

78: 00 OO OO OO OO 00 OE 00 ........ File length: 14

80: OO 00 82 14 02 50 45 52 ..... PER File type = $82 = 88: 46 4F 52 4D 41 4E 43 45 FORMANCE Starts on 20/2 ($14/$02)

90: 20 54 45 53 54 OO OO OO TEST... Name: PERFORMANCE TEST

98: 00 OO OO 00 OO 00 09 00 ........ File length: 9

AO: OO OO 82 14 07 50 45 52 ..... SEQ File type = $82 = A8: 55 45 4E 54 49 41 4C 20 UENTIAL Starts on 20/7 ($14/$07) BO: 46 49 4C 45 AO OO OO OO FILE ___ Name: B8: 00 OO OO OO OO OO 05 OO ........ File length: 5

CO: OO OO 82 OF Ol 52 41 4E ..... RAN File type = $82 = C8: 44 4F 4D 20 46 49 4C 45 DOM FILE Starts on 15/1 ($0F/$01)

DO: AO AO AO AO AO OO OO OO ___ Name:

DB: OO OO OO OO OO 00 OD 00 ........ File length: 13

EO: OO OO OO OO OO OO OO OO ........ NULL E8: OO OO 00 00 OO OO 00 OO FO: OO OO 00 00 00 OO OO 00 F8: OO 00 OO 00 OO 00 OO 00

47

30: AO AO AO AO AO OO OO OO ___ Name:VIEW

-----------------------------------------------------Page 47-----------------------------------------------------
﻿
You will find four of the utilities listed in Appendix C particularly helpful in furthering your understanding of the organization of a diskette. The first program is DISPLAY TRACK & SECTOR. The hex dumps in this section were generated using this utility. A hex dump can be sent either to the screen or printer. When sent to the screen only half a page of the specified track and sector is displayed at one time to prevent scroll¬ ing. Bytes 0 - 127 ($00 - $7F) are displayed first followed by bytes 128 - 255 ($80 - $FF). Use this program for your own experimentation. The second program is DISPLAY A BLOCK AVAILABILITY MAP. It portrays the BAM in a two-dimensional representation. The diskette name, ID, DOS version, and blocks free are also displayed. The third program is VIRTUAL DIRECTORY. It displays a directory in its entirety including scratched files. Output can be directed to a printer by changing the OPEN 4,3 statement in line 440 to OPEN 4,4. The last program, DISPLAY A CHAIN, traces a file chain. The chain of sectors may be viewed on the screen or sent to the printer.

The programming techniques that are used in these sample programs will be partially explained in later sections.

Now that we've seen how the directory is kept, let's look at how the different types of files are actually stored on a diskette. We'll start by looking at a program file.

4.5 Program File Storage

The most common type of file is a program file, PRG. It is designated by an $82 in the directory. Program file structure is quite simple. Diagrammatically, the first sector (block) in a program file looks like this.

TRACK LINK
 SECTOR LINK
 LOAD

LO

LOAD

HI

THE FIRST 252 BYTES

OF YOUR PROGRAM

Byte Purpose

0 Track of the next block in this file 1 Sector of the next block in this file

2 Lo-byte of the load address 3 Hi-byte of the load address

4-255 The first 252 bytes of the program

The first pair of bytes are the pointer to the track and sector of the next block in the file. Technically, this is known as a "forward pointer." It points ahead to the next sec¬ tor in the file. All Commodore files use this type of pointer.

The second pair of bytes is the "load address" of the file in lo-byte/hi-byte form. They indicate where the program is to be loaded into memory. A BASIC program that was saved from a C64 will have a $01 and a $08 in these two locations. This indicates that the program is to be loaded into memory starting at memory location $0801 (remember it is in lo-byte/hi-byte form). In decimal notation this is memory location 2049 — the start

of BASIC on a C64.

48

-----------------------------------------------------Page 48-----------------------------------------------------
﻿
Have you ever wondered about the significance of the ",1" in the command LOAD "name",8,l? It determines whether or not a program is "relocated" when it is loaded into memory. If you do not specify the ",1", the C64 will ignore the load address at the start of the file and load the program starting at memory location $0801 (2049). When the ",1" is present, the C64 (or VIC-20) will pay attention to the load address and load the program into memory starting at the location specified by bytes $02 and $03.

The remaining sectors, except the last one, look like this:

TRACK LINK

SECTOR LINK

THE NEXT 254 BYTES

OF YOUR PROGRAM

Byte Purpose

0 Track of the next block in this file 1 Sector of the next block in this file

2-255 The next 254 bytes of the program

The last block in a program file is special because:

1. It is the last sector.

2. It is usually only partially full.

To signal the DOS that this is the last block, the first byte is set to $00. The first byte is normally the track link. Since there is no track 0, the DOS knows that this is the last sector in the file. The second byte indicates the position of the last byte that is part of the program file. Any bytes beyond this position are garbage.

Diagrammatically, the last sector in a program file looks like this:

NULL

$00

LAST BYTE

THE FINAL BYTES OF YOUR PROGRAM
 GARBAGE

Byte Purpose

Null byte to indicate that this is the last sector Number of bytes to read from this sector (N)

2-N The last (N-2) bytes of the program

(N + D-255 Garbage

Let's examine the program file "DIR" on your 1541TEST/DEMO disk. DIR appears in the directory on track 18, sector 04. The directory entry looks like this:

49

-----------------------------------------------------Page 49-----------------------------------------------------
﻿
TRACK 18 - SECTOR 04

00: 00 FF 82 10 01 44 49 52 08: AO AO AO AO AO AO AO AO 10: AO AO AO AO AO OO 00 OO 18: 00 00 00 00 00 00 04 OO

From the entry we see that "DIR" starts at track 16 ($10), sector 01 ($01) and that the file is four blocks long (4 + 0 * 256).

00: 00 FF 82 lO 01 44 49 52

** »*

08: AO AO AO AO AO AO AO AO 10: AO AO AO AO AO 00 OO OO 18: 00 00 00 00 00 00 04 OO

♦* **

Let's look at the first block in this file.

TRACK 16 - SECTOR Ol

00 08 10 18 20 28 30 38 40 48 50 58 60 68 70 78 80 88 90 98 AO A8 BO B8 CO C8
 10 OB 01 04 OD 04 04 00

9F 32 2C 38 2C 31 35 00 .2,8,15.

IE 04 05 OO 99 22 93 22

3A 89 20 31 30 30 30 30 : . lOOOO

00 2E 04 OA 00 9F 31 2C 1 38 2C 30 2C 22 24 30 22 8,0,"*0"

00 3C 04 14 00 Al 23 31 .<

2C 41 24 2C 42 24 OO 4A ,A*,B*.J 04 IE 00 Al 23 31 2C 41 ----

24 2C 42 24 00 58 04 28 *,B*.X.<

00 Al 23 31 2C 41 24 2C ..#1,A*,

42 24 00 60 04 32 00 43 BS...2.C B2 30 00 77 04 3C 00 8B .0 --- 20 41 24 B3 Bl 22 22 20 A*.."" A7 20 43 B2 C6 28 41 24 . C..(A* 29 OO 94 04 46 OO 8B 20 )...F.. 42 24 B3 Bl 22 22 20 A7 B*.."" . 20 43 B2 43 AA C6 28 42 C.C..(B 24 29 AC 32 35 36 00 AF *).256.. 04 50 OO 99 22 12 22 CA .P..".".

28 C4 28 43 29 2C 32 29 (.(C),2) 3B A3 33 29 3B 22 92 22 ;.3>;"." 3B OO C9 04 5A 00 Al 23 ;...Z..# 31 2C 42 24 3A 8B 20 53 1,B*:. S

54 B3 Bl 30 20 A7 20 31 T..0 . 1 30 30 30 OO DE 04 64 OO OOO

50

-----------------------------------------------------Page 50-----------------------------------------------------
﻿
. DO: 8B 20 42 24 B3 Bl C7 28 . B*

. D8: 33 34 29 20 A7 20 39 30 34) . 90 . EO: OO 00 05 6E OO Al 23 31

. E8: 2C 42 24 3A 8B 20 42 24 ,B*:. B*

. FO: B3 Bl C7 28 33 34 29 A7 ___ . F8: 20 99 42 24 3B 3A 89 31 .B*;:.l

Not very recognizable is it? Remember this is C64 internal BASIC not a BASIC listing. Bytes 0 and 1 are of interest. They are the track and sector link that point to the next block in the program file. In this case, they point to track 16 ($10), sector 11 ($0B). Since this is the first data block of the file, bytes 2 and 3 are also important. They are the load address. We can see that the load address is $0401 or 1025 decimal. This file was written on a PET. (The start of BASIC memory on the C64 is at $0801. The VIC-20 begins at $1001, $1201, or $0401 depending ont he amount of external memory.) DIR will require a straight relocating load, i.e., LOAD "DIR",8. If you used a LOAD "DIR", 8,1 command, the program would be loaded into the screen RAM of the C64. NOTE: If you load this program properly, you will NOT be able to get it to VERIFY correctly. The reason is that the internal BASIC links were changed when the program was

relocated.

00: 10 OB 01 04 OD 04 04 00

** ** ** *♦

Let's follow the forward chain to track 16, sector 11 and take a look at the start of the

second block in our file.

TRACK 16 - SECTOR 11

00: 10 02 31 30 00 1C 05 78 ..10

08: 00 Al 23 31 2C 42 24 3A ..#1,B*:

10: 8B 20 42 24 B2 C7 28 33 . B*..(3

Nothing much of interest here. Let's chain to track 16 ($10), sector 02 ($02) and take

a look at the start of the next block.

TRACK 16 - SECTOR 02

00: 10 OC B2 22 22 3A 99 22 ..."":." 08: 3E 22 3B OO 1A 06 AB OF >";

10: Al 42 24 3A 8B 42 24 B2 .B«:.B*.

51

-----------------------------------------------------Page 51-----------------------------------------------------
﻿
Again, nothing much of interest. Chain to track 16 ($10), sector 12 ($0C).

TRACK 16 - SECTOR 12

oo: OO 68 8B 20 41 24 B2 22 ___ 08: 44 22 20 A7 20 31 30 OO D" . lO. 10: 2D 07 3C 28 8B 20 41 24 -.<(. A* 18: B2 22 2E 22 20 BO 20 41 . ". " . A 20: 24 B2 22 3E 22 20 BO 20 *.">" . 28: 41 24 B2 22 3E 22 20 A7 A*.">" . 30: 20 34 30 30 30 OO 3E 07 4000.>. 38: 46 28 8B 20 41 24 B2 22 F(. A*." 40: 51 22 20 A7 20 80 OO 52 Q" . ..R 48: 07 50 28 8B 20 41 24 B2 .P(. A*. 50: 22 53 22 20 A7 20 35 30 "S" . 50 58: 30 30 OO 5E 07 F7 2A 89 OO. ..*. 60: 20 31 30 31 30 30 OO OO 10100.. 68: OO AO OO Al 20 54 24 3A

70: 78:
 8B 20
 20 A7
 54 20
 24 8D
 B3 20
 Bl

32

22 30

22 30

. T*..""

. . 200

Now we're cooking. This is the last sector of the file. How can we tell? The track of

the next block in the file is 0 ($00). But what about the sector link? It's a misnomer. The sector link in the last block is actually a byte count. It informs the DOS that only bytes 2 through 104 ($68) are important in this example. Recall that an end of file in BASIC is designated by three zeros in a row. An End-or-Identify (EOI) signal will be sent once byte 104 has been transferred across the serial bus. When the C64 receives this EOI signal, the status variable, ST, will be set to a value of 64. (Any further at¬ tempt to read a byte will cause the drive to time out.) Here's the tail end of our pro¬ gram. The three null bytes, ($00), at $66/7/8 are the last three bytes in our program file.

oo: 08: 10: 18: 20: 28: 30: 38: 40: 48: 50: 58: 60: 68:
 00 44 2D B2 24 41

20 46 51

07 22 30 20 00

68 22 07 22 B2 24 34 28 22 50 53 30 31

XX

8B 20 3C 2E 22 B2 30 8B 20 28 22 00 30

XX

20 A7 28 22 3E 22 30 20 A7 8B 20 5E 31

XX

41

20 8B 20 22 3E 30 41

20 20 A7 07 30

XX

24 31

20 BO 20 22 OO 24 80 41

20 F7 30

XX

B2 30 41 20 BO 20 3E B2 OO 24 35 2A 00

XX

22 00 24 41

20 A7 07 22 52 B2 30 89 OO

XX

... A*." D" . 10. -.<(. A* . ". " . A

*.">" .

A*.">" .

4000.>.

F(. A*." Q" . ..R .P(. A*. "S" . 50 OO. ..*.

10100..

a

52

____

-----------------------------------------------------Page 52-----------------------------------------------------
﻿
What about the rest of the block? Ignore it. It is garbage. The DOS does not zero out a buffer before it begins filling it with new information sent from the computer. As a result, the last block in a file, which is almost never filled with new information, is padded with whatever happened to be left in the buffer from a previous read or write opera¬ tion. There are two exceptions to the rule, namely, the directory and relative files. A partial directory block is always padded with nulls ($00). Moreover, it always appears as a full block. Bytes 0 and 1 of the last directory block will contain a $00 and a $FF, respectively. Relative file structure will be explained shortly.

4.6 Sequential File Storage

The format of a sequential file is very straightforward. All the sectors, except the last

one, look like this:

TRACK LINK
 SECTOR LINK
 254 BYTES OF DATA

Byte

0 1

2-255

Purpose

Track of the next block in this file Sector of the next block in this file

254 bytes of data

The last block in a sequential file is special for two reasons:

1. It is the last sector.

2. It is usually only partially full.

To signal the DOS that this is the last block, the first byte is set to $00. The first byte is normally the track link. Since there is no track 0, the DOS knows that this is the last sector in the file. The second byte indicates the position of the last byte in the file. Any bytes beyond this position are garbage.

Diagrammatically, the last sector in the file looks like this:

NULL

$00

LAST BYTE

THE FINAL DATA BYTES IN

YOUB SEQUENTIAL FILE

GABBAGE

Byte

0 1

Purpose

Null byte to indicate this is the last sector Position of the last byte in the file (N)

2-N The last N-2 bytes of the sequential file (N + D-255 Garbage

53

-----------------------------------------------------Page 53-----------------------------------------------------
﻿
No sequential files appear on the 1541TEST/DEMO. (The file named SEQUENTIAL FILE is a program file demonstrating the sequential access method.) The C-64 DISK BONUS PACK does come with one sequential file on it. The file named " DIREC¬ TORY " appears as a SEQ when displaying the directory. " DIRECTORY " can be found at track 18, sector 01 on the C-64 DISK BONUS PACK. Let's take a peek at the directory entry for this file:

TRACK 18
 SECTOR 01

20: 00 OO 81 11 01 20 20 20

28: 44 49 52 45 43 54 4F 52 DIRECTOR 30: 59 20 20 20 AO 00 OO 00 Y 38: 00 OO 00 00 00 OO 02 OO

DIRECTORY " is the second file entry in the directory.

20: OO OO 81 11 Ol 20 20 20

** »* **

28: 44 49 52 45 43 54 4F 52 DIRECTOR 30: 59 20 20 20 AO OO OO 00 Y 38: 00 OO OO 00 OO 00 02 OO

**

A sequential file is designated by an $81 in the directory. The first block of this file is stored on track 17 ($11), sector 1 ($01). We also see that " DIRECTORY " is two blocks long (2 + 0 * 256). Let's take a look at the first half of the starting data block.

TRACK 17 - SECTOR Ol

OO

: 11

OB
 43

36

34

20

53

54

..C64 ST

os-

: 41

52

54

45

52

20

4B

49

ARTER KI

io

: 54

20
 20
 20
 36
 34
 20
 20
 T 64

18-

: 32

41

OD

31
 35
 34

31

20

2A.1541

20 28 30 38 40 48

: 42 : 4D : 4C : OD : 44

43

41 4F 45 42 20 41

43 52 OD 49 42 4C

4B 54 41

54 59 45

55 20 52 53 54 4E
 50 54 52 20 45 44
 OD 41 4F 41 53 41
 41

42 57 4E OD 52

BACKUP.A MORT TAB LE.ARROW .BITS AN D BYTES. CALENDAR

50:

: OD

43
 48

41

4E

47
 45
 20
 .CHANGE

58:
 44

49
 53
 4B
 OD
 43
 48
 41
 DISK.CHA

60:

: 52

20

42

4F

4F

54
 OD
 43
 R BOOT.C

68: 70: 78:

4F 54 4C

4C OD 4C
 4F 43 36
 52 4F 34
 20 50 OD
 54 59 44
 45 2D 45

53 41

4D

OLOR TES T.COPY-A LL64.DEM

54

-----------------------------------------------------Page 54-----------------------------------------------------
﻿
Bytes 0 and 1 are the track and sector link (forward pointer). They inform us that the next data block can be found at track 17, sector 11. The remaining 254 bytes are data. The sequential data that appear here are in fact the disk name (C64 STARTER KIT), the cosmetic disk ID (64), and the file names found on the C-64 DISK BONUS PACK. It is interesting to note that a carriage return character ($0D) was used as a delimiter to separate record entries. Next we see:

TRACK 17 - SECTOR 11

OO OO 86 2D 20 59 41 4E 4B ..- YANK OS 45 45 OD 53 4F 55 4E 44 EE.SOUND 10 20 2D 20 41 4C 49 45 4E - ALIEN 18 OD 53 4F 55 4E 44 20 2D .SOUND - 20 20 42 4F 4D 42 OD 53 4F BOMB.SO 28 55 4E 44 20 2D 20 43 4C UND - CL 30 41 50 OD 53 4F 55 4E 44 AP.SOUND 38 20 2D 20 47 55 4E 46 49 - GUNFI 40 52 45 OD 53 4F 55 4E 44 RE.SOUND 48 20 2D 20 50 4F 4E 47 OD - PONG. 50 53 4F 55 4E 44 20 2D 20 SOUND - 58 52 41 59 47 55 4E OD 53 RAYGUN.S 60 4F 55 4E 44 20 2D 20 53 OUND - S 68 49 52 45 4E OD 53 50 52 IREN.SPR 70 49 54 45 20 42 4F 4F 54 ITE BOOT 78 OD 53 55 50 45 52 4D 4F .SUPERMO 80 4E 36 34 2E 56 31 OD 59 N64.V1.Y 88 54 53 50 52 49 54 45 53 TSPRITES 90 AO AO AO AO AO OO 00 OO 98 00 OO 00 00 00 OO 05 OO AO 00 00 82 07 OO 53 4E 4F

A8 4F 50 59 20 4D 41 54 48 OPY MATH BO AO AO AO AO AO OO OO OO B8 00 OO 00 00 OO 00 33 00 CO 00 OO 82 ID OO 41 4D 4F

CS 52 54 20 54 41 42 4C 45 RT TABLE DO AO AO AO AO AO OO 00 OO D8 00 OO 00 OO 00 OO 27 00

EO

E8 FO F8

54 47 41 47 45 AO AO AO TGAGE... AO AO AO AO AO OO OO OO 00 00 00 00 OO 00 2D 00

We can see from the above data block that this is the last sector in the chain. Byte 0 contains a zero indicating no forward track. Byte 1 then is a byte count ($86=134). Byte 134 is the last byte in our data file. Recall that the status variable (ST) will be set to 64 on the C64 side after byte 134 has been read.

. 80: 4E 36 34 2E 56 31 OD xx N64.V1.

55

00 OO 82 05 02 4D 4F 52 . ____

-----------------------------------------------------Page 55-----------------------------------------------------
﻿
The remainder of the block has been padded ($87—$FF). The padding is clearly recognizable this time around. It has no rhyme or reason but it is still interesting to say the least. A portion of the C-64 DISK BONUS PACK directory itself was used to pad the remainder of the data block in question.

80 88 90 98 AO A8 BO B8 CO C8 DO D8 EO E8 FO F8

xx xx xx xx xx xx xx 59 N64.V1.Y 54 53 50 52 49 54 45 53 TSPRITES AO AO AO AO AO OO 00 00 00 00 00 00 00 00 05 OO OO OO 82 07 OO 53 4E 4F

4F 50 59 20 4D 41 54 48 OPY MATH AO AO AO AO AO 00 OO OO 00 00 OO OO 00 OO 33 00 00 00 82 ID 00 41 4D 4F

52 54 20 54 41 42 4C 45 RT TABLE AO AO AO AO AO OO OO 00 00 00 00 00 00 OO 27 00 OO OO 82 05 02 4D 4F 52

54 47 41 47 45 AO AO AO TGAGE... AO AO AO AO AO OO OO OO OO OO 00 00 00 00 2D OO

4.7 Relative File Storage

Relative file types have the most elaborate internal structure. Relative files are often referred to as random access files. A relative file is actually two files in one:

1. A sequential data file with records of a fixed length. 2. A file of track and sector pointers called side sectors.

The sequential data file uses fixed length records so that the DOS can calculate where to find any given record. This makes it possible to position to a particular record and read or write it without disturbing the rest of the file. In the jargon of relative files, the length of one record in the sequential data file is known as the record size.

The complete file of track and sectors pointers is called the side sector file. The size of this file depends on the length of the sequential file. In general it is l/120th the length of the sequential file (minimum length = 1 block; maximum length = 6 blocks). Each block in this file is known as a side sector. There are really two sets of track and sector pointers in this file. The larger set is a list of the track and sector numbers of the blocks used to store the sequential data file (its file chain). The other is a list of the track and sector numbers of the side sectors (the file chain of the side sector file).

The purpose of the side sector file is to allow the DOS to find any given record with remarkable efficiency. One disk read of a side sector is all that is required to locate the track and sector of the block where a particular record is stored. Two additional reads may then be required to retrieve a record itself if it spans two data blocks. This will be explained shortly when we examine records in more detail.

56

-----------------------------------------------------Page 56-----------------------------------------------------
﻿
Remember that sequential data blocks have the following format:

Byte

0 1

Purpose

Track of the next block in this file Sector of the next block in this file

2-255 254 bytes of data

Diagrammatically, each block (side sector) in the side sector file looks like this:

TRACK LINK

SECTOR LINK
 SIDE

SECTOR

RECORD SIZE
 TRACK/SECTOR LINKS FOR 6

TRACK/SECTOR LINKS FOR 120

NUMBER

SIDE SECTORS
 DATA BLOCKS

Byte

3

4-15

16-256

Purpose

Track of the next side sector Sector of the next side sector

Side sector number

Record length

Track and sector list of the side sector file

4-5 Track and sector of side sector #0 6-7 Track and sector of side sector #1 8-9 Track and sector of side sector #2 10-11 Track and sector of side sector #3 12-13 Track and sector of side sector #4 14-15 Track and sector of side sector #5

Track and sector list of 120 data blocks

16-17 Track and sector of data block #1 18-19 Track and sector of data block #2 20-21 Track and sector of data block #3

\

254-255 Track and sector of data block #120

To help you make some sense out of this, let's begin with the directory entry for a relative file. Here's the start of the directory of a diskette that has a relative file stored on it.

57

-----------------------------------------------------Page 57-----------------------------------------------------
﻿
00 08 10 18 20 28 30 38 40 48 50 58 60 68 70 78

TRACK 18 - SECTOR 01

OO FF 81 11 OO 53 43 20

31 4D 41 47 20 46 49 4C 1MAG FIL 45 AO AO AO AO 00 00 OO E 00 00 00 00 00 OO 01 00 OO OO 81 11 01 53 43 20

32 4D 41 47 20 46 49 4C 2MAG FIL 45 AO AO AO AO OO 00 00 E 00 00 00 00 00 00 01 00 00 OO 81 11 02 53 43 20

33 4D 41 47 20 46 49 4C 3MAG FIL 45 AO AO AO AO 00 OO OO E 00 OO OO 00 OO OO 01 OO

00 OO 84 11 03 4D 41 47 ..... MAG Here's the 20 46 49 4C 45 AO AO AO FILE ___ for the REL

AO AO AO AO AO 11 OD 96 00 OO OO 00 OO OO B4 Ol

"MAG FILE" will serve as our demo throughout this section. Let's examine its direc¬ tory entry in detail from track 18, sector 1.

. 60: 00 OO 84 11 03 4D 41 47

** »* »* File type and T/S link

. 68: 20 46 49 4C 45 AO AO AO FILE... . 70: AO AO AO AO AO 11 OD 96 . 78: 00 OO OO OO OO 00 B4 01

From the directory entry we can see that "MAG FILE" is a relative file. A relative file is indicated by an $84 as the file type. The track and sector pointers in the directory reveal that "MAG FILE" starts at track 17 ($11), sector 03 ($03). This is the sequential data file portion of the relative file. It is the beginning of our data.

70: AO AO AO AO AO

11 OD 96

♦* ** **

Side sector information

Record length

Side sector information follows the file name. The first side sector begins at track 17 ($11), sector 13 ($0D). In addition, we see our record length ($96=150). Each record in our sequential data file is 150 bytes long. This is fixed throughout the entire data file.

78: OO OO OO OO 00 OO B4 01

** ** File length (lo/hi-byte)

58

-----------------------------------------------------Page 58-----------------------------------------------------
﻿
Our sample relative file consumes a total of 436 blocks on the diskette (180 + 1 * 256). (There is still room for expansion.) We can determine the number of side sectors by simple divison. A side sector stores track and sector pointers for 120 data blocks of our sequential file. To determine the number of side sectors, simply divide the total number of blocks that appear in the directory entry by 120 and round up to the next higher integer:

436 / 120 = 3.6 -* 4

Four side sectors are needed to keep track of this much data. To figure out how many records currently exist requires a little more arithmetic. First we have to subtract the

number of side sectors from the total number of blocks.

436 - 4 = 432

Now we can determine the total number of data bytes currently in use by our sequen¬

tial file.

432 * 254 = 109728

Why 254 as a multiplier? Remember that the first two bytes of any data block are for¬ ward track and sector pointers (256 - 2 = 254). We finish our set of calculations by dividing this total by the fixed record length.

109728 / 150 = 731.52

A total of 731 records exist at the current time in "MAG FILE."

Let's examine the first side sector.

TRACK 17 - SECTOR 13 SIDE SECTOR #0

OO 08

10 18 20 28 30 38 40 48 50 58 60 68 70 78 80 88

OC 13 OO 96 11 OD OC 13 ........Forward pointer, SS #, 06 lO 13 OF OO OO OO OO ........ and 6 pairs of side sector

11 03 11 OE 11 04 11 OF ........ 120 pairs of data 11 05 11 10 11 06 11 11 ........

11 07 11 12 11 OS 11 13 11 09 11 14 11 OA 11 OB 11 OC lO OO 10 OA 10 14 10 08 lO 12 10 06 10 10 10 04 lO OE lO 02 lO OC lO 01 lO OB 10 03 10 OD 10 05 10 OF lO 07 lO 11 10 09 lO 13 OF 07 OF 11 OF 05 OF OF OF 03 OF OD OF Ol OF OB OF OO OF OA OF 14 OF 08 OF 12 OF 06 OF 10 OF 04 OF OE OF 02 OF OC OF 09 OF 13 OE 07 OE 11 OE 05 OE OF OE 03

59

-----------------------------------------------------Page 59-----------------------------------------------------
﻿
90 98 AO A8 BO B8 CO C8 DO D8 EO E8 FO F8
 OE OD OE 01 OE OB OE 00 OE OA OE 14 OE 08 OE 12 OE 06 OE lO OE 04 OE OE OE 02 OE OC OE 09 OE 13 OD 07 OD 11 OD 05 OD OF OD 03 OD OD OD Ol OD OB OD OO OD OA OD 14 OD 08 OD 12 OD 06 OD 10 OD 04 OD OE OD 02 OD OC OD 09 OD 13 OC 07 OC 11 OC 05 OC OF OC 03 OC OD OC Ol OC OB OC OO OC OA OC 14 OC 08 OC 12 OC 06 OC 10 OC 04 OC OE OC 02 OC OC

Of primary interest are the first 16 bytes.

. 00: OC 13 00 96 11 OD OC 13 . 08: 06 lO 13 OF OO OO 00 OO

Bytes 0 and 1 show us that the next side sector resides at track 12 ($0C), sector 19 ($13). Byte 2 informs us that this is side sector 0. A maximum of 6 side sectors are used by any one relative file. This is determined solely by the physical storage capacity of the diskette (664 blocks free after formatting divided by 120 track and sector pointers in a side sector equals 5.53 side sectors). Side sectors are numbered from 0 to 5. Byte 3 shows us the record size again (150 bytes). Bytes 5-15 are the track and sector locations of the six possible side sectors. They can be tabled as follows:

B YTE

4- 5 6- 7 8- 9 10-11 12-13 14-15

SIDE SECTOR

0 1 2 3 4 5

TRACK - SECTOR

17 ($11) - 13 ($0D) 12 ($0C) - 19 ($13) 6 ($06) - 16 ($10) 19 ($13) - 15 ($0F) 0($00)- 0($00) 0($00)- 0($00)

We can see from the table above that side sectors 4 and 5 have not yet been allocated. Once our data file expands to encompass more than 480 and 600 sectors, respectively, they will be allocated, provided there is room on the diskette.

The remaining 240 bytes are track and sector pointers to the first 120 blocks in the se¬ quential file. From bytes 16 and 17 of side sector 0 we see that our data begins at track 17 ($11), sector 03 ($03). (This is the track and sector recorded in the directory itself.) Track 17, sector 03 chains to track 17 ($11), sector 14 ($0E) which chains to track 17 ($11), sector 4 ($04) and so on.

60

-----------------------------------------------------Page 60-----------------------------------------------------
﻿
TRACK 17 - SECTOR 13 SIDE SECTOR #0

10: 11 03 11 OE 11 04 11 OF

** -**

18: 11 05 11 lO 11 06 11 11 20: 11 07 11 12 11 08 11 13 28: 11 09 11 14 11 OA 11 OB 30: 11 OC lO 00 10 OA 10 14 38: 10 08 10 12 lO 06 10 10 40: 10 04 10 OE 10 02 10 OC 48: 10 01 10 OB 10 03 10 OD 50: 10 05 lO OF lO 07 lO 11 58: 10 09 10 13 OF 07 OF 11 60: OF 05 OF OF OF 03 OF OD 68: OF 01 OF OB OF 00 OF OA 70: OF 14 OF OS OF 12 OF 06 78: OF 10 OF 04 OF OE OF 02 80: OF OC OF 09 OF 13 OE 07 88: OE 11 OE 05 OE OF OE 03 90: OE OD OE 01 OE OB OE OO 98: OE OA OE 14 OE 08 OE 12 AO: OE 06 OE 10 OE 04 OE OE A8: OE 02 OE OC OE 09 OE 13 BO: OD 07 OD 11 OD 05 OD OF B8: OD 03 OD OD OD Ol OD OB CO: OD OO OD OA OD 14 OD 08 C8: OD 12 OD 06 OD lO OD 04 DO: OD OE OD 02 OD OC OD 09 D8: OD 13 OC 07 OC 11 OC 05 EO: OC OF OC 03 OC OD OC Ol E8: OC OB OC OO OC OA OC 14 FO: OC 08 OC 12 OC 06 OC lO F8: OC 04 OC OE OC 02 OC OC

Let's trace the remaining side sectors now.

TRACK 12 - SECTOR 19 SIDE SECTOR #1

. 00: 06 lO 01 96 11 OD OC 13 . 08: 06 10 13 OF 00 OO OO OO . lO: OC 09 OB 13 OB 07 OB 11 . 18: OB 05 OB OF OB 03 OB OD . 20: OB 01 OB OB OB OO OB OA . 28: OB 14 OB 08 OB 12 OB 06 . 30: OB lO OB 04 OB OE OB 02 . 38: OB OC OB 09 OA 13 OA 07 . 40: OA 11 OA 05 OA OF OA 03 . 48: OA OD OA 01 OA OB OA OO . 50: OA OA OA 14 OA 08 OA 12

61

-----------------------------------------------------Page 61-----------------------------------------------------
﻿
58 60

: OA : OA

06 02
 OA OA
 10 OC

OA OA

04 09
 OA 09

OE 13

68-

• 09

07
 09
 11
 09
 05
 09
 OF

70

: 09

03
 09
 OD
 09
 01
 09
 OB

78:

: 09

00
 09
 OA
 09
 14
 09
 08

80 88 90 98 AO A8 BO B8 CO

C8:

: 09 : 09 : 08 : 08 : 08 . 08 : OS

08 : 07

07

12 OE 13 OF OB 08 04 09 05 01
 09 09 08 08 08 08 08 07 07 07

06 02 07 03 00 12 OE 13 OF OB
 09 09 08 08 OB 08 08 07 07 07
 10 OC

11

OD OA 06 02 07 03 OO

09 09 08 08 08 08 08 07 07 07
 04 09 05 01 14 lO

11

OA

do:

: 07

14
 07
 08
 07
 12
 07

06

D8
 07
 10

07

04
 07
 OE
 07
 02

EO:

: 07

OC
 07
 09
 06
 13

06

07

E8:
 06

11
 06

05

06
 OF
 06
 03

FO:

: 06

OD
 06
 01
 06
 OB

06
 OO

F8:

06

OA

06

14
 06

OB

06
 12

Side sector 1 looks OK on this end.

TRACK 06 - SECTOR 16

SIDE SECTOR #2

00

: 13

OF
 02
 96
 11

OD

OC
 13

08:

• 06

10

13
 OF
 OO
 OO
 OO

OO

10 18 20 28 30 38 40 48 50

: 06 . 06 : 05 . 05 : 05

05 : 05 ' 04 : 04

06 OE

11

OD OA 06 02 07 03

06 06 05 05 05 05 05 04 04
 02 09 05 Ol 14 10 OC

11

OD

06 05 05 05 05 05 05 04 04
 OC 13 OF OB 08 04 09 05 Ol
 06 05 05 05 05 05 04 04 04

07 03 OO

12 OE

13 OF OB

58-

: 04

OO
 04

OA
 04

14
 04
 08

60 68 70

: 04 : 04 : 03

12 OE

13

04 04 03

06 02 07
 04 04 03

10 OC

11

04 04 03
 04 09 05

78:

: 03

OF

03

03
 03
 OD
 03
 Ol

80

: 03

OB
 03
 00
 03
 OA
 03
 14

88:

: 03

08
 03
 12
 03
 06

03

90

: 03

04
 03

OE

03

02

03

OC

98:

: 03

09
 02

13

02

07

02
 11

AO

: 02

05
 02
 OF
 02
 03
 02
 OD

A8:

: 02

Ol

02
 OB
 02
 OO
 02

BO

: 02

14
 02
 08
 02
 12
 02

62

-----------------------------------------------------Page 62-----------------------------------------------------
﻿
B8: 02 10 02 04 02 OE 02 02 CO: 02 OC 02 09 01 13 01 07 C8: 01 11 01 05 Ol OF 01 03 DO: 01 OD 01 Ol 01 OB 01 OO D8: 01 OA 01 14 01 08 01 12 EO: 01 06 Ol 10 Ol 04 01 OE E8: 01 02 01 OC 01 09 13 OA FO: 13 00 13 OB 13 01 13 OC F8: 13 02 13 OD 13 03 13 OE

Side sector 2 seems to be in order too.

TRACK
 19

- SECTOR

15

SIDE SECTOR #3

oo: 08: io: 18: 20: 28: 30:
 OO 06

13 13 13 14 14

9F 10 04 07 09 OB OD

03

13 13 13 14 14 14

96 OF 10 12 00 02 04

11

00 13 13 14 14 14

OD 00 06 08 OA OC OE
 OC oo

13 13 14 14 14

13

11

Ol

03 05

38 40 48 50 58 60 68 70 78 80 88 90 98 AO AS BO B8 CO C8 DO D8 EO E8 FO F8

: 14 : 14 : 15 : 15 : 15 : 15 : 15 : 16 : 16 : 16 : 16 : 16 : 17 : OO : oo : oo : oo : 00 : 00 : 00 : 00 : OO : 00 : OO : 00

OF 11

OO 02 04 06 OS OA OC OE

10 12 01

00 OO OO OO OO OO OO 00 oo 00

oo 00

14 14 15 15 15 15 15 16 16 16 16 16 17 OO 00 00 OO oo 00 oo 00 oo oo oo oo
 06 08 OA OC OE 10 12 01

03 05 07 09 OB OO 00 00 00 00 00 OO 00 OO 00 OO oo

14 14 15 15 15 15 15 16 16 16 16 17 17 OO OO 00 00 OO 00 OO OO OO OO OO 00

10 12 01

03 05 07 09 OB OD OF

11

OO 02 00 OO OO OO OO OO 00 OO OO OO oo oo

14 14 15 15 15 15 16 16 16 16 16 17 17 00 00 OO 00 00 OO OO 00 OO OO OO oo

07 09 OB

OF 11

00 02 04 06 OB OA

00 00 OO OO 00 OO OO OO OO OO OO oo

63

-----------------------------------------------------Page 63-----------------------------------------------------
﻿
Hold it right there please. Bytes 0 and 1 should look familiar by now. Still thinking? (Hint: End of chain and a byte count.)

00: OO 9F 03 96 11 OD OC 13

Byte 1 of side sector 3 shows a byte count of 159 ($9F). Recall that bytes 16-255 in a side sector are a list of track and sector pointers to 120 data blocks. As a result, bytes 158 and 159 must be interpreted together. They point to the last block in our sequential data file in this instance. The last block is stored on track 23 ($17), sector 12 ($0C). Notice too, that the remainder of the side sector is padded with nulls. The remaining 96 bytes are in limbo until our relative file is expanded. Bytes 160 and 161 will then point to the next track and sector of data and so on. When side sector 3 is full, a new side sector will be created. Bytes 0 and 1 of side sector 3 will then point to side sector 4. Bytes 12 and 13 in side sectors 0, 1, and 2 will also be updated to reflect the creation of side

sector 4.

Now let's take a brief glance at the sequential file itself.

TRACK 17 - SECTOR 03

OO 08

10 18 20 28 30 38 40 48 50 58 60 68 70 78 80 88 90 98 AO A8 BO B8 CO CB DO

11 OE 4D 41 47 20 46 49 ..MAG FI 4C 45 OD 20 37 30 39 OD LE. 709. 20 36 OD D4 49 54 4C 45 6..ITLE OD C3 4F 4D 50 55 54 45 ..OMPUTE 52 OD CD 41 47 41 5A 49 R..AGAZI 4E 45 OD C9 53 53 55 45 NE..SSUE OD DO 41 47 45 OD C3 4F ..AGE..0 4D 4D 45 4E 54 OD OD OO MMENT OO OO 00 OO 00 OO OO OO OO OO OO OO OO 00 00 OO OO OO OO OO OO 00 oo oo OO OO OO OO OO OO 00 oo 00 OO OO OO OO 00 00 oo OO OO OO OO OO 00 oo oo OO OO OO 00 OO OO 00 oo OO 00 OO OO OO OO 00 oo 00 OO 00 00 00 oo oo oo OO 00 00 00 OO 00 OO 00 OO OO 00 00 OO OO 00 oo

20 31 35 30 20 OD 2E OD 150 ... 2E OD 2E OD 2E OD 2E OD 2E OD 2E OD 2E OD 2E OD 2E OD 2E OD 2E OD 2E OD 2E OD 2E OD 2E OD 2E OD 2E OD 2E OD 2E OD 00 00 OO OO OO OO OO OO OO OO 00 00 OO 00 00 00 OO OO

64

-----------------------------------------------------Page 64-----------------------------------------------------
﻿
. D8: OO OO OO OO OO OO OO OO . EO: 00 00 00 00 00 00 oo oo

. E8: OO 00 OO OO OO OO OO OO . FO: 00 00 OO OO OO 00 oo oo . F8: OO OO OO OO OO OO OO oo

The block reveals a typical sequential file. Bytes 0 and 1 are the chain. The first data block links to track 17 ($11), sector 14 ($0E). The next 150 bytes (2 - 151) constitute our first record. Note that the unused bytes within a record are written as nulls ($00) by the DOS so the record is always a fixed length. The content of individual records will vary enormously. This is program dependent so the data block in question contains whatever data was specified by the program used. This particular record is from a free form data base. It was reserved to for management information by the main program and contains the following data:

1. The name of our relative file ("MAG FILE"). 2. The number of active records (709). 3. The number of fields in use (6).

4. The field titles (TITLE, COMPUTER, MAGAZINE, ISSUE, PAGE, COMMENT).

In the sequential data file portion of a relative file, the record length (record size) is constant. In this case, the records are all 150 bytes long. Record number 2 begins at byte 152 ($98) and will extend on into the next data block. Two reads would be required to fetch the entire contents of this record. The first 104 bytes of the record will be found here, but the remaining 46 are in the next block of the file. Here they are.

TRACK 17 - SECTOR 14

00 08 lO 18 20 28 30 38 40 48 50 58 60 68 70 78 80 88 90 98 AO
 11 04 OO OO OO 00 OO OO OO OO OO 00 OO OO OO OO 00 OO 00 oo oo oo oo oo OO 00 OO 00 oo oo oo oo OO OO OO 00 oo oo oo oo OO OO 00 00 OO OO 00 00

D3 4F 55 4E 44 20 D3 59 .OUND -Y 4E 54 48 45 53 49 53 OD NTHESIS. 41 4C 4C OD C3 4F 4D 50 ALL..OMP 55 54 45 OD CA 41 4E 20 UTE..AN 38 33 OD 32 36 OD 2E OD 83.26... OD 2E OD 2E OD 2E OD 2E OD 2E OD 2E OD 2E OD 2E OD 2E OD 2E OD 2E OD 2E OD OO 00 OO OO 00 00 OO OO OO OO OO OO OO OO OO OO OO OO OO 00 00 00 oo OO 00 oo oo oo oo oo oo 00 OO 00 OO OO 00 oo oo 00 OO OO 00 OO 00 00 oo 00 00 OO 00 oo oo oo oo

65

-----------------------------------------------------Page 65-----------------------------------------------------
﻿
A8: OO OO 00 00 00 OO 00 00 BO: OO OO 00 00 00 OO OO oo B8: 00 00 00 OO OO OO 00 00 CO: OO OO 00 00 OO 00 D7 52

C8: 49 54 49 4E 47 20 D4 52 ITING -R DO: 41 4E 53 50 4F 52 54 41 ANSPORTA D8: 42 4C 45 20 C2 41 53 49 BLE .ASI EO: 43 OD 41 4C 4C OD C3 4F C.ALL..0 E8: 4D 50 55 54 45 OD CA 41 MPUTE..A FO: 4E 20 38 33 OD 33 36 OD N 83.36. F8: 2E OD OD 2E OD 2E OD 2E

Record number 2 is used again for management information by our data base. It simply contains the record length. One can see from the number of carriage returns ($0D) that while only 6 fields are in use, 21 were established by the main program. One can also see that a blank field from this data base is stored as a period ($2E = CHR$(46) = "."). Record number 3 begins at byte 48. It contains our first actual data. It would look like so:

Title:

Computer: Magazine:

Issue:

Page:

Comment:

Sound Synthesis

All

Compute (sic)

Jan 83 26

(none)

Just out of curiosity let's examine the last two sectors of our sequential file chain as reported in bytes 156-159 of side sector 3. Why two sectors? Our fixed length of 150 bytes dictates this. (A fixed record length of 1, 2, 127, or 254 would not span a given sector. The maximum length of a relative record is 254 bytes. 254 is the only number evenly divisible by these factors. A record length of 1 or 2 would be rather impractical.)

TRACK 23 - SECTOR 02

OO 08 lO 18 20 28 30 38 40 48 50 58 60 68 70 78

17 OC 00 OO OO 00 00 OO OO OO OO OO OO OO OO OO OO 00 OO OO OO OO 00 oo 00 OO OO 00 OO OO 00 oo OO OO OO OO OO OO 00 oo 00 oo oo oo oo oo oo oo OO 00 00 00 oo oo oo oo OO OO OO OO 00 oo oo oo OO 00 oo oo oo oo oo oo OO OO OO 00 oo oo oo oo oo oo oo oo oo oo oo oo OO OO 00 OO 00 oo oo oo oo oo oo oo oo oo oo oo 00 OO OO 00 00 00 OO 00 OO OO OO 00 oo oo oo oo OO OO 00 00 00 00 OO 00

66

-----------------------------------------------------Page 66-----------------------------------------------------
﻿
80: OO OO OO OO FF 00 OO OO 88: 00 OO 00 00 00 OO 00 00 90: 00 00 OO 00 OO OO 00 OO 98: 00 00 00 OO OO 00 OO OO AO: OO OO 00 OO OO OO OO 00 A8: 00 OO 00 00 OO 00 OO 00 BO: OO OO OO OO oo oo oo oo B8: 00 00 00 00 00 00 00 00 co: oo oo oo oo oo oo oo oo C8: OO OO OO 00 OO 00 oo oo do: oo oo oo oo oo oo oo oo D8: 00 OO OO 00 OO 00 OO OO eo: OO OO OO 00 oo oo oo oo E8: 00 00 OO 00 OO 00 OO OO FO: 00 OO 00 00 OO 00 00 oo F8: 00 OO 00 OO 00 00 00 OO

TRACK 23 - SECTOR 12

oo: OO Bl OO 00 OO OO oo oo 08: 00 OO 00 00 OO 00 OO 00 10: OO 00 OO OO OO 00 00 oo 18: 00 00 00 00 FF 00 OO OO 20: oo oo oo oo oo oo oo oo 28: 00 OO OO 00 OO 00 OO OO 30: OO 00 OO 00 oo oo oo oo 38: OO OO OO OO 00 00 OO OO 40: 00 00 00 00 00 00 OO 00 48: 00 00 OO OO OO OO 00 OO 50: 00 OO OO 00 oo oo oo oo 58: OO OO 00 00 OO OO OO 00 60: OO 00 OO OO OO OO 00 oo 68: 00 OO OO 00 OO OO OO OO 70: oo oo oo oo oo oo oo oo 78: 00 00 OO 00 00 OO OO 00 80: 00 OO 00 OO OO 00 OO 00 88: 00 00 OO OO OO OO OO OO 90: oo oo oo oo oo oo oo oo 98: OO OO OO OO OO OO OO OO AO: 00 00 00 00 OO 00 oo oo A8: OO OO OO OO OO 00 OO OO bo: 00 OO FF 00 OO OO 00 oo B8: oo oo oo oo oo oo oo oo co: oo oo oo oo oo oo oo oo C8: oo oo oo oo oo oo oo oo do: oo oo OO 00 00 OO OO 00 D8: OO OO 00 oo oo oo oo oo EO: 00 00 00 00 00 OO 00 00 E8: 00 00 oo oo oo oo oo oo FO: OO 00 OO 00 oo oo oo oo F8: oo oo oo oo oo oo oo oo

67

-----------------------------------------------------Page 67-----------------------------------------------------
﻿
An analysis of the preceding two sectors will all but end our discussion on relative file structure. Bytes 2-131 of track 23, sector 2 are the overflow of a previous record. Bytes 132-255 of this same track and bytes 2-27 of track 23, sector 12 make up the next record. This record is empty, as indicated by a 255 ($FF) in the first byte and nulls in the re¬ maining bytes. Track 23, sector 12 has no forward chain and a byte count of 177 ($B1). Our last record in the relative file ends at byte 177 (28-177). What is interesting is the padding beyond this point:

BO: xx xx FF OO OO OO OO OO B8: OO OO OO 00 OO OO OO OO CO: 00 00 00 00 00 oo oo oo ca: oo oo oo oo oo oo oo oo do: 00 OO 00 00 OO 00 OO 00 D8: 00 00 00 oo oo oo oo oo EO: 00 OO 00 00 00 00 OO 00 E8: OO OO 00 00 OO OO OO OO FO: OO OO 00 OO OO 00 00 oo F8: 00 oo oo oo oo oo oo oo

We would expect to find all nulls ($00). Byte 178 ($B2), however, shows an $FF, i.e., the start of a new record. The DOS is one step ahead of the game when expansion time rolls around. A partial record has already been created in this instance. The DOS need only calculate the difference between 255 and the byte count to determine the number of nulls that must follow to complete the record:

255 - 177 = 78 bytes already in existence

It then takes the record size to figure out the padding needed:

Total Record Length - Bytes in Existence = Nulls to Go

150 - 78 = 72

Slick!

We will close our section on relative file structure by taking a brief look at how the computer, or you, can locate a particular relative record. Pick a number, any number. Record number 4 you say. No problem if you know the record length.

First we find the appropriate side sector.

4-1 = 3 previous records

3 * 150 fixed length = 450th starting byte (i.e., 0 - 449 previous bytes)

450 / 254 = 1.7716535

INT (1.7716535) + 1 = pointer set 2

68

-----------------------------------------------------Page 68-----------------------------------------------------
﻿
Pointer set 2 / 120 sets of pointers in a side sector = 0.01666667

INT (0.01666667) = side sector 0

Where in side sector 0 is it? Easy.

Byte 14 + (pointer set 2 * 2 bytes in a pointer) = byte 18

Bytes 18 and 19 will contain the track and sector of our record.

Where in the actual data block is it? A piece of cake.

1.7716535 - INT(1.7716535) = remainder .7716535

2 (skip over bytes 0 and 1) + (.7716535 * 254 bytes of data) = byte 198

Still a disbeliever? Check it out yourself in the preceding hex dumps of track 17, sector

13 and track 17, sector 14.

4.8 User File Storage

A user file (USR) file is one that is designed by the user. This file type is designated by an $83 in the directory. Although a user file is a legal Commodore file type (USR), its use is quite rare. Using a USR file rather than a more common file type is for showmanship only.

A user file may have the structure of either a sequential file or a program file if it was created by the DOS. It may be structured entirely differently if it was created using direct-access techniques described in Chapter 5. Before you do something rash, remember that the DOS will expect to find the track and sector links in their normal places. If they are not there, all the blocks that make up your file will be earmarked as free in

the BAM whenever the disk is validated!

4.9 Deleted File Storage

A deleted file (DEL) has a file-type byte of $80 in the directory. This is not a scratched file ($00), but an undocumented Commodore file type (DEL). It is extremely rare. Only one vendor has dared use a DEL file on a commercial product to date. It was not a func¬ tional file and was placed on the diskette to intimidate users as part of a low level pro¬

tection scheme.

You cannot create a DEL file using an OPEN statement. You can only create a DEL file by changing the file-type byte of an existing file to $80 as described in the next sec¬ tion. Since a DEL file is really another file type in disguise, a DEL file may have the structure of either a sequential file or a program file. If it has the structure of a pro¬ gram file, it may be loaded using one of these commands:

LOAD "FILE NAME,DEL,R",8 (RELOCATED)

LOAD "FILE NAME,DEL,R",8,1 (NOT RELOCATED)

69

-----------------------------------------------------Page 69-----------------------------------------------------
﻿
If a DEL file is structured like a sequential file, it may be opened in read mode using the following command:

OPEN 2,8,2,"FILE NAME,DEL,R"

4.10 Locked Files

Earlier in this chapter you may have been surprised to see locked files of various form in the table of legal file types. Locked file types are once again an undocumented feature

of Commodore disk drives. A locked file cannot be scratched unless it is first unlocked.

Unfortunately, the DOS does not support the locking or unlocking of a file. You have to do-it-yourself by editing the file-type byte in the directory entry for that file. The program EDIT TRACK & SECTOR listed in Appendix C allows you to do this. We will not describe the technique here. See the section on Unscratching a File in Chapter 8 for instructions on how to edit the file-type byte. Use the values from the table below, rather than those listed in Chapter 8, when locking or unlocking a file.

File Type Normal Locked

Deleted

Sequential Program

User

Relative

DEL

SEQ

PRG USR REL

$80 $81 $82 $83 $84

DEL<

SEQ<

PRG< USR< REL<

$C0 $C1 $C2 $C3 $C4

The DOS determines whether or not a file is locked by checking bit 6 of the file-type byte. If it is set (1), the file is locked. Even if a file has been locked, it may be renamed or copied using normal disk commands.

Conclusion

The material covered in this chapter is primarily of academic interest. However, do not attempt to recover a blown file unless you thoroughly understand the structure of the directory and how files are stored.

70

-----------------------------------------------------Page 70-----------------------------------------------------
﻿
CHAPTER 5

DIRECT-ACCESS PROGRAMMING

5.1 Introduction to Direct-Access Programming

In Chapter 2 you learned how to use such DOS commands as NEW, SCRATCH, and VALIDATE, for diskette housekeeping. This chapter describes how to use another set

of DOS commands known as direct-access commands. These commands are not com¬

monly used in typical programming applications. However, they allow you to step beyond simple housekeeping chores to develop more powerful disk utility programs that do such things as:

Change a disk name or cosmetic ID.

Display a block availability map (the BAM). Display a directory.

Display a track and sector.

Chain through a directory entry.

Edit a track and sector.

Recover an inadvertently scratched file. Recover a damaged diskette. Duplicate a diskette. Copy a file.

Catalog a disk library.

As you grow with your 1541, the need for routines of this nature will become increas¬ ingly apparent, if it isn't already. This chapter illustrates the use of direct-access com¬ mands in simple programs. A basic understanding of the function of these commands is necessary to appreciate the routines found in subsequent chapters and Appendix C.

5.2 Beginning Direct-Access Programming

The 1541 DOS recognizes nine direct-access commands. These direct-access commands

and their functions are listed below.

Direct-Access Command Function

Block-Read (Ul) Read a data block into 1541 RAM. Buffer-Pointer (B-P) Set pointer to any byte in a disk buffer. Block-Write (U2) Write a data block from 1541 RAM to diskette.

71

-----------------------------------------------------Page 71-----------------------------------------------------
﻿
Memory-Read (M-R) Peek bytes out of 1541 RAM or ROM. Memory-Write (M-W) Poke bytes into 1541 RAM.

Block-Allocate (B-A) Set bit in BAM to indicate a sector is in use. Block-Free (B-F) Set bit in BAM to indicate a sector is not in use. Memory-Execute (M-E) Execute a 6502 routine stored in 1541 RAM

or ROM.

Block-Execute (B-E) Load and execute a 6502 routine in 1541 RAM.

More often than not, direct-access commands complement one another in actual use. For example, a sector can be read from disk using a Ul command, examined using a B-P or M-R command, altered using a B-P or M-R command, and rewritten to disk us¬ ing a U2 command.

The block-read (Ul), buffer-pointer, and block-write (U2) comands are the easiest to com¬ prehend and, as a result, the most widely used. The memory-read and memory-write commands represent a more sophisticated level of direct-access programming and are sometimes used in lieu of the buffer-pointer command. The block-allocate and block-free commands are used primarily for the maintenance of random access files. Random ac¬ cess files were the forerunner of relative files and are rarely used today. The memory- execute command is used at the guru level of disk programming and requires a rudimen¬ tary knowledge of both machine language and the innards of the 1541 to implement. The block-execute command, while documented by Commodore, is almost never used.

In order to use the commands mentioned above you will need to learn how to open a

direct-access data channel. The format of a direct-access OPEN statement is:

SYNTAX: OPEN *ile#, device*, channel*, ,,#"

EXAMPLE: OPEN 2,8,2,"#"

OPEN 1,8,l�,"*"

where

file# = the logical file number (1 to 127)

device* = 8

channel* = the secondary address of the associated open statement (2 to 14)

Opening a direct-access data channel establishes a communication link between the C64 and the 1541. In the first example, we opened logical file number 2 on the C64 side to device number 8 with a secondary address of 2 (channel number 2) on the 1541 side. The only time a channel number is ever referenced is as part of a direct-access com¬ mand, e.g., a block-read command (Ul). Data is always read from disk (GET* file*, INPUT* file*,) or written to disk (PRINT* file*,) by way of the logical file number of the direct-access OPEN statement NOT the channel number. The logical file number and the channel number do not have to match as they do in our first OPEN example. They are two separate entities. The logical file number which resides on the C64 side passes read or write commands to the channel number on the 1541 side. Any similarity

72

-----------------------------------------------------Page 72-----------------------------------------------------
﻿
between the logical file number and the channel number is for mnemonic purposes only. The second example is a perfectly legal direct-access OPEN statement. In this instance, we opened logical file number 1 (GET#1, PRINT#1,) to device number 8 with a second¬ ary address of 14 (channel number 14) on the 1541 side. Whether or not you use mnemonic OPEN statements is strictly a matter of personal preference.

We will begin our tutorial on direct-access programming with a quick review of the 1541 format explained in Chapter 3. The table below outlines the range of track and sector

numbers found on a diskette.

Zone

Track

Sector Range Number of Sectors

1 2 3 4
 1 - 17 18-24 25-30 31-35
 0-20 0- 18 0- 17 0- 16
 21

19 18 17

NOTE: If you attempt to access a track less than 1, a track greater than 35, or a sector out of range for a given track, you will get a DOS error message number 66, ILLEGAL

TRACK OR SECTOR.

5.3 Block-Read Command (Ul)

The block-read command (Ul) transfers the contents of a given track and sector to an area of disk RAM commonly referred to as a buffer or workspace. The format of a block- read command (Ul) is:

SYNTAX:

PRINT* file*.
 ■Ul"; channel*; drive*; track;

sector

ALTERNATE:

PRINT* file*, "Ul:" channel*; drive*; track;

sector

PRINT* file*, "Ul: channel*, drive*, track,

sector"

EXAMPLE:

print*15,"U1";2;o;18;o

where

file*

channel*

drive*

track

sector

= the logical file number of the command channel

= the secondary address of the associated open statement

= 0

= 1 to 35

= 0 to the range for a given track

73

-----------------------------------------------------Page 73-----------------------------------------------------
﻿
After a given track and sector has been transferred to a buffer with a block-read com¬ mand (Ul), the buffer pointer is automatically left in position 255. Bytes 0-255 of the buffer are now accessible from the starting position, i.e., byte 0. The GET* command is normally used to retrieve one byte at a time from the buffer by way of the logical

file number of the direct-access OPEN statement. The GET* command is used rather

than INPUT* because the data may contain null bytes, carriage returns and/or line feeds, commas, colons, or other control characters. When using the GET* command you must remember to test each incoming byte for equality with the null string "".A null byte must be converted to CHR$(0) or an ?ILLEGAL QUANTITY ERROR will result when you try to find the ASCII value of the byte. (The GET* command fails to make the necessary conversion for you.) The ASCII value of a byte is used to check for control characters. These characters are misinterpreted by the INPUT* command. The follow¬ ing example reads the block from track 18, sector 0 (the BAM) into disk RAM and prints

the contents to the screen.

lOO REM BLOCK-READ (Ul)

110 OPEN 15,8,15 120 PRINT*15,"I0"

130 INPUT*15,EN*,EM*,ET*,ES*

140 IF EN*<>"00"GOTO 290

150 OPEN 2,8,2,"*"

160 PRINT#15, ,,U1";2;0;18;0 170 INPUT*15,EN*,EM*,ET*,ES*

180 IF EN*0"00"GOTO 270 190 FOR 1=0 TO 255

200 GET*2,B*

21O IF B*=""THEN B*=CHR*(0) 220 A=ASC(B*)

230 PRINT ST,I,A,

240 IF A>31 AND A<96 THEN PRINT B*,

250 PRINT 260 NEXT I

270 CLOSE 2

280 INPUT*15,EN*,EM*,ET*,ES*

290 CLOSE 15 300 END

Line Range Description

110 Opens logical file number 15 (PRINT#15,) to device 8 with a

secondary address of 15 (command channel).

120 Initializes drive 0.

130-140 Query the error channel.

150 Opens logical file number 2 (GET#2,) to device 8 with a secondary

address of 2 (channel number 2) letting the 1541 assign a buffer

area.

160 Reads the block from drive 0, track 18, sector 0 into channel 2 buf¬

fer area.

170-180 Query the error channel.

190 Begin loop to read 256 bytes.

74

-----------------------------------------------------Page 74-----------------------------------------------------
﻿
200 Transfer a byte from channel 2 buffer area to C 64 memory by way

of the GET* command (GET* logical file number not the channel

number).

210 Test for equality with the null string "". 220 ASCII conversion of a byte.

230 Print the status variable (ST), our loop counter, and the ASCII

value of the byte.

240 Print the byte if it's within normal ASCII range.

250 Terminate comma tabulation.

260 Increment loop counter. 270 Close logical file number 2. 280 Suppress the error light. 290 Close logical file number 15.

300 End.

An explanation of programming technique is in order here. Initialization (line 120) is done prior to opening a direct-access data channel (line 150). Initialization automatically shuts down all direct-access data channels (2 -14) that are open on the 1541 side. The command channel (15) is not affected. Logical files still remain open on the C64 side, however. Any attempt to access a data channel after initialization results in a 70, NO CHANNEL error. The DOS attempts to rewrite the BAM each time a direct-access channel is closed (line 270). If a diskette is either write protected or DOS protected, the BAM is not rewritten and the error light remains on until cleared. Fortunately, no damage has been done to the data on the diskette. The error light is quite distracting nevertheless. You can suppress the error light after closing a direct-access data chan¬ nel simply by inputting the error number, message, track, and sector via the command

channel (line 280).

The alternate formats of the block-read command (Ul) in line 160 are:

print#15,"Ui:"2;0;i8;o

PRINT#15,"Ul:2,0,18,O"

Although the block-read command (Ul) comes in three basic flavors, line 160 uses the preferred format. It will be used in demonstration programs throughout the chapter for consistency. Alternate formats will appear in passing.

Additionally, lines 210-220 are often combined into one BASIC statement for the sake of efficiency:

A=ASC(B*+CHR*(O))

Recall that lines 210-220 are necessary because the GET* command does not interpret nulls correctly.

5.4 Buffer-Pointer Command (B-PJ

The buffer-pointer command allows access to any individual byte in a DOS buffer. Any byte from position 0 through 255 in the buffer may be read or overwritten. The format

of a buffer-pointer command is:

75

-----------------------------------------------------Page 75-----------------------------------------------------
﻿
SYNTAX:

PRINT* file*, "B-P"; channel*; byte position

ALTERNATE:

PRINT* file*, "B-P:" channel*; byte position PRINT* file*, "B-P: channel*, byte position"

EXAMPLE:

PRINT#15,"B-P";2;144

where

file* = the logical file number of the command channel

channel* = the secondary address of the associated open statement

byte position = 0 to 255

The following program displays a disk name by reading only bytes 144 to 159 from track 18, sector 0.

lOO REM BUFFER-POINTER

llO OPEN 15,8,15 120 PRINT#15,"IO"

130 INPUT#15,EN*,EM*,ET*,ES*

140 IF EN*0"00"GOTO 320

150 OPEN 2,8,2,"*"

160 PRINT*15,"Ul";2;0;18;0 170 INPUT*15,EN*,EM*,ET*,ES*

180 IF EN*O"00"G0T0 300

190 PRINT#15,"B-P";2;144

200 FOR 1=1 TO 16

210 GET#2,B*

220 IF B*=""THEN B*=CHR*(0) 230 A=ASC(B*)

240 IF A>127 THEN A=A-128

250 IF A<32 OR A>95 THEN A=63 260 IF A=34 THEN A=63 270 DN*=DN*+CHR*(A) 280 NEXT I

290 PRINT"<DOWN>DISK NAME: ";DN* 300 CLOSE 2

310 INPUT#15,EN*,EM*,ET*,ES*

320 CLOSE 15 330 END

Line Range Description

190 Sets channel 2 pointer to position 144 in the buffer area.

200-280 Concatenate (build) the disk name one byte at a time by jamming it

within printable ASCII range.

76

-----------------------------------------------------Page 76-----------------------------------------------------
﻿
The alternate formats of the buffer-pointer command in line 190 are:

PRINT#15,"B-P:"2;144

PRINT#15,"B-P:2,144"

5.5 Block-Write Command (U2)

The block-write command (U2) writes the data from a DOS buffer to any given track and sector on a diskette. The format of a block-write command (U2) parallels that of a block-read command (Ul). The format of a block-write command (U2) is:

SYNTAX:

PRINT* file*, "U2"; channel*; drive*; track;

sector

ALTERNATE:

PRINT* file*, "U2:" channel*; drive*; track;

sector

PRINT* file*, "U2: channel*, drive*, track,

sector"

EXAMPLE:

print*15,"U2";2;o;18;0

where

file* = the logical file number of the command channel

channel* = the secondary address of the associated open statement

drive* = 0

track = 1 to 35

sector = 0 to the range for a given track

The entire contents of a buffer are written to disk during the execution of a block-write command (U2). The position of the buffer-pointer is irrelevant. It is not referred to by the DOS during the execution of a block-write command (U2).

The first program listed below allows a disk name to be changed using a block-write command (U2). The second example allows you to edit the cosmetic disk ID that ap¬ pears in the BAM. NOTE: This program does not change the formatting ID that is embedded in the header block of every sector.

77

-----------------------------------------------------Page 77-----------------------------------------------------
﻿
100 REM EDIT DISK NAME 110 F0RI=1T016

120 PAD*=PAD*+CHR*(160) 130 NEXTI

140 PRINT" {CLR3EDIT DISK NAME - 1541" 150 PRINT"CD0WN>REMOVE <RVS>WRITE PROTEC T TABCROFF*"

160 PRINT"{DOWN>INSERT DISKETTE IN DRIVE

II

170 PRINT"*DOWN*PRESS <RVS3 RETURN<ROFF>

TO CONTINUE"

180 GETC*:IFC*=""THEN180 190 IFC*OCHR*(13)G0T0180 200 PRINT"OK"

210 0PEN15,8,15

220 PRINT#15,"I0"

230 INPUT*15,EN*,EM*,ET*,ES*

240 IFEN*="00"G0T0280

250 PRINT"CDOWN>"EN*", "EM*","ET*","ES*

260 CLOSE15 270 END

280 0PEN2,8,2,"#"

290 PRINT#15,"Ui";2;o;i8;o 300 INPUT*15,EN*,EM*,ET*,ES* 310 PRINT#15,"B-P";2; 2 320 GET*2,B*

330 IFB*=""THENB*=CHR*(O) 340 DOS=ASC(B*)

350 IFD0S=65G0T0390

360 PRINT"CDOWN*73,CBM DOS V2.6 1541,00,

00"

370 PRINT"<DOWN> <RVS>FAILEDCROFF}" 380 G0T0720

390 PRINT*15,"B-P";2;144

400 F0RI=1T016

410 GET#2,B*

420 IFB*=""THENB*=CHR*(O) 430 A=ASC(B*)

440 IFA>127THENA=A-128 450 IFA<320RA>95THENA=63 460 IFA=34THENA=63

470 ODN*=ODN*+CHR*(A) 480 NEXTI

490 PRINT" CD0WN3-0LD DISK NAME: ";ODN* 500 INPUT"CDOWN>NEW DISK NAME"jNDN*

510 IFLEN(NDN*)< >OANDLEN(NDN*)<17G0T0530

520 G0T0720

530 INPUT"{D0WN>ARE YOU SURE (Y/N) YCLE FT 3>";Q*

78

-----------------------------------------------------Page 78-----------------------------------------------------
﻿
540 IF0*O"Y"G0T0720

550 NDN*=LEFT*(NDN*+PAD*,16) 560 PRINT*15,"B-P";2;144 570 PRINT#2,NDN*;

580 PRINT#15."U2";2;O;18;0

590 INPUT#15,EN*,EM*,ET*,ES*

600 IFEN*="o6"GOT0640

610 PRINT"CDOWN3-"EN*", "EM*","ET*","ES*

620 PRINT"{DOWN* <RVS>FAILEDCROFF>" 630 G0T0720 640 CL0SE2

650 INPUT#15,EN*,EM*,ET*,ES* 660 PRINT*15,"I0"

670 INPUT*15,EN*,EM*,ET*,ES*

680 CLOSE15

690 PRINT"CDOWN>DONE!" 700 END

710 REM CLOSE 720 CL0SE2

730 INPUT#15,EN*,EM*,ET*,ES*

740 CLOSE15 750 END

Line Range

280

310-380 550 560 570 580 660

Description

Opens logical file number 2 (GET#2, PRINT#2,) to device 8 with a secondary address of 2 (channel number 2) let¬ ting the 1541 assign a buffer area. Query DOS version.

Pad new diskette name.

Reset channel 2 pointer to position 144.

Overwrite existing disk name in channel 2 buffer area. Write channel 2 buffer to drive 0, track 18, sector 0. Update the BAM ($0700-$07FF) to reflect a disk name

change.

The alternate formats of the block-write command (U2) in line 580 are:

print#15,"U2:"2;o;is;o

PRINT*15,"U2:2,0,18,0"

100 REM EDIT DISK ID

110 PRINT"<CLR>EDIT DISK ID - 1541"

120 PRINT"CD0WN>REMOVE £RVS>WRITE PROTEC

T TAB<ROFF>"

79

-----------------------------------------------------Page 79-----------------------------------------------------
﻿
130 PRINT"(DOWN*INSERT DISKETTE IN DRIVE

■■

140 PRINT"CD0WN>PRESS CRVS>RETURNCR0FF> TO CONTINUE"

150 GETC*:IFC*=""THEN150 160 IFC*< >CHR*(13)GOTO150 170 PRINT"OK"

180 0PEN15.8,15

190 PRINT#15,"I0"

200 INPUT*15,EN*,EM*,ET*,ES*

210 IFEN*="00"G0T0250

220 PRINT"<DOWN>"EN*", "EM*","ET*","ES*

230 CLOSE15 240 END

250 0PEN2,8,2,"*"

260 PRINT*15,"Ul";2;0;18;O 270 INPUT*15,EN*,EM*,ET*,ES* 280 PRINT#15,"B-P";2;2 290 GET#2,B*

300 IFB*=""THENB*=CHR*(O > 310 DOS=ASC(B*)

320 IFD0S=65G0T0360

330 PRINT"CD0WN>73,CBM DOS V2.6 1541,00,

00"

340 PRINT"CDOWN* *RVS>FAILEDCROFF>" 350 G0T0690

360 PRINT*15,"B-P";2;162

370 F0RI=1T02

380 GET*2,B*

390 IFB*=""THENB*=CHR*(O) 400 A=ASC(B*)

410 IFA>127THENA=A-128 420 IFA<320RA>95THENA=63 430 IFA=34THENA=63

440 ODI*=ODI*+CHR*(A) 450 NEXTI

460 PRINT"CDOWN>OLD DISK ID: ";ODI* 470 INPUT"<DOWN>NEW DISK ID";NDI*

480 IFLEN(NDI* X >OANDLEN(NDI* X 3G0T0500 490 G0T0690

500 INPUT"CD0WN3ARE YOU SURE (Y/N) YCLE FT 3>";Q*

510 IFQ*0"Y"GOT0690

520 NDI*=LEFT*(NDI*+CHR*(O),2 > 530 PRINT*15,"B-P";2;162 540 PRINT#2,NDI*;

550 PRINT*15,"U2";2;o;18;0 560 INPUT*15,EN*.EM*,ET*,ES*

570 IFEN*="00"G0T0610

580 PRINT"{DOWN*"EN*", "EM*","ET*","ES*

80

-----------------------------------------------------Page 80-----------------------------------------------------
﻿
590 PRINT"(DOWN* CRVS>FAILED*ROFF>" 600 G0T0690 610 CL0SE2

620 INPUT*15,EN*,EM*,ET*,ES* 630 PRINT#15,"IO"

640 INPUT*15,EN*,EM*,ET*,ES*

650 CLOSE15

660 PRINT"<D0WN>D0NE!" 670 END

680 REM CLOSE 690 CL0SE2

700 INPUT*15,EN*,EM*,ET*,ES*

710 CL0SE15 720 END

The alternate formats of the block-write command (U2) in line 550 are:

print*15,"U2:"2;o;i8;o

PRINT#15,"U2:2,0,18,0"

That's enough about the block-write command (U2) for now.

5.6 Memory-Read Command (M-R)

The memory-read command allows you to read the contents of any area of the 1541's RAM or ROM. You must specify in the memory-read command the memory address of RAM or ROM that you want to read. The format of a memory-read command is:

SYNTAX:

PRINT* file*, "M-R" CHR*(lo-byte) CHR*(hi -

byte) CHR*(# of bytes)

ALTERNATE:

PRINT* file*, "M-R:" CHR*(lo-byte) CHR*(hi -

byte) CHR*(* of bytes)

EXAMPLE:

PRINT*15,"M-R"CHR*(0)CHR*(3)

81

-----------------------------------------------------Page 81-----------------------------------------------------
﻿
where

file* = the logical file number of the command channel

lo-byte = lo-byte of the memory address

hi-byte = hi-byte of the memory address

# of bytes = 1 to 255

The third parameter of the memory-read command, CHR$(# of bytes), is undocumented by Commodore. The use of the third parameter is always optional. The default is CHR$(1), i.e., 1 byte.

Typically a block-read command (Ul) is issued prior to a memory-read command. A block- read command (Ul) transfers the data that is recorded on a given track and sector to one of four pages (256 bytes) of RAM. A page of RAM is called a buffer. When you open a direct-access data channel to the 1541 with OPEN 2,8,2,"*", the DOS arbitrarily selects one buffer as a workspace for that channel. As long as you use the GET* file* command or the PRINT* file* command from the associated OPEN statement you do not need to know which buffer the DOS is using. The buffer in use is only important when you issue a memory-read command. You may tell the DOS which buffer area to use in the direct-access OPEN statement itself. The format for selecting a buffer is:

SYNTAX:

OPEN file*, device*, channel*, "# buffer*"

EXAMPLE:

OPEN 2,8,2,"*0"

where

buffer* = 0 to 3

The table below shows how the buffer areas are organized in the 1541.

Buffer Number

0 1 2 3

Address

$0000 - $00FF $0100 - $01FF $0200 - $02FF $0300 - $03FF $0400 - $04FF $0500 - $05FF $0600 - $06FF $0700 - $07FF

Example

Not available (ZERO PAGE) Not available (STACK)

Not available (COMMAND BUFFER) OPEN 2,8,2,"#0" OPEN 2,8,2,"#1" OPEN 2,8,2,"#2" OPEN 2,8,2,"#3"

Not available (BAM)

82

-----------------------------------------------------Page 82-----------------------------------------------------
﻿
NOTE: Two or more direct-access data channels cannot share the same buffer area.

If you attempt to open a direct-access data channel to a buffer already in use a 70, a

NO CHANNEL error will result.

The GET* command is used following a memory-read command to retrieve the contents of the buffer you selected. There is one major difference, however. Bytes are now fetched over the command channel not the logical file number of the "OPEN file*, device*, channel*, buffer*" statement. Bytes must still be tested for equality with the null string "" and converted to CHR$(0) if need be.

The next program selects buffer #0 ($0300 - $03FF) as a workspace and does a block- read of track 18, sector 0. Bytes are returned to the C64 side from buffer #0 with memory- read and GET# commands, and printed to the screen.

lOO 110 120 130 140 150 160 170 180 190 200 210 220 230 240 250 260 270 280 290 300 310
 REM TWO PARAMETER MEMORY-READ

OPEN 15,8,15 PRINT*15,"IO"

INPUT*15,EN*,EM*,ET*,ES*

IF EN*0"00"GOTO 300

OPEN 2,8,2,"#0"

print*15,"Ui";2;o;18;0 INPUT*15,EN*,EM*,ET*,ES*

IF EN*0"00"GOTO 280 FOR 1=0 TO 255

PRINT*15,"M-R"CHR*(I)CHR*(3) GET*15,B*

IF B*=""THEN B*=CHR*(0)

A=ASC(B*)

PRINT I,A,

IF A>31 AND A<96 THEN PRINT B*,

PRINT

NEXT I

CLOSE 2

INPUT*15,EN*,EM*,ET*,ES*

CLOSE 15 END

Line Range Description

150 Opens logical file number 2 to device 8 with a secondary

address of 2 assigning buffer number 0 ($0300 - $03FF) as a workspace.

160 Reads the block from drive 0, track 18, sector 0 into

channel 2 buffer area ($0300 - $03FF).

190 Begin loop to read 256 bytes ($0300 - $03FF). 200 Indexed memory-read command ($0300 - $03FF). 210 Transfer a byte from channel 2 buffer area to C64

memory via the command channel (GET#15,).

83

-----------------------------------------------------Page 83-----------------------------------------------------
﻿
The alternate format of the standard memory-read command in line 200 is:

PRINT*15,"M-R:"CHR*(I)CHR*(3)

Please note that we deliberately omitted the third parameter of the memory-read com¬ mand in the preceding example. The following example incorporates all three parameters of the memory-read command to read a disk name.

lOO REM THREE PARAMETER MEMORY-READ

HO OPEN 15,8,15 120 PRINT#15,"10"

130 INPUT*15,EN*,EM*,ET*,ES*

140 IF EN*0"00"GOTO 320

150 OPEN 2,8,2,"#1"

160 print#15,"Ul";2;0;i8;o 170 INPUT#15,EN*,EM*,ET*,ES*

180 IF EN*0"00"GOTO 300

190 PRINT*15,"M-R"CHR*(144)CHR*(4)CHR*(1

6)

200 FOR 1=1 TO 16

210 GET#15,B*

220 IF B*=""THEN B*=CHR*(0) 230 A=ASC(B*)

240 IF A>127 THEN A=A-128

250 IF A<32 OR A>95 THEN A=63 260 IF A=34 THEN A=63 270 DN*=DN*+CHR*(A) 280 NEXT I

290 PRINT"{DOWN>DISK NAME: ";DN*

300 CLOSE 2

310 INPUT#15,EN*,EM*,ET*,ES*

320 CLOSE 15 330 END

Line Range Description

150 Opens logical file number 2 to device 8 with a secondary

address of 2 assigning buffer number 1 ($0400 - $04FF) as a workspace.

160 Reads the block from drive 0, track 18, sector 0 into

channel 2 buffer area ($0400 - $04FF).

190 Memory-read command ($0490 - $049F). 200 Begin loop to read 16 characters.

210 Transfer a byte from channel 2 buffer area to C64

memory over the command channel (GET#15,).

Inclusion of the third memory-read parameter means that we no longer have to issue a memory-read command to fetch each byte like we did in the first sample program. Instead, we establish a loop after the memory-read command to pull a byte in. (See lines

84

-----------------------------------------------------Page 84-----------------------------------------------------
﻿
200-280 above.) The alternate format of the three parameter memory-read command

in line 190 is:

PRINT#15,"M-R:"CHR*(144)CHR*(4)CHR*(16)

5.7 Memory-Write Command (M-W)

The memory-write command is the opposite of the memory-read command. Data is writ¬ ten to a DOS buffer via the command channel. The format of a memory-write command is:

SYNTAX:

PRINT* file*, "M-W" CHR*(lo-byte) CHR*(hi-

byte) CHR*(# of bytes) data

ALTERNATE:

PRINT* file*, "M-W:" CHR*(lo-byte) CHR*(hi-

byte) CHR*(# of bytes) data

EXAMPLE:

PRINT#15,"M-W"CHR*(2)CHR*(5)CHR*(2)CHR*(1)

CHR*(8)

PRINT*15,"M-W"CHR*(2)CHR*(5)CHR*(2)CHR*(1)D*

where

file* = the logical file number of the command channel

lo-byte = lo-byte of the memory address

hi-byte = hi-byte of the memory address

# of bytes = 1 to 34

data = a string variable or a CHR$ iteration

A total of 34 data bytes may be written with each issuance of a memory-write command. Typically only 8, 16, or 32 data bytes are sent out at one time in a loop as our buffer size (256 bytes) is evenly divisible by these factors. At the most sophisticated level of disk programming, machine language programs can be poked into RAM inside the 1541 with a memory-write command and then executed. (See Chapter 7 for actual programs of this nature.) In practice, however, one encounters limited use of the memory-write

command.

The following example demonstrates the use of the memory-write command. It allows you to change the load address of a program file. A routine of this nature would be used to aid in the disassembly of a program that normally loads into high memory (e.g., $8000-$BFFF) and is already occupied by a machine language monitor program

(SUPERMON64) or ROM.

85

-----------------------------------------------------Page 85-----------------------------------------------------
﻿
100 REM EDIT LOAD ADDRESS 110 H*="0123456789ABCDEF"

120 PRINT"CCLR3-EDIT LOAD ADDRESS - 1541"

130 PRINT"{DOWN3REMOVE CRVS>WRITE PROTEC T TABCROFF>"

140 PRINT"CDOWN>INSERT DISKETTE IN DRIVE

II

150 PRINT"£DOWN>PRESS CRVS3RETURNCR0FF3

TO CONTINUE"

160 GETC*:IFC$=""THEN160 170 IFC*OCHR*(13)G0T0160 180 PRINT"OK"

190 0PEN15,8,15

200 PRINT*15,"I0"

210 INPUT*15,EN*,EM*,ET*,ES*

220 IFEN*="00"G0T0260

230 PRINT"*DOWN!"EN*", "EM*","ET*","ES*

240 CLOSE15 250 END

260 PRINT*15,"M-R"CHR*(1)CHR*(1) 270 GET#15,D0S*

280 IFDOS*=""THENDOS*=CHR*(O) 290 DOS=ASC(DOS*)

300 IFD0S=65G0T0330

310 PRINT"CD0WN>73,CBM DOS V2.6 1541,00,

00"

320 G0T0910

330 INPUT"CDOWN>FILENAME";F*

340 1FLEN(F* X >0ANDLEN(F* X17G0T0360 350 G0T0920

360 0PEN2,8,2,"0:"+F*+",P,R" 370 INPUT#15,EN*,EM*,ET*,ES*

380 IFEN*="O0"G0T040O 390 G0T0940

400 PRINT*15,"M-R"CHR*(24)CHR*(O)CHR*(2)

410 GET#15,T*

420 T=ASC(T*+CHR*(O))

430 GET#15,S*

440 S=ASC(S*+CHR*(O)) 450 CL0SE2

460 INPUT#15,EN*,EM*,ET*,ES*

470 IFEN*="00"G0T0490 480 G0T0900

490 0PEN2,8,2,"*2"

500 PRINT#15,"U1";2;o;t;s

510 INPUT#15,EN*,EM*,ET*,ES*

520 IFEN*="00"G0T0540 530 G0T0900

86

-----------------------------------------------------Page 86-----------------------------------------------------
﻿
540 PRINT#15,"M-R"CHR*(2)CHR*(5)CHR*(2) 550 GET*15,LOW*

560 LOW=ASC(LOW*+CHR*(O))

570 GET*15,HIGH*

580 HIGH=ASC(HIGH*+CHR*(0)) 590 D=HIGH

600 GOSUB1010 610 OLA*=HD* 620 D=LOW

630 G0SUB1010

640 0LA*=0LA*+HD*

650 PRINT"{DOWN}OLD LOAD ADDRESS: ";OLA*

660 INPUT"{DOWN}NEW LOAD ADDRESS";NLA* 670 IFLEN(NLA*)=4G0T0690 680 G0T0960

690 INPUT" {DOWN} ARE YOU SURE (Y/N) Y{LE FT 3>";Q*

700 IF0*O"Y"G0T0960

710 HD*=RIGHT*(NLA*,2)

720 G0SUB1060

730 IFTME=1G0T0960 740 LOW=D

750 HD*=LEFT*(NLA*,2)

760 G0SUB1060

770 IFTME=1G0T0960 780 HIGH=D

790 PRINT#15,"M-W"CHR*(2)CHR*(5)CHR*(2)C

HR*(LOW)CHR*(HIGH)

800 PRINT*15,"U2";2;o;T;s

810 INPUT*15,EN*,EM*,ET*,ES*

820 IFEN*="00"G0T0S40 830 G0T0940 840 CL0SE2

850 INPUT*15,EN*,EM*,ET*,ES*

860 CLOSE15

870 PRINT"CDOWN}DONE!" 880 END

890 REM CLOSE

900 PRINT"{DOWN*"EN*", "EM*","ET*","ES*

910 PRINT"CDOWN}{RVS}FAILED{ROFF}" 920 CLOSE15 930 END

940 PRINT"{DOWN}"EN*", "EM*","ET*","ES*

950 PRINT"{DOWN}{RVS}FAILED{ROFF}" 960 CL0SE2

970 INPUT#15,EN*,EM*,ET*,ES*

980 CLOSE15 990 END

1000 REM DECIMAL TO HEXADECIMAL 1010 H=INT(D/16)

87

-----------------------------------------------------Page 87-----------------------------------------------------
﻿
1020 1030 1040 1050 1060 1070 1080 1090 1 = 16 1100

L=D-(H*16)

HD*=MID*(H*,H+1,1)+MID*(H*,L+1,1)

RETURN

REM HEXADECIMAL TO DECIMAL TME=0 H=0

F0RI=1T016

IFLEFT*(HD*,1)=MID*(H*,1,1)THENH=I:

NEXTI

1110

IFH=OTHENTME=

l:GOTO1200

1120 1130 1140 1150
 H=H-1 L=0

F0RI=1T016

IFRIGHT*(HD*,1)=MID*(H*,I,1)THENL=I

-.1 = 16

1160 NEXTI

1170 IFL=0THENTME=1 1180 L=L-1

1190 D=H*16+L 1200 RETURN

GOTO1200

Line Range

260-320 330-350 360-390

400-440 450 490

500

540

550 570

590-640 660-700 710-780 790

800

Description

Query DOS version ($0101). Input file n�me.

Opens logical file number 2 to device 8 with a secondary address of 2 for a program read.

Fetch file name track ($0018) and sector ($0019). Close logical file number 2.

Reopens logical file number 2 to device 8 with a second¬ ary address of 2 assigning buffer number 2 ($0500 - $05FF) as a workspace.

Reads the starting block of the filename from drive 0 as specified by $0018 and $0019 into channel 2 buffer area ($0500 - $05FF).

Three parameter memory-read command to fetch two byte load address ($0502 - $0503). Fetch lo-byte of load address ($0502). Fetch hi-byte of load address ($0503).

Decimal to hexadecimal conversion of load address.

Input new load address.

Hexadecimal to decimal conversion of new load address.

Memory-write of new two byte load address ($0502 - $0503).

Write channel 2 buffer ($0500 - $05FF) to drive 0, track ($0018), sector ($0019).

88

-----------------------------------------------------Page 88-----------------------------------------------------
﻿
The alternate format of the memory-write command in line 790 is:

PRINT#15,"M-W:"CHR*(2)CHR*(5)CHR*(2)CHR*(LO)

CHR*(HI)

5.8 Block-Allocate Command (B-A)

The block-allocate command allocates a sector in the BAM as in use. A sector is allocated

by setting its associated bit low (0) on track 18, sector 0. (Review the coverage on bit mapping in Chapter 4 if necessary.) The DOS will not write to an allocated sector dur¬ ing a normal write operation such as a SAVE. However, an allocated sector can be over¬ written with a block-write command (U2). Hence the origin of the term "direct-access."

The format of a block-allocate command is:

SYNTAX:

PRINT* file*, "B-A"; drive*; track; sector

ALTERNATE:

PRINT* file*, "B-A:"; drive*; track; sector

EXAMPLE:

PRINT*15,"B-A";0;l;7

where

file* = the logical file number of the command channel

drive* = 0

track = 1 to 35

sector = 0 to the range for a given track

The following program allocates every sector on a diskette. Run this program on a test

diskette.

lOO REM BLOCK-ALLOCATE

110 OPEN 15,8,15 120 PRINT*15,"IO"

130 INPUT*15,EN*,EM*,ET*,ES*

140 IF EN*0"00"GOTO 310

ISO OPEN 2,8,2,"*"

160 T=l 170 S=0

180 print#15,"B-A";o;t;s

190 INPUT#15,EN*,EM*,ET*,ES*

89

-----------------------------------------------------Page 89-----------------------------------------------------
﻿
200 IF EN*="00"G0T0 180 210 IF EN*O"65"G0T0 330 220 BA=BA+1

230 PRINT T,S,BA

240 T=VAL(ET*)

250 IF T=0 GOTO 290

260 IF T=18 THEN T=19:S=0:GOTO 180 270 S=VAL(ES*) 280 GOTO 180 290 CLOSE 2

300 INPUT*15,EN*,EM*,ET*,ES*

310 CLOSE 15 320 END

330 PRINT"{DOWN}"EN*", "EM*","ET*

340 CLOSE 2

350 INPUT#15,EN*,EM*,ET*,ES*

360 CLOSE 15 37O END

","ES*

Line Range

150 160 170 180 190 200 210 220

230 240

250

260 270

280 290

330-370

Description

Open a direct-access channel.

Initialize track to 1. Initialize sector to 0.

Block-allocate command.

Query error channel.

The track and sector were not allocated.

Something is amiss so bail out.

Counter representing the number of sectors allocated in

line 170.

Print track, sector, counter.

The sector just allocated already was but the DOS

returns the next available track in the error message (65, NO BLOCK, track, sector).

If the next available track is zero then all 683 blocks on the diskette have been allocated.

Don't allocate the directory.

The DOS returns the next available sector in the error

message (65, NO BLOCK, track, sector).

Allocate the next available track and sector. Close the direct-access channel. Error handler.

The alternate format of the block-allocate command in line 180 is:

PRINT*15,"B-A:";0;T;S

The opening of a direct-access channel (line 150) is standard form. Why? Because the BAM is rewritten to a diskette when a direct-access data channel is closed (line 290).

90

-----------------------------------------------------Page 90-----------------------------------------------------
﻿
In reality, though, the BAM is updated on the fly but very erratically. Thus, opening and closing a direct-access data channel is a good habit to get into. An ounce of prevention . . .

By the way, what happens when you try to save to a full disk? Error 72, DISK FULL right? Would you believe error 67, ILLEGAL TRACK OR SECTOR,36,01? Track 36? That's right. An error 72 only occurs during normal write mode (i.e., not a direct-access write) where at least 1 free block exists at the outset or the directory is at its physical limit, i.e., 144 active file entries.

A block remains allocated until a diskette is validated. Unless a given track and sector somehow chains to a directory entry its bit will be freed (1) during validation. (See the validate command in Chapter 2.) Caution must be taken to ensure that the block-allocate command does not allocate an unused sector in the directory. See line 260 above. Once a sector has been allocated in the directory, it is never deallocated by the DOS, even during a validate. An allocated directory sector can only be freed under software control.

The following program makes use of the block-allocate command to certify a formatted diskette. A worst-case binary pattern is written to any sector not currently in use. Bad sectors, if any, are allocated in the BAM. However, these bad sectors will be deallocated if the diskette is ever validated. (Sorry, but that's the nature of the beast.)

100 REM CERTIFY A DISKETTE - 1541 110 F0RI=1T032

120 NULL*=NULL*+CHR*(O)

130 WRITE*=WRITE*+CHR*(15) 140 NEXTI

150 DIMT7.(681),S7.(681)

160 PRINT"{CLR} CERTIFY A DISK

ETTE"

170 PRINT"{DOWN} {RVS}WAR

NING{ROFF}"

180 PRINT"{DOWN}{RVS}RANDOM ACCESS{ROFF} AND {RVS}DEL{ROFF} FILES WILL BE LOST" 190 PRINT"REMOVE {RVS}WRITE PROTECT TAB{

ROFF}"

200 PRINT"{DOWN}INSERT DISKETTE IN DRIVE

il

210 PRINT"{DOWN}PRESS {RVS3RETURN{R0FF} TO CONTINUE"

220 GETC*:IFC*=""THEN220 230 IFC*< >CHR*(13)G0T0220 240 PRINT"OK"

250 0PEN15,8,15

260 PRINT#15,"IO"

270 INPUT*15,EN*,EM*,ET*,ES*

280 IFEN*="0O"GOTO33O

290 PRINT"{DOWN}"EN*", "EM*","ET*","ES*

300 CLOSE15 310 END

91

-----------------------------------------------------Page 91-----------------------------------------------------
﻿
320 REM BAM

330 PRINT#15,"M-R"CHR*(0)CHR*(7)CHR$(192

)

340 F0RI=0T0191

350 GET#15,B*

360 IFB*=""THENB*=CHR*(0) 370 BAM*=BAM*+B* 380 NEXTI

390 D0S=ASC(MID*(BAM*,3,1)>

400 IFD0S=65G0T0460 410 CL0SE15

420 PRINT"{D0WN373,CBM DOS V2.6 1541,00,

00"

430 PRINT"{DOWN}{RVS}FAILED{ROFF}" 440 END

450 REM BUFFER 460 1=0

470 FORJ=lT08

480 PRINT*15,"M-W"CHR*(I)CHR*(4)CHR*(32)

WRITE*

490 1=1+32 500 NEXTJ 510 T=l 520 S=0 530 C=0 540 A=0

550 PRINT#15,"B-A";0;T;S

560 INPUT*15,EN*,EM*,ET*,ES*

570 IFEN*="00"G0T0620 580 T=VAL(ET*)

590 IFT=OANDC=060T0760 600 IFT=OG0T08OO 610 S=VAL(ES*)

620 T*=RIGHT*("O"+RIGHT*(STR*(T),LEN (STR *(T))-1),2)

630 S*=RIGHT*("O"+RIGHT*(STR*(S),LEN(STR *(S))-l),2)

640 C=C+1

650 IFC=1THENPRINT"{UP} "

660 PRINT#15,"B-A";0;T;S

670 PRINT"{HOME}{DOWN 6}{RVS}CERTIFYINGt ROFF} TRACK ";T*;" - SECTOR ";S*

680 PRINT"{DOWN}NUMBER OF SECTORS CERTIF IED :";C

690 PRINT"{DOWN}NUMBER OF BAD SECTORS AL LOCATED:";A

700 G0SUB1030

710 IFE=1G0T0550 720 A=A+1

730 T7-(A)=T

92

-----------------------------------------------------Page 92-----------------------------------------------------
﻿
740 S7-(A)=S 750 G0T0550 760 CLOSE15

770 PRINT"{D0WN3ALL SECTORS HAVE BEEN AL LOCATED"

780 PRINT"{DOWN}{RVS}FAILED{ROFF}" 790 END 800 1=0

810 FORJ=lT06

820 PRINT*15,"M-W"CHR*(I)CHR*(4)CHR*(32) MID*(BAM*,1+1,32)

830 1=1+32 840 NEXTJ

850 PRINT*15,"M-W"CHR*(192)CHR*(4)CHR*(3

2)NULL*

860 PRINT*15,"M-W"CHR*(224)CHR*(4)CHR*(3

2)NULL*

870 T=18 880 S=0

890 G0SUB1030

900 PRINT#15,"I0"

910 INPUT#15,EN*,EM*,ET*,ES*

920 IFAO0G0T0960 930 CLOSE15

940 PRINT"{DOWN}NO BAD SECTORS!" 950 END

960 FORI=1TOA

970 PRINT#15, "B-A" ; 0; T7. (I) ; 37. (I )

980 NEXTI

990 CLOSE15

100O PRINT"{DOWN}DONE!" 1010 END

1020 REM SEEK 1030 J0B=176

1040 G0SUB1120

1050 IFE=lG0TOlO80 1060 RETURN

107O REM WRITE 1080 JOB=144

1090 G0SUB1120 llOO RETURN

1110 REM JOB QUEUE 1120 TRY=0

1130 PRINT*15,"M-W"CHR*(8)CHR*(0)CHR*(2)

CHR*(T)CHR*(S)

1140 PRINT*15,"M-W"CHR*(1)CHR*(O)CHR*(1)

CHR*(JOB)

1150 TRY=TRY+1

1160 PRINT*15,"M-R"CHR*(1)CHR*(O) 1170 GET#15,E*

93

-----------------------------------------------------Page 93-----------------------------------------------------
﻿
1180 IFE*=""THENE*=CHR*(0) 1190 E=ASC(E*)

1200 IFTRY=500G0T01220 1210 IFE>127G0T01150 1220 RETURN

Line Range Description

330-380 Store the BAM ($0700 - $07A0). 390-440 Query DOS version.

460-500 Write worst-case binary pattern to buffer at $0400. 510-540 Initialize track, sector, and counters.

550 Block-allocate command.

700 Write worst-case binary pattern at $0400 - $04FF to a

deallocated track and sector.

710 Query error channel. 720-740 Error array.

800-890 Restore the BAM.

960-980 Allocate any bad sectors in error array.

The alternate format of the two block-allocate commands above are:

550 print#15,"B-a:";o;T;S

970 PRINT*15, "B-A: "; o; T7. (I); S7. (I )

Lines 330-380 and 800-890 compensate for a bug in the block-allocate command. (See Chapter 9 for the lowdown.) Lines 330-380 store an image of the BAM in C64 RAM. The BAM is restored in lines 800-890. Lines 1020-1230 will be explained in detail in Chapter 6 on intermediate disk programming techniques.

5.9 Block-Free Command (B-F)

The block-free command deallocates (frees) a sector in the BAM. A sector is deallocated by setting its associated bit high (1) on track 18, sector 0. The format of a block-free

command is:

SYNTAX:

PRINT* file*, "B-F"; drive*; track; sector

ALTERNATE:

PRINT* file*, "B-F:"; drive*; track; sector

EXAMPLE:

PRINT#15,"B-F";O;1;7

94

-----------------------------------------------------Page 94-----------------------------------------------------
﻿
where

file* = the logical file number of the command channel

drive* = 0

track = 1 to 35

sector = 0 to the range for a given track

The following program deallocates every sector on a diskette. Run this program on a

test diskette.

100 REM BLOCK-FREE

110 OPEN 15,8,15

120 PRINT#15,"10"

130 INPUT#15,EN*,EM*,ET*,ES*

140 IF EN*0"00"GOTO 260

150 OPEN 2,8,2,"#"

160 FOR T=l TO 35

170 IF T=18 GOTO 240

180 NS=20+2*(T>17)+(T>24)+(T>30) 190 FOR S=0 TO NS

200 print#15,ub-F";o;t;s

21O BF=BF+1

220 PRINT T,S,BF

230 NEXT S 240 NEXT T 250 CLOSE 2

260 INPUT#15,EN*,EM*,ET*,ES*

270 CLOSE 15 280 END

Line Range _ _

150 Open a direct-access channel. 160 Begin loop for tracks 1 to 35. 170 Don't deallocate the directory. 180 Calculate sector range.

190 Begin loop for sectors 0 to sector range.

200 Block-free command.

210 Counter to indicate number of blocks freed.

220 Print track, sector, counter.

250 Close the direct-access channel.

The alternate format of the block-free command in line 200 is:

PRINT*15,"B-F:";0;T;S

95

-----------------------------------------------------Page 95-----------------------------------------------------
﻿
The opening and closing of a direct-access channel is essential if the block-free command is to work correctly. Experimentation in freeing a full diskette reveals that tracks 34 and 35 still remain allocated if this procedure is not followed.

5.10 Memory-Execute Command (M-E)

The memory-execute command is used to execute any standard ROM routine or, at the pinnacle of disk programming, a custom machine language program that has been poked into 1541 RAM. The format of a memory-execute command is:

SYNTAX:

PRINT* file*, "M-E" CHR*(lo-byte) CHR*(hi-

byte)

ALTERNATE:

PRINT* file*, "M-E:" CHR*(lo-byte) CHR*(hi-

byte)

EXAMPLE:

PRINT*15,"M-E"CHR*(0)CHR*(6)

where

file* = the logical file number of the command channel

lo-byte = lo-byte of the RAM or ROM address

hi-byte = hi-byte of the RAM or ROM address

Machine language programs are poked into 1541 RAM with the memory-write command. The following primitive program pokes a single RTS instruction to RAM and executes it.

100 REM MEMORY-EXECUTE

HO OPEN 15,8,15

120 PRINT#15, "M-W"CHR* (O) CHR* (6) CHR* (DC

HR*(96)

130 PRINT*15,"M-E"CHR*(0)CHR*(6)

140 CLOSE15 150 END

Line Range _ _

120 Write 1 byte ($60) to RAM at $0600. 130 Execute RTS at $0600.

96

-----------------------------------------------------Page 96-----------------------------------------------------
﻿
The alternate format of the memory-execute command in line 130 is:

PRINT#15,"M-E:"CHR*(O)CHR*(6)

More sophisticated coding is available in Chapter 7. In addition, refer to Chapter 9 for pertinent information about the execution of standard ROM routines.

5.11 Block-Execute Command (B-E)

The block-execute command is used to execute a machine language program that resides

on diskette. A sector is read into a DOS buffer and executed in a manner similar to a LOAD and RUN on the C64. The format of a block-execute command is:

SYNTAX:

PRINT* file*, "B-E"; channel*; drive*;

track; sector

ALTERNATE:

PRINT* file*, "B-E:"; channel*; drive*;

track; sector

PRINT* file*, "B-E: channel*, drive*,

track, sector"

EXAMPLE:

PRINT#15,"B-E";2;0;l;0

where

file* = the logical file number of the command channel

channel* = the secondary address of the associated open statement

drive* = 0

track = 1 to 35

sector = 0 to the range for a given track

The block-execute command could be used in a diagnostic routine but it is difficult to visualize any other advantage that this command has over a normal memory-execute command. The following program demonstrates one of the few block-execute commands you will probably ever see. (lights, camera, action!) Run this program using a test diskette.

lOO REM BLOCK-EXECUTE

110 OPEN 15,8,15 120 PRINT*15,"IO"

130 INPUT#15,EN*,EM*,ET*,ES*

140 IF EN*<>"O0"GOT0 250

97

-----------------------------------------------------Page 97-----------------------------------------------------
﻿
150 OPEN 2,8,2,"*3"

160 print*15,"U1";2;o;i;o

170 INPUT#15,EN*,EM*,ET*,ES*

180 IF EN*0"00"GOTO 220

190 PRINT#15,"M-W"CHR*(0)CHR*(6)CHR*(1)C

HR*(96)

200 print#15,"U2";2;o;i;o

210 PRINT#15, "M-WCHR* (O) CHR* (6) CHR* (DC

HR*(0)

220 PRINT#I5,"B-E";2;0;l;0

230 CLOSE 2

240 INPUT#15,EN*.EM*,ET*,ES*

250 CLOSE 15 260 END

Line Range Description

150 Open a direct-access channel specifying buffer number 1

($0600 - $06FF).

160 Block-read of track 1, sector 0 ($0600 - $06FF). 190 Write 1 byte ($60) to RAM at $0600.

200 Block-write to track 1, sector 0 ($0600 - $06FF). 210 Just to keep us honest.

220 Block-execute of track 1, sector 0 ($0600 - $06FF).

The alternate formats of the block-execute command in line 220 are:

PRINT#15,"B-E:";2;0;l;o

PRINT#15,"B-E:2,0,1,0"

5.12 Direct-Access Entomology

We will conclude our discussion of the disk utility command set by pointing out just

a few of the DOS V2.6 direct-access anomalies we've found to date.

Block-Read (B-R)

Throughout the preceding section we relied solely upon the use of the Ul command to read a sector and not the traditional block-read command (B-R). Why? The block-read command (B-R) is unreliable, period. When the contents of a buffer are accessed with the GET* command — surprise, surprise! The number of bytes returned is a function of the number of the track you accessed. For example, a block-read (B-R) of any sector

98

-----------------------------------------------------Page 98-----------------------------------------------------
﻿
on track 15 will return only 15 bytes before sending an erroneous End-Or-Identify (EOI). The C64 status variable (ST) is set to 64 and any further attempt to access the buffer merely returns the same sequence of bytes over and over and over again. Moreover, the byte in position 0 can only be accessed when the buffer-pointer is reset to position 0 in line 190. See for yourself.

100 REM BLOCK-READ (B-R)

110 OPEN 15,8,15 120 PRINT#15,"10"

130 INPUT#15,EN*,EM*,ET*,ES*

140 IF EN*0"00"GOTO 300

ISO OPEN 2,8,2,"*"

160 PRINT*15,"B-R";2;o;18;0 170 INPUT#15,EN*,EM*,ET*,ES*

180 IF EN*O"00"G0T0 280

190 PRINT#15,"B-P";2;0

200 FOR 1=0 TO 255

210 GET#2,B*

220 IF B*=""THEN B*=CHR*(0) 230 A=ASC(B*)

240 PRINT ST,I,A,

250 IF A>31 AND A<96 THEN PRINT B*,

260 PRINT 270 NEXT I

280 CLOSE 2

290 INPUT#15,EN*,EM*,ET*,ES*

300 CLOSE 15 31O END

What's even more problematic is the situation that occurs when you do a block-read (B-R) of a track and sector that was rewritten by the block-write command (B-W) which is discussed below. The EOI occurs in connection with the ASCII value of the Oth byte of the sector that was read. Byte 0 contains the value of the buffer-pointer position at the time the block was written with a block-write command (B-W). The forward track reference that was originally there, has been destroyed. The ASCII value of the Oth byte determines how many characters you can access before the EOI occurs. Run the block-read (B-R) program listed above against track 1, sector 0 after you've done the block-write (B-W) experiment listed below on a test disk. Change the track number in

line 160 from an 18 to a 1 like this:

160 PRINT#15,"B-R";2;o;l;0

After further experimentation on your own, you should have little trouble understand¬ ing why the Ul command replaces the block-read command (B-R). Not only do user manuals continue to promote the use of the block-read command (B-R), but they also either ignore the Ul command altogether or simply mention it in passing without even

a hint on how to use it.

99

-----------------------------------------------------Page 99-----------------------------------------------------
﻿
Block-Write (B-W)

Recall that we also neglected to mention the block-write command (B-W) which we replaced with the U2 command. When you write a block with the block-write command (B-W) a different kind of dilemma occurs. Bytes 1 through 255 of the buffer are recorded on diskette correctly but the last position of the buffer-pointer is written to the Oth byte of the sector (the location of the forward track pointer). If it's any consolation, the data is still intact. Too bad the link has been destroyed. Run the following block-write pro¬ gram on a test diskette.

100 REM BLOCK-WRITE (B-W)

110 OPEN 15,8,15 120 PRINT#15,"I0"

130 INPUT*15,EN*,EM*,ET*,ES*

140 IF EN*0"00"GOTO 260

150 OPEN 2,8,2,"*"

160 print#15,"Ui";2;0;l;o

170 INPUT*15,EN*,EM*,ET*,ES*

180 IF EN*0"00"GOTO 240 190 FOR 1=0 TO 255

200 PRINT#2,CHR*(I);

210 NEXT I

220 PRINT#15,"B-P";2;6

230 print*15,"B-W";2;0;i;o

240 CLOSE 2

250 INPUT*15,EN*,EM*,ET*,ES*

260 CLOSE 15 270 END

Now run the original block-read (Ul) program that we wrote using this diskette. Be sure to change the track in line 160 from an 18 to a 1 as follows:

160 PRlNT#i5,"Ul";2;0;l;0

If all goes according to our diabolical plan, byte 0 will contain a 5 which is exactly where our buffer-pointer ended up. We arbitrarily set it to position 6 in line 220 above and 256 bytes later it wraps around to position 5. (Remember that bytes are numbered from

0 to 255 in a buffer area.)

Now change the Ul to a B-R in line 160 and run the program again. This time, only 5 bytes can be accessed before an EOI signal is returned.

UJ and Ul-

Commodore has traditionally had a warm reset buried somewhere in ROM on every piece of hardware they have manufactured to date. The UJ command is to the 1541 what a SYS 64738 is to the C64, a warm reset. Or rather, that is what it's supposed to be. The issuance of a UJ command is supposed to reset the 1541. Instead, it hangs the 1541.

100

-----------------------------------------------------Page 100-----------------------------------------------------
﻿
Press the RUN/STOP key and RESTORE key in tandem to regain control of the C64 after typing in this one liner in immediate mode.

OPEN 15,8,15,"UJ" : CLOSE15

Use U: in place of UJ.

The same thing is true for the Ul- command although Commodore can't really be held responsible here. The Ul- command was implemented to set the 1541 to VIC-20 speed,

not to take the C64 out to lunch.

U3 -U9

The VIC-15U1 User's Manual outlines 7 USER commands that perform a jump to a particular location in RAM. These USER commands and their respective jump addresses

are:

User Number

U3 (UC) U4 (UD) U5 (UE) U6 (UF) U7 (UG) U8 (UH) U9 (Ul)

Jump Address

$0500 $0503 $0506 $0509 $050C $050F

$FFFA

These jump locations are not quite as mystifying as they appear at first glance. Let's modify our simplistic memory-execute program.

100 REM U3

110 OPEN 15,8,15

120 PRINT#15, "M-W"CHR*(0) CHR* (5) CHR* (DC

HR*(96)

130 PRINT#15,"U3"

140 CLOSE15 150 END

One should be able to discern that any of the first six USER commands, U3 - U8, could double for a memory-execute command. It is very difficult to understand why Commodore included six jumps to the $0500 page (buffer number 2). Moreover, the U9 command jumps to $FFA which is a word table pointing to the NMI vector. U9 is an alternate reset that bypasses the power-on diagonstics.

101

-----------------------------------------------------Page 101-----------------------------------------------------
﻿

-----------------------------------------------------Page 102-----------------------------------------------------
﻿
CHAPTER 6

INTERMEDIATE

DIRECT-ACCESS PROGRAMMING

NOTE: This chapter is not intended for beginners. The reader is assumed to be relatively familiar with the direct-access programming commands described in Chapter 5.

The intermediate level of direct-access programming involves passing requests directly to the Floppy Disk Controller (FDC) via the job queue. Normally a 1541 command is initiated on the C64 side (e.g., SAVE, a block-read (Ul), etc.). The command is inter¬ preted by the 1541's 6502 Interface Processor (IP) as a set of simple operations called jobs. (This is analogous to the way the BASIC interpreter works inside the C64.) These jobs are poked into an area of 1541 RAM called the job queue. Every 10 milliseconds the job queue is scanned by the Floppy Disk Controller (FDC). If a job request is found the FDC executes it. The complete set of jobs that the FDC can perform are as follows:

1. Read a sector. 2. Write a sector.

3. Verify a sector.

4. Seek a track.

5. Bump the head to track number 1.

6. Jump to a machine language routine in a buffer. 7. Execute a machine language routine in a buffer.

The hexadecimal and decimal equivalents for each job request as seen by the FDC are:

J ob Code

$80 (128) $90 (144) $A0 (160) $B0 (176) $C0 (192) $D0 (208) $E0 (224)

Description

READ

WRITE

VERIFY SEEK BUMP JUMP

EXECUTE

If the FDC finds a job request in the job queue, it attempts to carry it out. Once the job is complete or aborted the FDC replaces the job code with an error code. The error codes returned by the FDC to the IP are listed below. The IP error codes and their respective error messages are what you see when you read the error channel.

103

-----------------------------------------------------Page 103-----------------------------------------------------
﻿
FDC Code

$01 (1) $02 (2)

$03 (3) $04 (4)

$05 (5)

$07(7)

$08 (8) $09 (9)

$0B (11)

IP Code

0

20

21 22

23

25

26 27

29

Error Message

OK

READ ERROR (header block not found)

READ ERROR (no sync character) READ ERROR (data block not present)

READ ERROR (checksum error in data block)

WRITE ERROR (write-verify

error)

WRITE PROTECT ON

READ ERROR (checksum error in header block)

READ ERROR (disk ID mismatch)

A more detailed description of each of these error messages can be found in Chapter 7.

Suppose that we want to read the contents of a given track and sector. The command initiated on the C64 side is parsed by the IP. If the syntax is correct, it is broken down into a job code, a track, and a sector. Depending upon what buffer has been assigned, the job code is poked into the corresponding job queue table location. The track and sector for the job are poked into the corresponding header table locations. The buffers and their corresponding job queue and header table addresses are outlined below:

Buffer Address Job Track Sector

#0 #1 #2 #3

$0000 - $00FF $0100 - $01FF $0200 - $03FF $0300 - $03FF $0400 - $04FF $0500 - $05FF $0600 - $06FF $0700 - $07FF
 Not available (ZERO PAGE) Not available (STACK)

Not available (COMMAND BUFFER) $0000 $0006 $0007 $0001 $0008 $0009 $0002 $000A $000B $0003 $000C $000D Not available (BAM)

For example, a block-read command (Ul) issued by the C64 to read the contents of track 18, sector 0 into buffer number 0 ($0300-$03FF) is checked for a syntax error and then broken down by the IP. In time, the FDC will find an $80 (128) at address $0000 in the job queue table, a $12 (18) at address $0006 in the header table, and a $00 (0) at address $0007 in the header table. Armed with that information, the FDC will attempt to seek (find) the track and read the sector. Upon successful completion of the read, the con¬ tents of the sector will be transferred to buffer number 0 ($0300-$03FF) and a $01 (1) will be returned by the FDC to address $0000. (If the job request could not be com¬ pleted for some reason, the job request would be aborted and the corresponding error code would be stored at address $0000 instead.) Interrogation of the error channel will transfer the IP counterpart of the FDC error code, the English message, the track

104

-----------------------------------------------------Page 104-----------------------------------------------------
﻿
number, and the sector number to the C64 side. If the job request was successful (00, OK,00,00), the contents of the track and sector could then be retrieved from the buffer at $0300 - $03FF using a GET* command as described in the previous chapter.

What happens, though, if we bypass the drive's parser routine and attempt to work the FDC directly ourselves? We thought you'd never ask. Grand and glorious schemes become possibilities, and that's what intermediate direct-access programming is all about. Armed with a lookup table of job codes, a map of the 1541's buffer areas, a track, a sector, and a lookup table of error codes, the FDC is at your beck and call. Tired of those horrendous grating noises when your drive errs out? Well wish no more. The drive does not do a bump (the root of all evil) to reinitialize when you are working the job queue directly. What more could you ask for? We know. The code, right?

The following program works the job queue directly to read the block from track 18, sector 0 into buffer number 0 ($0300 - $03FF) and prints the contents to the screen. Sound vaguely familiar? It should. It's a modification of the first program we wrote under beginning direct-access programming.

lOO REM JOB QUEUE READ

110 OPEN 15,8,15 120 PRINT#15,"I0"

130 INPUT#15,EN*,EM*,ET*,ES*

140 IF EN*0"00"GOTO 340 ISO REM SEEK 160 T=18 170 S=0

180 J0B=176

190 GOSUB 370

200 IF EOI GOTO 340 210 REM READ 220 JOB=128

230 GOSUB 370

240 IF EOI GOTO 340 250 FOR 1=0 TO 255

260 PRINT*15,"M-R"CHR*(I)CHR*(3) 270 GET#15,B*

280 IF B*=""THEN B*=CHR*(0) 290 A=ASC(B*)

300 PRINT ST,I,A,

310 IF A>31 AND A<96 THEN PRINT B*,

320 PRINT 330 NEXT I

340 CLOSE 15 350 END

360 REM JOB QUEUE 370 TRY=0

380 PRINT#15,"M-W"CHR*(6)CHR*(0)CHR*(2)C

HR*(T)CHR*(S)

390 PRINT#15, "M-WCHR* (O) CHR* (O) CHR* (DC

105

-----------------------------------------------------Page 105-----------------------------------------------------
﻿
HR*(JOB)

400 TRY=TRY+1

410 PRINT#15, ■

'M-R"CHR*(O)CHR*(0)

420 GET#15,E*

430 IF E*=""THEN E*=CHR*(0) 440 E=ASC(E*)

450 IF TRY=500 GOTO 470 460 IF E>127 GOTO 400 470 RETURN

Line Range

Main Program

110

120-140 160 170

180-190 200

220-230

240 250 260 270

280 290 300

310 320 330 340 350

Subroutine

370 380

390

400-460 470

Description

Open the command channel.

Initialize drive.

Initialize track to 18. Initialize sector to 0. SEEK track 18.

Query FDC error code.

READ sector 0 on track 18 into buffer number 0

($0300-$03FF).

Query FDC error code.

Begin loop to read 256 bytes ($0300-$03FF). Two parameter memory-read.

Transfer a byte from buffer number 0 to C 64 memory by way of the command channel (GET#15,). Test for equality with the null string "". ASCII conversion of a byte.

Print the status variable (ST), our loop counter, and the ASCII value of the byte.

Print the byte if it's within printable ASCII range.

Terminate comma tabulation.

Increment loop counter.

Close the command channel. End.

Initialize try counter.

Stuff the track and sector numbers into buffer number

0's header table ($0006-$0007).

Stuff job code number into buffer number 0's job queue

table ($0000).

Wait for FDC to complete the job.

Return with FDC error code in hand.

The good news is that working the job queue is not quite as complex as it at first ap¬ pears. The subroutine in lines 370-470 is the very heart of the matter. We simply stuff

106

-----------------------------------------------------Page 106-----------------------------------------------------
﻿
our track and sector into the header table, our job code into the job queue table, and wait until the FDC has completed the operation.

Keep in mind that this example was using buffer number 0 ($0300-$03FF). The corre¬ sponding header table and job queue table addresses were $0006 for the track, $0007 for the sector, and $0000 for the job code. Please note that every job code is greater than 127. (Bit 7 is deliberately set high (1).) Recall that when the FDC has completed a job, the job code is replaced with an error code. All error codes are less than 128. (Bit 7 is deliberately set low (0).) Line 460 waits until bit 7 of the job code is set low (0) by the FDC. If bit 7 is high (1), the FDC is still working so we must continue to

wait (line 410).

Error handling is a bit out of the ordinary too but not all that hard to comprehend either. An FDC error code of 1 means the job was completed successfully. Any other number

indicates an error.

You will also note a simple hierarchy of jobs in the program listing. Before we can read a sector (line 220) we must always find the track first Oine 180). Now are you ready for this one? Initialization is not necessary at all when working the job queue directly. Lines 120-140 were included as a force of habit. Applications like reading damaged or DOS protected diskettes may dictate that we do not initialize. Now for the bad news.

WARNING

Read this passage carefully. Then read it again for good measure.Experience is a hard teacher — test first, lesson afterward.

1. You must remember at all times when working the job queue that you have directly bypassed the parser routine. This is extremely dangerous because you have in effect killed all protection built into the 1541 itself. Let us explain. If by some poor misfortune you elect to do a read on track 99, the FDC doesn't know any better and takes off in search of track 99. You can physically lock the read/write head if it accidentally steps beyond its normal boundaries, i.e., a track less than 1 or a track greater than 35. No damage is done to the 1541 itself but if the power-on sequence doesn't return the head to center you will have to disassemble the drive and reposition the head manually. Exceeding the sector range for a given track is no problem, however. The drive will eventual¬ ly give up trying to find a sector out of range and report an FDC error 2 (an IP 20 error). Tracks are a pain in the stepper motor, however.

2. You must keep your header table locations and your job queue table locations straight in relation to the buffer number you are working. If they are not in agreement, the drive will go off into never-never land. The FDC will either at¬ tempt to work a nonexistent job code or seek a track and sector out of bounds. Remember the FDC will do exactly what you tell it to do. You are at the helm at all times. At the minimum, you will have to power off the drive to regain control. Again, no physical damage has been done to the 1541 but you may have to reposition the read/write head yourself. We know from experience.

107

-----------------------------------------------------Page 107-----------------------------------------------------
﻿
3. You should always monitor the job yourself. The try counter in line 450 is a stopgap measure. Five hundred wait cycles seems like an exaggerated figure here. However, you must give the drive adequate time to find a desired track and settle down before performing a job. If for some reason it cannot complete the job, it usually aborts and returns an error code on its own. If it doesn't, something is amiss and a try counter may trap it. (You might have to power off the drive to restore the status quo.) A try counter is a little like workman's compensation. Don't work the job queue without it.

Now, read these three paragraphs a second time.

The following program works the job queue directly to read track 18, sector 0 into buf¬ fer number 1 ($0400-$04FF). The disk name is returned with a three parameter memory- read of bytes 144-159 ($0490-$049F). It's another oldie but goodie.

100 REM JOB QUEUE READ - DISK NAME

HO OPEN 15,8, 15 120 PRINT#15,"10"

130 INPUT*15,EN*,EM*,ET*,ES*

140 IF EN*0"00"GOTO 360 150 REM SEEK 160 T=18 170 S=0

180 JOB=176

190 GOSUB 390

200 IF EOI GOTO 360 210 REM READ 220 J0B=128

230 GOSUB 390

240 IF EOI GOTO 360

250 PRINT#15,"M-R"CHR*(144)CHR*(4)CHR*(1

6)

260 FOR 1=1 TO 16

270 GET#15,B*

280 IF B*=""THEN B*=CHR*(0) 290 A=ASC(B*)

300 IF AM27 THEN A=A-128

310 IF A<32 OR A>95 THEN A=63 320 IF A=34 THEN A=63 330 DN*=DN*+CHR*(A) 340 NEXT I

350 PRINT"CDOWN>DISK NAME: ";DN* 360 CLOSE 15 370 END

380 REM JOB QUEUE 390 TRY=0

400 PRINT*15,"M-W"CHR*(8)CHR*(0)CHR*(2)C

HR*(T)CHR*(S)

410 PRINT#15, "M-W"CHR*(DCHR*(0)CHR* (DC

108

-----------------------------------------------------Page 108-----------------------------------------------------
﻿
HR*(JOB)

420 TRY=TRY+1

430 PRINT*15,"M-R"CHR*(1)CHR*(0)

440 GET#15,E*

450 IF E*=""THEN E*=CHR*(0) 460 E=ASC(E*)

470 IF TRY=500 GOTO 490 480 IF E>127 GOTO 420 490 RETURN

Line Range

120-140 160 170

180-190 200

220-230

240 250

260-340

390 400

410

420-480 490

Description

Force of habit.

Initialize track to 18. Initialize sector to 0. SEEK track 18.

Query FDC error code.

READ sector 0 on track 18 into buffer number 1

($0400-$04FF).

Query FDC error code.

Three parameter memory-read ($0490-$049F).

Concatenate the disk name one byte at a time by jam¬ ming it within printable ASCII range. Initialize try counter.

Stuff the track and sector number into buffer number l's

header table ($0008-$0009).

Stuff the job code number into buffer number l's job queue table ($0001).

Wait for FDC to complete the job.

Return with FDC error code in hand.

Not much new here except the buffer in use. Let's review the key memory addresses for working buffer number 1 ($0400-$04FF):

BUFFER NUMBER 1 TRACK NUMBER SECTOR NUMBER JOB CODE

= $0400 - $04FF

= $0008 (HEADER TABLE) = $0009 (HEADER TABLE)

= $0001 (JOB QUEUE TABLE)

While we're at it, we might as well review the order of jobs for the sake of posterity.

First SEEK a track. Then READ a sector.

The next program incorporates four FDC job codes, namely a SEEK, a READ, a WRITE, and indirectly a VERIFY. This routine is a modification of the edit disk name program found in the previous chapter. Keep in mind that we are working buffer number 2 here ($0500-$05FF). The header table addresses are $000A for the track and $000B for the sector. The job codes themselves will be poked into location $0002 in the job queue table.

109

-----------------------------------------------------Page 109-----------------------------------------------------
﻿
100 REM JOB QUEUE READ/WRITE - EDIT DISK

NAME

110 FOR 1=1 TO 16

120 PAD*=PAD*+CHR*(160) 130 NEXT I

140 PRINT"{CLR*EDIT DISK NAME - 1541" 150 PRINT"{DOWN}REMOVE {RVS}WRITE PROTEC T TAB{ROFF}"

160 PRINT"{DOWN}INSERT DISKETTE IN DRIVE

11

170 PRINT"{DOWN3PRESS {RVS}RETURNCROFFi

TO CONTINUE"

ISO GET C*:IF C*=""THEN 180 190 IF C*OCHR*(13)GOTO 180 200 PRINT"OK"

210 OPEN 15,8,15 220 PRINT*15,"10"

230 INPUT*15,EN*,EM*,ET*,ES*

240 IF EN*="00"GOTO 290

250 PRINT"{DOWN}"EN*", "EM*","ET*","ES*

260 CLOSE 15 270 END

280 REM SEEK 290 T=18 300 S=0

310 JOB=176

320 GOSUB 660 330 REM READ 340 JOB=128

350 GOSUB 660

360 PRINT*15,"M-R"CHR*(144)CHR*(5)CHR*(1

6)

370 FOR 1=1 TO 16

380 GET*15,B*

390 IF B*=""THEN B*=CHR*(0) 400 A=ASC(B*)

410 IF A>127 THEN A=A-128

420 IF A<32 OR A>95 THEN A=63 430 IF A=34 THEN A=63 440 ODN*=ODN*+CHR*(A) 450 NEXT I

460 PRINT"{DOWN}OLD DISK NAME: ";ODN* 470 INPUT"{DOWN}NEW DISK NAME";NDN*

4SO IF LEN(NDN*)OO AND LEN(NDN*)<17 GOT O 500

490 GOTO 630

500 INPUT"{DOWN}ARE YOU SURE (Y/N) Y{LE FT 3}";Q*

510 IF Q*O"Y"G0T0 630

520 NDN*=LEFT*(NDN*+PAD*,16)

110

-----------------------------------------------------Page 110-----------------------------------------------------
﻿
530 PRINT#15,"M-W"CHR*(144)CHR*(5)CHR*(1

6)NDN*

540 REM WRITE 550 J0B=144

560 GOSUB 660

570 PRINT#15,"10"

580 INPUT*15,EN*,EM*,ET*,ES*

590 CLOSE 15

600 PRINT"{DOWN}DONE!" 610 END

620 REM CLOSE 630 CLOSE 15 640 END

650 REM JOB QUEUE 660 TRY=0

670 PRINT#15, "M-WCHR* (10) CHR* (O) CHR* (2)

CHR*(T)CHR*(S)

680 PRINT#15, "M-W"CHR*(2)CHR*(0) CHR* (DC

HR*(JOB)

690 TRY=TRY+1

700 PRINT*15,"M-R"CHR*(2)CHR*(O) 710 GET#15,E*

720 IF E*=""THEN E*=CHR*(0) 730 E=ASC(E*)

740 IF TRY=500 GOTO 780 750 IF E>127 GOTO 690 760 IF E=l THEN RETURN 770 REM ERROR HANDLER

780 ET*=RIGHT*(STR*(T),LEN(STR*(T))-1)

790 IF TOO THEN ET*="0"+ET*

800 ES*=RIGHT*(STR*(S),LEN(STR*(S))-1)

810 IF S<10 THEN ES*="On+ES*

820 IF E>1 AND E<12 THEN EN*=RIGHT*(STR*

(E+18),2):GOTO 840

830 EN*="02":EM*="?TIME OUT":GOTO 860 840 IF E=7 OR E=8 THEN EM*="WRITE ERROR"

:GOTO 860

850 EM*="READ ERROR"

860 PRINT"{DOWN}"EN*", "EM*","ET*","ES*

870 PRINT"{DOWN}{RVS}FAILED{ROFF}" 880 CLOSE 15 890 END

Line Range Description

290-320 SEEK track 18.

340-350 READ contents of sector 0 from track 18 into buffer

number 2 ($0500-$05FF).

550-560 WRITE buffer number 2 ($0500-$05FF) to track 18, sec¬

tor 0.

770-890 Error handler.

Ill

-----------------------------------------------------Page 111-----------------------------------------------------
﻿
Lines 100 to 530 should be self explanatory by now. Lines 540-560 are equivalent to a block-write command (U2). To write a sector via the job queue we stuff the track and sector in the header table and a $90 (144) into the job queue table and let her rip.

The error handler, however, is of interest. The conversion from FDC code to IP code is quite easy. We simply add 18 to the FDC error code (line 820). Note that we try to restrict all errors within a range of 20 to 29. An FDC error code of 0 or greater than 11 is indicative that something went radically wrong. Line 820 arbitrarily reports a ?TIME OUT in this situation. Speaking from experience, the job just plainly didn't get done. A time out occurs very rarely, unless of course, one is inspecting a damaged or DOS-protected diskette.

Line 840 is another highlight. An FDC WRITE ($90) automatically flips to an FDC VERIFY ($A0) to compare the contents of the buffer against the sector just written. Kind of neat, isn't it? If the buffer and the sector do not match, we see an FDC error 7, i.e., an IP error number 25, WRITE ERROR. Since a VERIFY is done automatical¬ ly by the FDC, we will not elaborate any further on this particular job code.

The job code for a BUMP is a $C0 (192). Why anybody would ever want to implement this job request is beyond us.

A subtle difference exists between the remaining two job codes, a JUMP ($D0) and an EXECUTE ($E0). A JUMP executes a machine language routine poked into RAM. No more, no less. Like a BUMP job, it is seldom used. The program that moves the read/write head in Chapter 9 is the only place where we have ever found a practical

use for it.

An EXECUTE ($E0) is the Rolls Royce of job codes, however. Before a machine language routine is executed, the FDC makes sure that:

1. The drive is up to speed.

2. The read/write head is on the right track.

3. The read/write head has settled.

The FDC cannot be interrupted when performing an EXECUTE job. Once the FDC starts to EXECUTE the machine language routine, control is not returned to the IP until the routine is completed. A runaway routine cannot be debugged even with BRK instructions. You must power down the 1541 and try to second guess the side effects of the routine to determine what went wrong.

NOTE: The FDC does not automatically return an error code when the routine is com¬ pleted. It is the programmer's responsibility to change the job code in the job queue table from an EXECUTE ($E0) to an $01 at the end of the routine. If this is not done, the FDC will find the same EXECUTE request on its next scan of the job queue and re-run the routine. Infinite regression!

Most of the programs in Chapter 7 make use of the EXECUTE job code in one form or another. Therefore, example programs will be given there.

112

-----------------------------------------------------Page 112-----------------------------------------------------
﻿
CHAPTER 7

DOS PROTECTION

7.1 Commodore's Data Encoding Scheme

Before we can enter the netherworld of DOS protection you have to possess a thorough understanding of how the 1541 records a sector on a diskette. Any given sector is di¬ vided into two contiguous parts, a header block and a data block. For clarity sake let's review the parts of a sector discussed in Chapter 3.

Header Block (16 8-bit bytes)

Number of Bytes

2 8

)ata Block (260 8-bit bytes)

Number of Bytes

1

256

1 2

Variable

Description

Sync Character

Header Block Identifier ($08)

Header Block Checksum Sector Number Track Number IDLO ID HI

Off Bytes ($0F)

Header Gap ($55)

Description

Sync Character

Data Block Identifier ($07) Data Bytes

Data Block Checksum

Off Bytes ($00) Tail Gap ($55)

The 1541 writes a track on the surface of a diskette as one continuous bit stream. There

are no demagnetized zones between sectors on a track to delineate where one sector ends and another one begins. Instead, Commodore relies upon synchronization characters

113

-----------------------------------------------------Page 113-----------------------------------------------------
﻿
for reference marks. A DOS 2.6 sync mark can be defined as five 8-bit $FF's written in succession to disk. Note that a sync mark is recorded at the front end of each header block and each data block. To differentiate a sync mark from a normal data byte, the 1541 writes to diskette in two modes, a sync mode and a normal write mode.

To appreciate the uniqueness of a sync mark we must first look at how a normal data byte is recorded. During normal write mode each 8-bit byte is encoded into 10 bits before it is written to disk. Commodore calls this encoding scheme binary to GCR (Group Code Recording) conversion. The conversion technique itself is quite straightforward. Each 8-bit byte is separated into two 4-bit nybbles, a high nybble and a low nybble. For ex¬ ample, the binary representation of $12 (18) is %00010010. The breakdown of this 8-bit byte into its two 4-bit nybbles is depicted below:

Hexadecimal Binary High Nybble Low Nybble

$12 (18) 00010010 OOOlxxxx xxxxOOlO

Mathematically speaking, a 4-bit nybble can be decoded into any one of 16 different decimal values ranging from 0 (all bits turned off) to 15 (all bits turned on) as follows:

Bit Number Power of 2

Weight

3 3 8
 2 2 4

1 1 2

0 0 1

Hence, the 1541's GCR lookup table contains just sixteen 4-bit nybble equivalencies:

Hexadecimal

$0(0) $1(1) $2(2) $3(3) $4(4) $5(5) $6(6) $7(7) $8(8) $9(9)

$A (10) $B (11) $C (12) $D (13) $E (14) $F (15)

Binary

0000 0001 0010 0011 0100 0101 0110 0111 1000 1001 1010 1011 1100 1101 1110 1111

GCR

01010 01011 10010 10011 onio 01111 10110 10111 01001 11001 11010 11011 01101 11101 11110 10101

Using the binary to GCR lookup table above, let's walk through the necessary steps

to convert a $12 (18) to GCR form.

114

-----------------------------------------------------Page 114-----------------------------------------------------
﻿
STEP 1. Hexadecimal to Binary Conversion

$12 (18) = 00010010

STEP 2. High Nybble to GCR Conversion

OOOlxxxx = $1 (1) = 01011

STEP 3. Low Nybble to GCR Conversion

xxxxOOlO = $2 (2) = 10010

STEP 4. GCR Concatenation

01011 + 10010 = 0101110010

Two things should stand out when scrutinizing the 1541's binary to GCR lookup table.

1. No combination of any two 5-bit GCR bytes will ever yield 10 consecutive on bits (Is) which is used as the sync mark. Binary to GCR conversion eliminates all likelihood that a permutation of normal data bytes can ever be mistaken by the read/write elec¬ tronics for a sync mark.

2. No more than two consecutive off bits (0s) appear in any given 10-bit GCR byte or combination of GCR bytes. This latter constraint was imposed for accuracy when clocking bits back into the 1541 during a read. (See Chapter 9 for additional

information.)

This brings us full circle to what actually differentiates a sync mark from a normal data byte. Simply put, a sync mark is 10 or more on bits (Is) recorded in succession. Only one normal data byte, an $FF (%11111111), can even begin to fill the shoes of a sync mark. During normal write mode, however, an $FF would take the following GCR form, 1010110101. Enter sync mode. When the 1541 writes an $FF in sync mode no binary to GCR conversion is done. A single $FF is only eight consecutive on bits and falls short of the ten consecutive on bits needed to create a sync character. To remedy this, Com¬ modore writes five consecutive 8-bit $FFs to disk. This records 40 on bits (Is) in succes¬ sion. the overkill is intentional on the DOS's part. Commodore is trying to guarantee that the 1541 will never have any trouble finding a sync mark during subsequent

reads/writes to a diskette.

Four 8-bit data bytes are converted to four 10-bit GCR bytes at a time by the 1541 DOS. RAM is only an 8-bit storage device though. This hardware limitation prevents a 10-bit GCR byte from being stored in a single memory location. Four 10-bit GCR bytes total 40 bits — a number evenly divisible by our overriding 8-bit constraint. Commodore sub¬ divides the 40 GCR bits into five 8-bit bytes to solve this dilemma. This explains why four 8-bit data bytes are converted to GCR form at a time. The following step by step example demonstrates how this bit manipulation is performed by the DOS.

STEP 1. Four 8-bit Data Bytes

$08 $10 $00 $12

115

-----------------------------------------------------Page 115-----------------------------------------------------
﻿
STEP 2. Hexadecimal to Binary Conversion

1. Binary Equivalents

$08 $10 $00 $12

00001000 00010000 00000000 00010010

STEP 3. Binary to GCR Conversion

1. Four 8-bit Data Bytes

00001000 00010000 00000000 00010010

2. High and Low Nybbles

0000 1000 0001 0000 0000 0000 0001 0010

3. High and Low Nybble GCR Equivalents

01010 01001 01011 01010 01010 01010 01011 10010

4. Four 10-bit GCR Bytes

0101001001 0101101010 0101001010 0101110010

STEP 4. 10-bit GCR to 8-bit GCR Conversion

1. Concatenate Four 10-bit GCR Bytes

0101001001010110101001010010100101110010

2. Five 8-bit Subdivisions

01010010 01010110 10100101 00101001 01110010

STEP 5. Binary to Hexadecimal Conversion

1. Hexadecimal Equivalents

01010010 01010110 10100101 00101001 01110010

$52 $56 $A5 $29 $72

STEP 6. Four 8-bit Data Bytes are Recorded as Five 8-bit GCR Bytes

$08 $10 $00 $12 are recorded as $52 $56 $A5 $29 $72

Four normal 8-bit bytes are always written to diskette as five 8-bit GCR bytes by the DOS. The 1541 converts these same five 8-bit GCR bytes back to four normal 8-bit bytes during a read. The steps outlined above still apply but they are performed in the reverse order. (The appendix contains various mathematical conversion routines for your use.) In light of the above discussion, we need to recalculate the number of bytes that are actually recorded in a sector. We stated in Chapter 3 that a header block was comprised of eight 8-bit bytes excluding the header gap. This is recorded on the diskette as ten 8-bit GCR bytes. The formula for determining the actual number of bytes that are re¬

corded is:

Number of 8-bit GCR Bytes Recorded = (Number of 8-bit Data Bytes/4) * 5

116

-----------------------------------------------------Page 116-----------------------------------------------------
﻿
Similarly, a data block consisting of 260 8-bit bytes is written to disk as 325 8-bit GCR bytes. Lest we forget, each sync mark is five 8-bit bytes. We must also remember to add in the header gap which is held constant at eight bytes. (Header gap bytes ($55) are not converted to GCR form and serve only to separate the header block from the data block.) An entire sector is recorded as 353 bytes not 256 data bytes.

Sync Character ($FF)

Header Block

Header Gap ($55)

Sync Character ($FF)

Data Block

Data Bytes

5* 8

8 * 5*

260

GCR Bytes

5 10

8 5 325

* No binary to GCR conversion.

We deliberately excluded the inter-sector (tail) gap in calculating the number of bytes in a given sector. Why? Because the tail gap is never referenced again by the DOS once formatting is complete. During formatting the Floppy Disk Controller (FDC) erases a track by writing 10240 overlapping 8-bit $FFs. Once a track has been erased the FDC writes 2400 8-bit $FFs (%11111111) followed by 2400 8-bit $55s (%01010101). The intent is to wrap around the circumference of the track with a clearly discernable on/off pat¬ tern of bytes. The FDC then counts to see how many sync ($FF) and nonsync ($55) bytes were actually written to the track. From this count the FDC subtracts the total number of bytes that the entire range of sectors in a given zone will use. The remainder is then divided by the number of sectors in that zone to determine the size of the tail gap. The algorithm is analogous to cutting a pie. The tail gap varies not only between tracks due to a decrease in both circumference and the sector range but between disk drives as well, due to varying motor speeds. A stopgap measure is incorporated into the algorithm for the latter reason. If a tail gap is not computed to be at least four bytes in length formatting will fail and an error will be reported. In general, the length of the tail gaps fall into the ranges tabled below:

Zone Tracks Number of Sectors Variable Tail Gap

1 2 3 4
 1 - 17 18-24 25-30 31 -35
 21 19 18 17

4-7

9- 12 5-8 4-8

Note that the values given above do not apply to the highest numbered sector on a track. The gap between this sector and sector 0 is usually much longer. We have seen tail gaps in excess of 100 bytes here.

Also note that a header block is never rewritten after formatting is complete. The data block of a sector, including the sync character, is completely rewritten every time data is written to that sector. The eight byte header gap is counted off by the DOS to deter¬ mine where to start writing the data block.

117

-----------------------------------------------------Page 117-----------------------------------------------------
﻿
7.2 Checksums

The only remaining concern we have at this time is how we compute a checksum. Unlike tape storage where a program file is recorded twice in succession, data is recorded on diskette only once. In other words, there is no cyclic redundancy. Checksum comes to the rescue. A single byte checksum or hashtotal is used by the DOS to determine whether or not an error occurred during a read of a header block or a data block. A checksum is derived by Exclusive-ORing (EOR) bytes together. Two bytes are EORed together at one time by comparing their respective bits. The four possible EOR bit combinations are shown in the following truth table.

EOR Truth Table

0 EOR 0 = 0 0 EOR 1 = 1 1 EOR 0 = 1 1 EOR 1 = 0

A header block checksum is the EOR of: the sector number, the track number, the ID LO, and the ID HI. (These four bytes serve to differentiate sectors from one another on a diskette.) A data block checksum is the EOR of all 256 8-bit data bytes in a sector. Recall that a data block normally consists of a forward track and sector pointer plus 254 data bytes. Please note that bytes are EORed by the DOS prior to their GCR

conversion.

The following example demonstrates how a header block checksum is calculated. The algorithm for calculating a data block checksum is identical, only longer.

Sector Number Track Number IDLO ID HI

Hexadecimal

$00(0)

$12 (18) $58 (88) $5A (90)

Binary

00000000 00010010 01011000 01011010

STEP 1. Initialization

EOR $00 (0) With Sector Number

$00 = 00000000 Sector Number ($00) = 00000000

00000000

STEP 2. EOR With Track Number

00000000

Track Number ($12) = 00010010

00010010

118

-----------------------------------------------------Page 118-----------------------------------------------------
﻿
STEP 3. EOR With ID LO

ID LO ($58)

00010010 01011000

01001010

STEP 4. EOR With ID HI

01001010

ID HI ($5A) = 01011010

00010000

STEP 5. Binary to Hexadecimal Conversion

00010000

$10 (16)

The checksum for $00, $12, $58, and $5A is thus $10 (16). This checksum just happens to be the header block checksum for track 18, sector 0 on the 1541TEST/DEMO. In ad¬ dition, the binary to GCR conversion tour presented earlier was for the first four bytes ($08 $10 $00 $12) of the same header block.

7.3 Description of DOS Error Messages

In Chapter 6 we presented a table of FDC and IP error codes. The following table outlines the order in which errors are evaluated by the DOS during a read and a write, respectively.

READ ERRORS

FDC Job FDC

Request Error Code

SEEK $03 (3) SEEK $02 (2) SEEK $09 (9) SEEK $0B (11) READ $02 (2) READ $04 (4) READ $05 (5) READ $01 (1)

IP

Error Code

21 20 27 29 20 22 23

0

119

Error Message

No Sync Character

Header Block Not Found

Checksum Error in Header Block Disk ID Mismatch

Header Block Not Found Data Block Not Present

Checksum Error in Data Block OK

-----------------------------------------------------Page 119-----------------------------------------------------
﻿
WRITE ERRORS

FDC Job
 FDC

IP

Request

WRITE WRITE WRITE WRITE

VERIFY

Error Code

$0B (11) $08 (8) $07(7) $01 (1)

Error Code

73 29 26 25

0

Error Message

DOS Mismatch

Disk ID Mismatch Write Protect On

Write-Verify Error

OK

Each error is described in greater detail below.

21 READ ERROR (NO SYNC CHARACTER)

The FDC could not find a sync mark (10 or more consecutive on bits) on a given track within a prescribed 20 millisecond time limit. A time out has occurred.

20 READ ERROR (HEADER BLOCK NOT FOUND)

The FDC could not find a GCR header block identifier ($52) after 90 attempts. The FDC did a seek to a track and found a sync character. The FDC then read the first GCR byte immediately following it. This GCR byte was compared against a GCR $52 ($08). The comparison failed and the try counter was decremented. The FDC waited for another sync character and tried again. Ninety attempts were made.

27 READ ERROR (CHECKSUM ERROR IN HEADER BLOCK)

The FDC found a header block on that track. This header block was read into RAM

and the GCR bytes were converted back to their original binary form. The FDC then EORed the sector number, the track number, the ID LO, and the ID HI together. This independent checksum was EORed against the actual checksum found in the header block itself. If the result of the EOR was not equal zero, the checksums were not equal. The comparison failed and the FDC returned a $09 to the error handler.

29 READ ERROR (DISK ID MISMATCH)

The IDs recorded in the header block found above did not match the master copy of the disk id's stored in $0012 and $0013. These zero page memory addresses are normal¬ ly updated from track 18 during initialization of a diskette. Note that they also can be updated by a seek to a track from the job queue.

20 READ ERROR (HEADER BLOCK NOT FOUND)

A GCR image of the header was created using the sector number, the track number, and the master disk IDs. The FDC attempted to find a header on this track that match¬ ed the GCR image in RAM for that sector. Ninety attempts were made before this er¬ ror was reported.

120

-----------------------------------------------------Page 120-----------------------------------------------------
﻿
22 READ ERROR (DATA BLOCK NOT PRESENT)

The header block for a given track and sector passed the previous five tests with flying colors. The FDC found the data block sync mark and read the next 325 GCR bytes into RAM. These GCR bytes were converted back into 260 8-bit binary bytes. The first decod¬ ed 8-bit byte was compared against a preset data block identifier at $0047 and failed to match. Note this zero page memory address normally contains a $07.

23 READ ERROR (CHECKSUM ERROR IN DATA BLOCK)

An independent checksum was calculated for the 256 byte data block converted above.

This checksum did not match the actual checksum read from the diskette.

00, OK,00,00

Nothing wrong here.

73 DOS MISMATCH (CBM DOS V2.6 1541)

An attempt was made to write to a diskette with a non-compatible format. The DOS version stored at location $0101 was not a $41. This memory address is normally up¬ dated during initialization by reading byte 2 from track 18, sector 0.

29 READ ERROR (DISK ID MISMATCH)

Same as 29 READ ERROR above but conflicting id's were found during a write at¬ tempt rather than a read. Repeated occurrance of this error on a standard diskette is indicative of a seating problem or a slow-burning alignment problem.

26 WRITE PROTECT ON

An attempt was made to write to a diskette while the write protect switch is depress¬ ed. Remove the write protect tab from the write protect notch.

25 WRITE-VERIFY ERROR

The contents of the data just written to a sector did not match the data in RAM when they were read back. This was probably caused by a flaw on the surface of the diskette. The end result was an unclosed file. Validate the diskette to decorrupt the BAM. (See Chapter 2.)

00, OK,00,00

Looking good.

121

-----------------------------------------------------Page 121-----------------------------------------------------
﻿
7.4 Analyzing a Protected Diskette

Bad sectoring is central to any disk protection scheme. In a nutshell, disk protection involves the deliberate corruption of a given track or sector. The authenticity of a diskette is often determined by a short loader program that reads the corrupted track or sector. In essence the FDC or IP error code is a password allowing access to the run time module. As a result the loader is extremely protected. If it can be cracked the program is generally freed from its bonds. This is easier said than done though. A loader is usually rendered indecipherable (Coda Obscura) through an autostart feature, the use of unimplemented 6502 op codes, encryption, or compilation. Frankly speaking, it's much easier to go after the whole disk. The following passages will introduce you to the black art of bit copying.

The appendix contains four routines written specifically to assist in the interrogation of a diskette. They are:

1. Interrogate Formatting IDs 2. Interrogate a Track

3. Shake, Rattle, and Roll 4. Interrogate a Diskette

These four programs tend to complement one another quite well in actual use. Their

uses and limitations are discussed below.

INTERROGATE FORMATTING ID'S returns the embedded disk ID for each track

using a SEEK. Recall that working the job queue prevents the dreaded BUMP. A seek to a track is deemed successful by the FDC if at least one intact sector can be found. The header of said sector is stored in zero page from $0016-$001A.The ASCII equivalents of the ID HI ($0016) and ID LO ($0017) are read and printed to the CRT if the SEEK was good. At a glance one can determine if a protected diskette has a blown track or if it has been formatted with multiple ID's. This latter scheme is less commonly used to date. This program will not report the integrity of each individual sector. We have

other routines for that task.

There is one severe drawback to this program as it stands. Occasionally the FDC gets hung up on a track. The SEEK may continue to attempt to find a sync mark without timing out. (You must power off the 1541 to recover from this situation.) Experimenta¬ tion in interrogating unformatted diskettes has produced the same effect. We surmise that the track in question was passed over during high-speed duplication. The FDC may in fact be homing in on a residual bit pattern left over from the manufacturer's certifica¬ tion process. The program has a built-in fail-safe mechanism for this very reason. Please take note: Lines 110-140 establish an active track array. All tracks are presumed active at the onset (line 130). Line 240 tests the integrity of the track prior to a seek. If a track is inactive (its flag equals 0) the track is bypassed and the program will work from start to finish. Should the need arise simply patch in a line that reads:

145 T(track number)=0

145 T(17)=0, for example.

If it's any comfort at all, a loader cannot check the integrity of said track either. The sole function of such a track is to discourage prying eyes.

122

-----------------------------------------------------Page 122-----------------------------------------------------
﻿
INTERROGATE A TRACK scans a single track using the job queue. The track is found with a SEEK and then the integrity of each sector is verified with a READ. IP error codes are returned to the screen. No BUMP occurs. The routine may occasionally pro¬ vide erroneous information. This is a major shortcoming of a READ from the queue. Certain errors are returned clean as a whistle (22, 23, 27). A partially formatted track (mid-track 21 error) or a smattering of 20 errors tend to throw the FDC into an absolute tizzy. Make note of this. Repeated runs of the same track often return a different error pattern. Errors tend to accumulate when a BUMP is overridden. Solution? See the follow¬ ing paragraph.

SHAKE, RATTLE, AND ROLL also scans a single track by using a Ul command rather than a direct READ from the job queue. The track is still found by a SEEK, however, to prevent 29 errors in the event that multiple formatting played a part in the protec¬ tion scheme. A 29 error is not an error per se. It is merely a stumbling block. A Ul without a SEEK to a multiple-formatted diskette will report a DISK ID MISMATCH. Information can be stored on a track with a different ID. A loader will retrieve it by the same method we're using here. Errors will force a BUMP so use discretion. Please note that a full track of 21 errors, 23 errors, or 27 errors does not need to be read with this routine. After you analyze a track, write the errors down and file your notes away for archival needs. Your 1541 will love you for it.

INTERROGATE A DISKETTE is the lazy man's routine. It scans an entire diskette reporting only bad sectors to the screen. The program is essentially INTERROGATE A TRACK in a loop. Note that you may have to patch around a track to map the entire diskette. See the example patch above.

7.5 Duplicating a Protection Scheme

The following table represents the state of the error. The rank order in which errors tend to crop up on copy protected diskettes are as follows:

1. 21 ERROR (FULL TRACK)

2. 23 ERROR (SINGLE SECTOR) 3. 23 ERROR (FULL TRACK)

4. 20 ERROR (SINGLE SECTOR) 5. 27 ERROR (FULL TRACK)

6. 29 ERROR (MULTIPLE FORMATTING) 7. 22 ERROR (SINGLE SECTOR) 8. 21 ERROR (PARTIAL TRACK)

Historically speaking, the 21 error (full track) and the 29 error appeared on the scene concurrently. At the present time, a full track 21 error and a single sector 23 error are the predominant errors used to corrupt a diskette. These same two errors are also the easiest to duplicate. The last entry, partial formatting of a track, is the new kid on the

block.

123

-----------------------------------------------------Page 123-----------------------------------------------------
﻿
The following 13 programs can be used to duplicate a multitude of errors on a diskette. They are:

File Name

Error Numb*

;r Error Range

21 ERROR

DESTROY A SECTOR 23A ERROR 23B ERROR 23M ERROR 20 ERROR

20M ERROR 27M ERROR 22A ERROR 22B ERROR

FORMAT A DISKETTE

BACKUP COPY

21

20,21

23 23 23 20 20 27 22 22

29

—

FULL TRACK

SINGLE SECTOR SINGLE SECTOR ♦SINGLE SECTOR

FULL TRACK

SINGLE SECTOR FULL TRACK FULL TRACK

SINGLE SECTOR *SINGLE SECTOR

MULTIPLE FORMATTING ID'S

SINGLE DRIVE BACKUP SINGLE FILE COPY

* Creates an exact duplicate of a bad sector.

Source listings for the machine language routines in these programs are included as a courtesy to the more advanced reader. The BASIC drivers themselves are nondescript and will not be explained in depth. It is assummed that the reader has digested the sections on beginning and intermediate direct-access programming in Chapters 5 and 6. Algorithms will be briefly mentioned along with any new techniques and/or limita¬

tions that apply.

7.6 How to Create 21 Errors on a Full Track

Limitations: None.

Parameters: Track number.

FULL TRACK 21 ERROR

100 110 120 130 140 150 ;q* 160 170 180

REM 21 ERROR - 1541

PRINT"{CLR}21 ERROR - 1541"

PRINT"{DOWN}INSERT CLONE IN DRIVE" INPUT"{DOWN}DESTROY TRACK";T IFT<1ORT >35THENEND

INPUT"{DOWN}ARE YOU SURE Y{LEFT 3}"

IFQ*<>"Y"THENEND

0PEN15,8,15

PRINT#15,"10"

124

-----------------------------------------------------Page 124-----------------------------------------------------
﻿
190 INPUT#15,EN*,EM*,ET*,ES*

200 IFEN*="00"G0T0250

210 PRINT"{DOWN}"EN*", "EM*","ET*","ES*

220 CL0SE15 230 END

240 REM SEEK 250 J0B=176 260 G0SUB400

270 F0RI=0T023 280 READD

290 D*=D*+CHR*(D) 300 NEXTI

310 PRINT#15,"M-W"CHR*(0)CHR*(4)CHR*(24)

D*

320 REM EXECUTE

330 PRINT"{DOWN}{RVS}DESTROYING{ROFF} TR ACK";T

340 J0B=224 350 G0SUB400

360 PRINT"{DOWN}DONE!" 370 CLOSE15 380 END

390 REM JOB QUEUE 400 TRY=0

410 PRINT#15,"M-W"CHR*(8)CHR*(0>CHR*<2)C

HR*(T)CHR*(0>

420 PRINT#15,"M-W"CHR*(1)CHR*(O)CHR* <1)C

HR*(JOB)

430 TRY=TRY+1

440 PRINT#15,"M-R"CHR*<1)CHR*(0) 450 GET#15,E*

460 IFE*=""THENE*=CHR*(0) 470 E=ASC(E*>

480 IFTRY=500G0T0510 490 IFEM27G0T0430 500 RETURN 510 CL0SE15

520 PRINT"{DOWN}{RVS}FAILED{ROFF}" 530 END

540 REM 21 ERROR

550 DATA 32,163,253.169, 85,141, 1, 28

560 DATA 162,255,160, 48, 32,201,253, 32

570 DATA 0,254,169, 1, 76,105,249,234

125

-----------------------------------------------------Page 125-----------------------------------------------------
﻿
FULL TRACK 21 ERROR SOURCE LISTING

100 REM 21.PAL 110 REM

120 0PEN2,8,2,"@0:21.B,P,W"

130 REM

140 150 160 170 180 190
 SYS40960 5

.OPT P,02

>

*= *0500

>

200 210 220 230 240 250
 JSR LDA STA LDX LDY JSR
 *FDA3 #*55

*1C01 #*FF #*48

*FDC9

ENABLE WRITE NON SYNC BYTE

WRITE 18432 NON SYNC BYT

ES

260 270 280
 JSR LDA J MP
 *FEOO #*01

*F969

ENABLE READ

Full Track 21 Error Source Annotation

This routine borrows from FORMT ($FAC7). Prior to formatting a track, the FDC erases it with sync marks ($FDA3). Experimentation has shown that an RTS from this ROM entry point would create a track of all 20 errors. Thus we are forced to trace the FORMT routine a little farther. The subroutine WRTNUM ($FDC3) writes either sync or non- sync bytes. By entering six bytes into this routine we can establish the number of bytes it writes. A JSR to $FEOO is necessary to re-enable read mode. Otherwise the write head is left on and it will erase everything in its path. Note that we LDA #$01, the FDC error code for OK, and JMP to the error handler at $F969 to exit.

7.7 How to Create a 21 Error on a Single Sector

Limitations: Preceding sector must be intact (See the annotation below).

Parameters: Track and sector number.

DESTROY A SECTOR

100 REM DESTROY A SECTOR - 1541 110 DIMD*(7)

120 PRINT"{CLR3DESTR0Y A SECTOR - 1541" 130 PRINT"{DOWN}INSERT CLONE IN DRIVE" 140 INPUT"{DOWN}DESTROY TRACK AND SECTOR

(T,S)";T,S

150 IFT<10RT>35THENEND

126

-----------------------------------------------------Page 126-----------------------------------------------------
﻿
160 NS=20+2*(T>17)+(T>24)+(T>30) 170 IFS<00RS>NSTHEMEND

180 INPUT"{DOWN}ARE YOU SURE Y{LEFT 3}" ;q*

190 IFQ*< >"Y"THEMEND

200 0PEN15,8,15

210 PRINT#15,"10"

220 INPUT#15,EN*,EM*,ET*,ES*

230 IFEN*="00"G0T0280

240 PRINT"{DOWN}"EN*","EM*","ET*","ES*

250 CLOSE15 260 END

270 REM SEEK

280 IFS=OTHENS=NS:G0T0300 290 S=S-1

300 J0B=176 310 G0SUB570 320 REM READ 330 J0B=128 340 G0SUB570 350 F0RJ=0T07 360 F0RI=0T07 370 READD

380 D*(J)=D*(J)+CHR*(D> 390 NEXTI 400 NEXTJ 410 1=0

420 F0RJ=OT07

430 PRINT#15,"M-W"CHR*(I)CHR*(5)CHR*(8)D

*<J)

440 1=1+8 450 NEXTJ

460 REM EXECUTE

470 PRINT#15, "M-W"CHR* (2) CHR* <0> CHR* (DC

HR*(224)

480 PRINT315,"M-R"CHR*<2)CHR*(0)

490 GET#15,E*

500 IFE*=""THENE*=CHR*(O) 510 E=ASC(E*>

520 IFE>127G0T0480 530 CLOSE15

540 PRINT"{DOWN}DONE!" 550 END

560 REM JOB QUEUE 570 TRY=0

580 PRINT#15,"M-W"CHR*(8)CHR*(0)CHR*(4)C

HR* (T) CHR* (S) CHR* (T) CHR* (S)

590 PRINT#15, ,,M-W"CHR*(1)CHR*(0)CHR*(1)C

HR*(JOB)

600 TRY=TRY+1

127

-----------------------------------------------------Page 127-----------------------------------------------------
﻿
610 PRINT815,"M-R"CHR*(1)CHR*(0) 620 GET#15,E*

630 IFE*=""THENE*=CHR*(0) 640 E=ASC<E*>

650 IFTRY=500G0T0680 660 IFEM27G0T0600 670 IFE=1THENRETURN 680 CLOSE15

690 PRINT"{DOWN}{RVS}FAILED{ROFF}" 700 END

710 REM DESTROY A SECTOR

720 DATA 32, 16,245, 32, 86,245,162, O

730 DATA 80,254,184,202,208
 50,162, 69

740 DATA 80,254,184,202,208,250,169,255 750 DATA141. 3. 28.173, 12, 28, 41, 31 760 DATA 9,192,141, 12, 28,162, 0,169 770 DATA 85, 80,254,184,141, 1, 28,202 780 DATA208,247, 80,254, 32, O,254,169 790 DATA 1, 76,105,249,234,234,234,234

SINGLE SECTOR 21 ERROR SOURCE LISTING

100 REM DAS.PAL 110 REM

120 0PEN2,8,2,"@0:DAS.B,P,W"

130 140 150 160 170 180 190 200 210 220 230 240 250 260 270 280 290 300 310 320 330 340 350 360 370
 REM

SYS40960 5

.OPT P,02

5

*= *0500

JSR *F510 ; FIND HEADER JSR *F556 ; FIND SYNC

5

;* WAIT OUT DATA *

*

LDX #*00

READ1 BVC READ1 CLV DEX

BNE READ1

LDX #*45

READ2 BVC READ2 CLV DEX

BNE READ2

>

LDA #*FF ; DATA DIRECTION OUT

128

-----------------------------------------------------Page 128-----------------------------------------------------
﻿
380 STA *1C03

390 LDA *1C0C; ENABLE WRITE MODE

400 AND #*1F 410 ORA #*C0 420 STA *1C0C

430 ;

440 LDX #*00 450 LDA #*55

460 WRITE1 BVC WRITE1 470 CLV

480 STA *1C01 490 DEX

500 BNE WRITE1 510 ;

520 WRITE2 BVC WRITE2 530 ;

540 JSR *FEOO ; ENABLE READ MODE 550 ;

560 LDA #*01 570 JMP *F969

Single Sector 21 Error Source Annotation

This routine finds the preceding sector and syncs up to its data block (lines 200-210). Lines 250-350 wait out 325 GCR bytes. We flip to write in lines 370-420 and write out 256 non-sync bytes. This overwrites both sync marks of the sector that was input. This routine will create a 20 error on a single sector as it stands. By serendipity, it has a unique side effect. If two consecutive sectors are destroyed we get a 21 error on both of them. The FDC times out trying to find one or the other or both. Caution must be used when spanning a sector range. To duplicate the following scheme we must destroy sector 0 first followed by sectors 20, 19, and 18 respectively.

Sector Error Number

0 21

1-17 OK 18 - 20 21

Repeat. This routine will not create a 21 error on a single sector per se. Two consecutive sectors must be destroyed.

7.8 How to Create a 23 Error on a Single Sector

Limitations: None.

Parameters: Track and sector number.

129

-----------------------------------------------------Page 129-----------------------------------------------------
﻿
SINGLE SECTOR 23 ERROR

100 no 120

REM 23A ERROR - 1541 DIMD*<11)

PRINT"{CLR}23 ERROR - 1541"

130
 PRINT"{DOWN}INSERT CLONE
 IN DRIVE"

140
 INPUT"{DOWN)DESTROY TRACK

: AND SECTOR

<T,

,S)";T,S

150 160 170 180 ;q* 190 200 210 220 230 240
 IFT<1ORT >35THENEND

NS=20+2* <T>17> + (T>24) + <T>

IFS< OORS >NSTHENEND

INPUT"{DOWN}ARE YOU SURE

IF0*O"Y"THENEND

0PEN15.8,15

PRINT#15,"10"

INPUT#15,EN*,EM*,ET*,ES*

IFEN*="00"G0T0280

PRINT"{DOWN}"EN*", "EM*",

30)

Y{LEFT 3}"

"ET*","ES*

250 260 270 280 290 300 310 320 330 340 350 360 370 380 390 400 410
 CLOSE15 END

REM SEEK J0B=176

G0SUB550 REM READ J0B=128

G0SUB550

F0RJ=0T011 F0RI=0T07 READD

D*(J)=D*(J)+CHR*(D> NEXTI NEXTJ 1=0

F0RJ=0T011

PRINT#15, "M-WCHR* (I) CHR* (5) CHR* (8) D

*(J)

1

420 430 440 450
 I = I+B NEXTJ

REM EXECUTE

PRINT#15,"M-W"CHR*(2)CHR*(0)CHR*(1> C

HR*(224)

460 470 480 490 500 510 520 530

PRINT#15,"M-R"CHR*(2)CHR*<0> GET#15,E*

IFE*=""THENE*=CHR*(0)

E=ASC<E*>

IFEM27G0T0460

CLOSE15

PRINT"{DOWN}DONE!" END

130

-----------------------------------------------------Page 130-----------------------------------------------------
﻿
540 REM JOB QUEUE 550 TRY=0

560 PRINT#15,"M-W"CHR*(8)CHR*(O)CHR*(4)C

HR*(T)CHR*(S)CHR*(T)CHR*(S)

570 PR I NT# 15, " M-W " CHR* (1) CHR* (0) CHR* < 1 > C

HR*(JOB)

580 TRY=TRY+1

590 PRINT#15,"M-R"CHR*(1)CHR*(0) 600 GET#15,E*

610 IFE*=""THENE*=CHR*(0> 620 E=ASC(E*)

630 IFTRY=500GOT0660 640 IFEM27G0T0580 650 RETURN 660 CLOSE15

670 PRINT"{DOWN}{RVS}FAILED{ROFF}" 680 END

690 REM 23 ERROR

700 DATA 169, 4,133, 49,165, 58,170.232

710 DATA 138,133, 58, 32,143,247, 32, 16

720 DATA 245,162, 8, 80,254,184,202,208

730 DATA 250,169,255,141, 3, 28,173, 12

740 DATA 28, 41, 31, 9,192,141, 12, 28

750 DATA 169,255,162, 5,141, 1, 28,184

760 DATA 80,254,184,202,208,250,160,187

770 DATA 185, O, 1, 80,254,184,141, 1

780 DATA 28,200,208,244,185, O, 4, 80

790 DATA 254,184,141, 1, 28,200,208,244

800 DATA 80,254, 32, 0,254,169, 5,133

810 DATA 49,169, 1, 76,105,249,234,234

SINGLE SECTOR 23 ERROR SOURCE LISTING

100 REM 23A.PAL 110 REM

120 0PEN2,8,2,"@0:23A.B.P,W"

130 REM

140 SYS40960 150 ;

131

-----------------------------------------------------Page 131-----------------------------------------------------
﻿
160 .OPT P,02

170 ;

180 *= *0500 190 ;

200 LDA #*04 210 STA *31 220 ;

230 LDA *3A 240 TAX

250 INX ; INCREMENT CHECKSUM 260 TXA

270 STA *3A 280 ;

290 JSR *F78F

GCR

300 JSR *F510 #

310 ;

320 LDX #*08

330 WAITGAP BVC WAITGAP AP

340 CLV 350 DEX

360 BNE WAITGAP 370 ;

380 LDA #*FF

CONVERT TO

FIND HEADER

WAIT OUT G

ENABLE WRI

TE

390 STA *1C03 400 LDA *1C0C 410 AND #*1F 420 ORA #*C0 430 STA *1C0C 440 LDA #*FF 450 LDX #*05 460 STA *1C01 470 CLV

480 WRITESYNC BVC WRITESYNC 490 CLV 500 DEX

510 BNE WRITESYNC 520 ;

530 LDY #*BB

540 OVERFLOW LDA *0100,Y ; WRITE OUT

OVERFLOW BUFFER

550 WAIT1 BVC WAIT1 560 CLV

570 STA *1C01 580 INY

590 BNE OVERFLOW

132

-----------------------------------------------------Page 132-----------------------------------------------------
﻿
600 BUFFER LDA *O4O0,Y ; WRITE OUT

BUFFER

610 WAIT2 BVC WAIT2 620 CLV

630 STA *1C01 640 INY

650 BNE BUFFER

660 WAIT3 BVC WAIT3 670 ;

680 JSR *FEOO ; ENABLE REA D

690 ;

700 LDA #*05 710 STA *31 720 LDA #*01 730 JMP *F969

Single Sector 23 Error Source Annotation

This routine borrows from WRIGHT ($F56E). Our entry point is 12 bytes into the routine. This bypasses the write protect test and the computation of the checksum. The driver routine reads the sector into $0400-$04FF. Lines 200-210 of the source listing set the indirect buffer pointer to this workspace. The checksum is next incremented at $003A. Buffer number 1 is converted to GCR form. Recall that 260 data bytes are converted into 325 8-bit GCR bytes. More than one buffer is used to store the GCR image. The first 69 GCR bytes are stored in an overflow buffer at $01BB-$01FF. The remaining 256 bytes are found at $0400-$04FF. We sync up to the appropriate sector in line 300, count off the eight byte header gap, and flip to write mode. Five $FFs are then written to disk (the sync mark) followed first by the overflow buffer and then the regular buf¬ fer. We restore the indirect buffer pointer at $0031 to a $05 and jump to the error handler

with a $01 in hand.

7.9 How to Duplicate a 23 Error on a Single Sector

Limitations: None (Requires disk swapping).

Parameters: Track and sector number.

DUPLICATE A SINGLE SECTOR 23 ERROR

100 REM DUPLICATE A 23 ERROR - 1541 110 DIMD*(10)

120 PRINT"{CLR}DUPLICATE A 23 ERROR - 15

41"

130 PRINT"{DOWN}INSERT MASTER DISKETTE I

N DRIVE"

140 INPUT"{DOWN}READ TRACK AND SECTOR <T

,S)";T,S

150 IFT<10RT>35THENEND

133

-----------------------------------------------------Page 133-----------------------------------------------------
﻿
160 170 180

;Q*

190 200 210 220 230 240 250 260 270 280 290 300 310 320 330 340 350

NS=20+2*(T>17)+(T>24)+(T>30)

IFS< OORS >NSTHENEND

INPUT"{DOWN}ARE YOU SURE Y{LEFT 3}"

IFQ*< >"Y"THENEND

0PEN15,8,15

PRINT#15,"I0"

INPUT#15,EN*,EM*,ET*,ES*

IFEN*="00"G0T0280

PRINT"{DOWN}"EN*", "EM*","ET*","ES*

CLOSE15 END

REM SEEK J0B=176

G0SUB650 REM READ J0B=128

G0SUB650 CLOSE15

PRINT"{DOWN}INSERT CLONE IN DRIVE" PRINT"{DOWN}PRESS {RVS}RETURN{ROFF}

TO CONTINUE"

360 370 380 390 400 410 420 430 440 450 460 470 480 490 500 510
 GETC*:IFC*=""THEN360 IFC*< >CHR*(13)G0T0360

PRINT"OK"

0PEN15,3,15

REM SEEK J0B=176

G0SUB650

FORJ=OT010 F0RI=0T07 READD

D*(J)=D*(J)+CHR*(D) NEXTI NEXTJ 1=0

F0RJ=0T010

PRINT#15,"M-W'CHR* <I)CHR*(5)CHR*(8)D

*(J)

(

520 530 540 550

1 = 1+8 NEXTJ

REM EXECUTE

PRINT#15,"M-W"CHR* <2)CHR*(0)CHR*(1)C

HR*<
 [224)

560 570 580 590 600 610

PRINT#15,"M-R"CHR*(2)CHR*(0> GET#15,E*

IFE*=""THENE*=CHR*(0)

E=ASC(E*)

IFE>127G0T0560 CLOSE15

134

-----------------------------------------------------Page 134-----------------------------------------------------
﻿
620 PRINT"{DOWN}DONE!" 630 END

640 REM JOB QUEUE 650 TRY=0

660 PRINT#15, "M-WCHR* (8) CHR* (0) CHR* (4) C

HR*(T)CHR*(S)CHR*(T)CHR* <S)

670 PRINT#15, "M-W"CHR* (1) CHR* (O) CHR* (DC

HR*(JOB)

680 TRY=TRY+1

690 PRINT#15,"M-R"CHR*(1)CHR*(O) 700 GET#15,E*

710 IFE*=""THENE*=CHR*(O) 720 E=ASC(E*)

730 IFTRY=500G0T0760 740 IFEM27G0T0680 750 RETURN

760 PRINT"{DOWN}FAILED" 770 CLOSE15 780 END

790 REM DUPLICATE A SECTOR

800 DATA 169, 4,133, 49, 32,143,247, 32

810 DATA 16,245,162, 8, 80,254,184,202

820 DATA 208,250,169,255,141, 3, 28,173

830 DATA 12, 28, 41, 31, 9,192,141, 12

840 DATA 28,169,255,162, 5,141, 1, 28

850 DATA 184, 80,254,184,202,208,250,160

860 DATA 187,185, O, 1, 80,254,184,141

870 DATA 1, 28,200,208,244,185, O, 4

880 DATA 80,254,184,141, 1, 28,200,208

890 DATA 244, 80,254, 32, 0,254,169, 5

900 DATA 133, 49,169, 1, 76,105,249,234

DUPLICATE A SINGLE SECTOR 23 ERROR SOURCE LISTING

100 REM 23B.PAL 110 REM

120 0PEN2,8,2,"@0:23B.B,P,W"

130 REM

140 SYS40960 150 ;

135

-----------------------------------------------------Page 135-----------------------------------------------------
﻿
160 .OPT P,02

170 ;

180 *= *0500

190 ;

200 LDA #*04 210 STA *31 220 J

230 JSR *F7SF

GCR

240 JSR *F510 #

250 ;

260 LDX #*08

270 WAITGAP BVC WAITGAP AP

280 CLV 290 DEX

300 BNE WAITGAP 310 ;

320 LDA #*FF TE

330 STA *1C03 340 LDA *1C0C 350 AND #*1F 360 ORA #*C0 370 STA *1C0C 380 LDA #*FF 390 LDX #*05 400 STA *1C01 410 CLV

420 WRITESYNC BVC WRITESYNC 430 CLV 440 DEX

450 BNE WRITESYNC

460 ;

470 LDY #*BB

480 OVERFLOW LDA *0100,Y

OVERFLOW BUFFER

490 WAIT1 BVC WAIT1 500 CLV

510 STA *1C01 520 INY

530 BNE OVERFLOW

540 BUFFER LDA *0400,Y

BUFFER

550 WAIT2 BVC WAIT2 560 CLV

570 STA *1C01 580 INY

590 BNE BUFFER

136

CONVERT TO

FIND HEADER

WAIT OUT G

ENABLE WRI

; WRITE OUT

WRITE OUT

-----------------------------------------------------Page 136-----------------------------------------------------
﻿
600 WAIT3 BVC WAIT3 610 ;

620 JSR *FE00 ; ENABLE REA

D

630 ;

640 LDA #*05 650 STA *31 660 LDA #*01 670 JMP *F969

Duplicate a Single Sector 23 Error Source Annotation

Identical to the 23A.PAL file with one exception. The checksum is left intact after a corrupted data block is read from the master using the job queue. The sector is stored at $0400-$04FF and the checksum at $003A. The checksum is not recalculated or in¬

cremented. The entire sector and its checksum are rewritten to the clone.

7.10 How to Create 23 Errors on a Full Track

Limitations: None.

Parameters: Track number.

FULL TRACK 23 ERROR

100 REM 23M ERROR - 1541 110 DIMD*(11)

120 PRINT"{CLR}MULTIPLE 23 ERROR - 1541"

130 PRINT"{DOWN}INSERT CLONE IN DRIVE" 140 INPUT"{D0WN3DESTR0Y TRACK";T 150 IFT<1ORT >35THENEND

160 INPUT"{DOWN}ARE YOU SURE Y{LEFT 3}" ;q*

170 IFQ*<>"Y"THENEND

180 0PEN15,S,15

190 PRINT315,"10"

200 INPUT#15,EN*,EM*,ET*,ES*

210 IFEN*="00"G0T0260

220 PRINT"{DOWN}"EN*", "EM*","ET*","ES*

230 CLOSE15 240 END

250 REM SEEK 260 J0B=176 270 G0SUB580

280 NS=20+2*(T>17)+(T>24)+(T>30) 290 FORS=OTONS 300 REM READ 310 J0B=128

137

-----------------------------------------------------Page 137-----------------------------------------------------
﻿
320 G0SUB580

330 IFS>0G0T0460 340 F0RJ=0T011 350 F0RI=OT07 360 READD

370 D*(J)=D*(J)+CHR*(D) 380 NEXTI 390 NEXTJ 400 1=0

410 F0RJ=0T011

420 PRINT#15,"M-W"CHR*(I)CHR*(5)CHR*(8)D

*(J)

430 1=1+8 440 NEXTJ

450 REM EXECUTE

460 PRINT"{HOME}{DOWN 8}{RVS}DESTROYING{ ROFF} TRACK"T"- SECTOR"S

470 PRINT#15, "M-W'CHR* (2) CHR* (O) CHR* (1) C

HR*(224)

480 PRINT#15,"M-R"CHR*(2)CHR*(0) 490 GET#15,E*

500 IFE*=""THENE*=CHR*(0) 510 E=ASC(E*)

520 IFEM27G0T0480 530 NEXTS

540 CLOSE15

550 PRINT"{HOME}{DOWN 8}DONE!

II

560 END

570 REM JOB QUEUE 580 TRY=0

590 PRINTttlS."M-W"CHR*(8)CHR*(0)CHR*(4)C HR*(T)CHR*(S)CHR*(T)CHR*(S)

600 PRINTttlS,"M-W"CHR*(1)CHR*(0)CHR*(1)C HR*(JOB)

610 TRY=TRY+1

620 PRINT#15,"M-R"CHR*(1)CHR*(0) 630 GET#15,E*

640 IFE*=""THENE*=CHR*(0) 650 E=ASC(E*)

660 IFTRY=500G0T0690 670 IFEM27G0T0610 680 RETURN 690 CLOSE15

700 PRINT"{DOWN}{RVS}FAILED{ROFF}" 710 END

720 REM 23 ERROR

730 DATA 169, 4,133, 49,165, 58,170,232

740 DATA 138,133, 58, 32,143,247, 32, 16

138

-----------------------------------------------------Page 138-----------------------------------------------------
﻿
750 DATA 245,162, 8, 80,254,184,202,208

760 DATA 250,169,255,141, 3, 28,173, 12

770 DATA 28, 41, 31, 9,192,141, 12, 28

780 DATA 169,255,162, 5,141, 1, 28,184

790 DATA 80,254,184,202,208,250,160,187

800 DATA 185, 0, 1, 80,254,184,141, 1

810 DATA 28,200,208,244,185, O, 4, 80

820 DATA 254,184,141, 1, 28,200,208,244

830 DATA 80,254, 32, 0,254,169, 5,133

840 DATA 49,169, 1,133, 2, 76,117,249

FULL TRACK 23 ERROR SOURCE LISTING

100 REM 23M.PAL 110 REM

120 0PEN2,8,2,"@0:23M.B,P,W"

130 REM

140 SYS40960 150 ;

160 .OPT P,02

170 ;

180 *= *050O

190 ;

200 LDA #*04 210 STA *31 220 ;

230 LDA *3A 240 TAX

250 INX CKSUM

260 TXA

270 STA *3A 280 ;

290 JSR *F78F R

300 JSR *F510

; INCREMENT CHE

; CONVERT TO GC

; FIND HEADER

310 ;

320 LDX #*08

330 WAITGAP BVC WAITGAP ; WAIT OUT GAP

340 CLV 350 DEX

139

-----------------------------------------------------Page 139-----------------------------------------------------
﻿
360 BNE WAITGAP 370 ;

380 LDA #*FF ; ENABLE WRITE 390 STA *1C03 400 LDA *1C0C 410 AND #*1F 420 ORA #*C0 430 STA *1C0C 440 LDA #*FF 450 LDX #*05 460 STA *1C01 470 CLV

480 WRITESYNC BVC WRITESYNC 490 CLV 500 DEX

510 BNE WRITESYNC

520 ;

530 LDY #*BB

540 OVERFLOW LDA *0100,Y ; WRITE OUT OVE

RFLOW BUFFER

550 WAIT1 BVC WAIT1 560 CLV

570 STA *1C01 580 INY

590 BNE OVERFLOW

600 BUFFER LDA *0400,Y ; WRITE OUT BUF

FER

610 WAIT2 BVC WAIT2 620 CLV

630 STA *1C01 640 INY

650 BNE BUFFER

660 WAIT3 BVC WAIT3 670 ;

680 JSR *FE00 ; ENABLE READ 690 ;

700 LDA #*05 710 STA *31 720 LDA #*01 730 STA *02

740 JMP *F975

Full Track 23 Error Source Annotation

See the annotation for 23A.PAL. The BASIC driver loops to do all sectors on a given

track.

140

-----------------------------------------------------Page 140-----------------------------------------------------
﻿
7.11 How to Create a 20 Error on a Single Sector

Limitations: Preceding sector must be intact. (See the annotation for a single sector 21 error)

Parameters: Track and sector number.

SINGLE SECTOR 20 ERROR

100 REM 20 ERROR - 1541 110 DIMD*(11)

120 PRINT"{CLR}20 ERROR - 1541"

130 PRINT"{DOWN}INSERT CLONE IN DRIVE" 140 INPUT"{D0WN3DESTR0Y TRACK AND SECTOR

(T,S)";T,S

150 IFT<1ORT >35THENEND

160 NS=20+2*(TM7) + (T>24) + (T>30) 170 IFS<OORS>NSTHENEND

180 INPUT"{DOWN}ARE YOU SURE Y{LEFT 3}" ;q*

190 IFQ*<>"Y"THENEND

200 0PEN15,8,15

210 PRINT#15,"I0"

220 INPUT#15,EN*,EM*,ET*,ES*

230 IFEN*="00"G0T0280

240 PRINT"{DOWN}"EN*", "EM*","ET*","ES*

250 CLOSE15 260 END

270 REM SEEK

280 IFS=0THENS=NS:G0T0300 290 S=S-1

300 JOB=176 310 G0SUB570 320 REM READ 330 J0B=128 340 G0SUB570

350 F0RJ=0T011 360 F0RI=0T07 370 READD

380 D*(J)=D*(J)+CHR*(D) 390 NEXTI 400 NEXTJ 410 1=0

420 F0RJ=0T011

430 PRINT#15,"M-W"CHR*(I)CHR*(5)CHR*(8)D

*(J)

440 1=1+8 450 NEXTJ

460 REM EXECUTE

470 PRINT#15,"M-W"CHR*(2)CHR*(0)CHR*(1)C

HR*(224)

141

-----------------------------------------------------Page 141-----------------------------------------------------
﻿
480 PRINT#15,"M-R"CHR*(2)CHR*(0) 490 GET#15,E*

500 IFE*=""THENE*=CHR*(0) 510 E=ASC(E*)

520 IFEM27GOT0480 530 CLOSE15

540 PRINT"{DOWN}DONE!" 550 END

560 REM JOB QUEUE 570 TRY=0

580 PR I NT# 15, " M-W " CHR* (8) CHR* (O) CHR* (4) C

HR*(T)CHR*(S)CHR*(T)CHR*(S)

590 PRINT315,"M-W"CHR*(1)CHR*(O)CHR*(1)C

HR*(JOB>

600 TRY=TRY+1

610 PRINT#15,"M-R"CHR*(1)CHR*(O) 620 GET#15,E*

630 IFE*=""THENE*=CHR*(0) 640 E=ASC(E*)

650 IFTRY=500G0T0680 660 IFEM27G0T0600 670 IFE=1THENRETURM 680 CLOSE15

690 PRINT"{DOWN}{RVS}FAILED{ROFF}" 700 END

710 REM 20 ERROR

720 DATA 32, 16,245, 32, 86,245,160, 20

730 DATA 165, 25,201, 18,144, 12,136,136

740 DATA 201, 25,144, 6,136,201, 31,144

750 DATA 1,136,230, 24,197, 24,144, 6

760 DATA 240, 4,169, 0,133, 25,169, O

770 DATA 69, 22, 69, 23, 69, 24, 69, 25

780 DATA 133, 26, 32, 52,249, 32, 86,245

790 DATA 169,255,141, 3, 28,173, 12, 28

800 DATA 41, 31, 9,192,141, 12, 28,162

810 DATA 0,181, 36, 80,254,184,141, 1

820 DATA 28,232,224, 8,208,243, 80,254

830 DATA 32, 0,254,169, 1, 76,105,249

142

-----------------------------------------------------Page 142-----------------------------------------------------
﻿
SINGLE SECTOR 20 ERROR SOURCE LISTING

100 110 120 130 140 150 160 170 180 190 200 K

210

REM 20.PAL REM

0PEN2,8,

REM

SYS40960 5

.OPT P,02

5

*= *0500

!

JSR *F510

JSR *F556

"@0:20.B,P,W"

FIND HEADER BLOC

FIND DATA BLOCK

220 230 240 250 260 270 280 290 300 310 320 330 340 350 360 370 380 390 400 410 420 430 440 450 460 470 480 490

5

LDY tt*14 LDA *19

CMP 4**12 BCC ZONE DEY DEY

CMP #*19 BCC ZONE DEY

CMP #*1F BCC ZONE DEY

ZONE INC *18 CMP *18

BCC HEADER BEQ HEADER LDA #*00 STA *19

5

HEADER LDA #*00 EOR *16 EOR *17 EOR *18 EOR *19 STA *1A

JSR *F934
 CREATE NEW HEADER

# IMAGE 500 JSR K

510 LDA 520 STA 530 LDA 540 AND

*F556

#*FF

*1C03 *1C0C #*1F

FIND HEADER BLOC

WRITE MODE

143

-----------------------------------------------------Page 143-----------------------------------------------------
﻿
550 ORA tt*CO 560 STA *1C0C 570 LDX #*00

580 WRITE LDA *0024,X

590 WAIT1 BVC WAIT1 600 CLV

610 STA *1C01 620 INX

630 CPX #*08 640 BNE WRITE

650 WAIT2 BVC WAIT2 660 ;

670 JSR *FEOO ; READ MODE

680 ;

690 LDA #*01 700 JMP *F969

Single Sector 20 Error Source Annotation

This routine represents a halfhearted attempt to rewrite a header. It is dependent upon the preceding sector being intact. Lines 200-210 sync up to the preceding header and data block. Lines 230-400 calculate the next sector in the zone. A header image for the sector is created in RAM at $0024-$002C. We sync up one more time which positions us to the start of the header block we want to destroy. We flip to write mode and rewrite the header. We are coming in just a shade too slow and create enough noise at the end of the sync mark to destroy the actual header block identifier. (Tweaking the internal clock reveals that the header was completely rewritten.) If the tail gap was a constant length our task would be analogous to rewriting a sector where the FDC syncs up to a header block, reads the header, and counts off eight bytes. We would similarly sync up to a data block, count off 325 GCR bytes, then count off the tail gap, and flip to write mode. However, it is virtually impossible to gauge the length of the tail gap, so we're stuck. Rest assured, though. It still gets the job done.

7.12 How to Create 20 Errors on a Full Track

Limitations: None.

Parameters: Track number.

FULL TRACK 20 ERROR

100 REM 20M ERROR - 1541 110 DIMD*(24)

120 PRINT"{CLR}MULTIPLE 20 ERROR - 1541"

130 PRINT"{DOWN}INSERT CLONE IN DRIVE" 140 INPUT"{DOWN}DESTROY TRACK";T 150 IFT<1ORT >35THENEND

160 INPUT"{DOWN}ARE YOU SURE Y{LEFT 3}" ;q*

144

-----------------------------------------------------Page 144-----------------------------------------------------
﻿
170 IFQ*<>"Y"THENEND

180 0PEN15,8,15

190 PRINT#15."10"

200 INPUT#15,EN*,EM*,ET*,ES*

210 IFEN*="00"G0T0260

220 PRINT"{DOWN}"EN*", "EM*","ET*","ES*

230 CLOSE15 240 END

250 REM SEEK

260 NS=20+2*(T>17)+(T>24)+(T>30) 270 S=NS

280 J0B=176 290 G0SUB580

300 F0RI=0T023 310 READD

320 D*=D*+CHR*(D) 330 I*=I*+CHR*(0) 340 NEXTI

350 PRINT#15,"M-W"CHR*(0)CHR*(6)CHR*(24)

D*

360 REM EXECUTE

370 PRINT"{DOWN}{RVS}DESTROYING{ROFF} TR ACK";T

380 J0B=224 390 G0SUB580

400 PRINT#15,"M-W"CHR*(0)CHR*(6)CHR*(24)

I*

410 F0RJ=0T024 420 F0RI=0T07 430 READD

440 D*(J)=D*(J)+CHR*(D) 450 NEXTI 460 NEXTJ 470 1=0

480 F0RJ=0T024

490 PRINT#15,"M-W"CHR*(I)CHR*(4)CHR*(8)D

*(J)

500 1=1+8 510 NEXTJ

520 REM EXECUTE

530 PRINT#15,"M-E"CHR*(0)CHR*(4)

540 CLOSE15

550 PRINT"{DOWN}DONE!" 560 END

570 REM JOB QUEUE 580 TRY=0

590 PRINT#15,"M-W"CHR*(12)CHR*(0)CHR*(2)

CHR*(T)CHR*(S)

600 PRINT#15,"M-W"CHR*(3)CHR*(0)CHR*(1)C

HR*(JOB)

145

-----------------------------------------------------Page 145-----------------------------------------------------
﻿
610 TRY=TRY+1

620 PRINT#15,"M-R"CHR*(3)CHR*(0) 630 GET#15,E*

640 IFE*=""THENE*=CHR*(0) 650 E=ASC(E*)

660 IFTRY=500G0T0690 670 IFEM27G0T0610 680 RETURN 690 CLOSE15

700 PRINT"{DOWN}{RVS}FAILED{ROFF}" 710 END

720 REM 21 ERROR

730 DATA 32,163,253,169, 85,141, 1, 28

740 DATA 162,255,160, 48, 32,201,253, 32

750 DATA 0,254,169, 1, 76,105,249,234

760 REM 20M ERROR

770 DATA169, O,133, 780 DATA134,128,166, 790 DATA 1,141, 32, 800 DATA 6,169, O, 810 DATA193,162, O, 820 DATA232,232,173, 830 DATA232,165, 81, 840 DATA O,157, O, 850 DATA232,169, 15, 860 DATA 0, 3,232, 870 DATA 93,251, 2, 880 DATA 2,157,249, 890 DATA 40, 6,197, 900 DATA169, 75,141, 910 DATA157, O, 5, 920 DATA133, 48,169, 930 DATA254,104,168, 940 DATA245,253,169, 950 DATA245,133, 58, 960 DATA133, 81,169, 970 DATA 5,141, 1, 980 DATA 6,169, 49, 990 DATA141, 4, 6,

127,166,

13,232,

6,169, 141, 40.

169, 9,

40, 6, 157, 0,

3,232, 157, 0,

169, 0,

93,252,

2,238, 67,208,

0, 5,

232,208,

3,133, 136, 32,

J, 1 -OO,

32,143, 169,141,

6,169, 141, 3, 169,170,

12, 134,

8,

6, 157,

157,

157,

3,

93,

2, 40, 189, 162, 250,

49, 229,

49, 247,

o, 133,

6,

141,

134,

67, 141,

32,

o, o, 232,

0,

232, 250.

93,

6,

138,

1, 169,

32, 253,

32, 169,

6, 141, 169,

5j

81

169

38

0

-r

169

157

253 173

72 138

0 48 32 233

35 169

2 76

6

1000 DATA169,252,141

, 6, 6,169

,224,13

1010 DATA
 :,165, 3, 48,252, 76,148,193

146

-----------------------------------------------------Page 146-----------------------------------------------------
﻿
FULL TRACK 20 ERROR SOURCE LISTING

100 110

REM REM

20M.PAL

120 130 140 150 160 170 180 190 200 210

0PEN2,8,2,"@0:20M.

REM

SYS40960

«

.OPT P,02

?

*= *0400

<t

;* INITIALIZATION

5

B,P,W"

*

220 230 240 250 260 270 280 290 300 310 320 330 340 350

LDA STA LDX STX STX LDX INX STX LDA STA LDA STA LDA STA

#*00 *7F *0C *51 *80 *0D

*43

#*01

*0620 8*08

*0626 #*00

*0628

5

TAIL GAP

SECTOR COUNTER

360

5

370
 JSR

*C100

<•

LED ON

380 390 400

?

;* CREATE HEADERS

*

*

410
 LDX
 #*00

420

HEADER LDA #*09

HBID

430 440 450 460 470 480 490 500 510 520 530
 STA INX INX LDA STA

INX LDA STA INX LDA STA

*0300,X

*0628

*0300,X

*51

*0300,X

#*00

*0300,X

5

5

5

?

CHECKSUM

SECTOR

TRACK

IDL

540
 INX

550 560 570
 STA

INX LDA

*0300,X

#*0F

•

IDH

147

-----------------------------------------------------Page 147-----------------------------------------------------
﻿
580 STA *0300,X ; GAP

590 INX

600 STA *0300,X ? GAP

610 INX

620 ;

630 LDA #*00 ? COMPUTE CHECKSUM

640 EOR *02FA,X 650 EOR *02FB,X

660 EOR *02FC,X

670 EOR *02FD,X

680 STA *02F9,X

690 ;

700 INC *062S 710 LDA *0628 720 CMP *43

730 BNE HEADER 740 ;

750 TXA 760 PHA

770 ;

780 ;* CREATE DATA * 790 ;

800 LDA #*4B ; 1541 FORMAT

810 STA *0500

820 LDX 4**01 ; 1541 FORMAT

830 TXA

840 DATA STA *0500,X

850 INX

860 BNE DATA 870 ;

880 ;* CONVERT TO GCR *

890 ;

900 LDA #*00 910 STA *30 920 LDA #*03 930 STA *31

940 JSR *FE30 950 PLA 960 TAY 970 DEY

980 JSR *FDE5 990 JSR *FDF5 1000 LDA #*05 1010 STA *31

1020 JSR *F5E9 1030 STA *3A

1040 JSR *F78F 1050 ;

1060 ;* JUMP INSTRUCTION * 1070 ;

148

-----------------------------------------------------Page 148-----------------------------------------------------
﻿
1080 1090 1100 1110 1120 1130 1140 1150 1160 1170 1180 1190 1200 1210 1220 1230 1240 1250 1260 1270
 LDA STA

5

LDA STA LDA STA LDA STA LDA STA LDA STA LDA STA LDA STA

5

LDA STA

#*23 *51

#*A9

*0600 #*05

*0601 #*85

*0602 #*31

*0603 #*4C

*0604 #*AA

*0605 #*FC

*0606

#*E0 *03

1280 1290

»

WAIT LDA *03

1300 1310 1320
 BMI

?

J MP

WAIT

*C194

Full Track 20 Error Source Annotation

This routine has a real surprise in store. Initialization in lines 220-290 sets the drive number to 0 ($007F) rather than rely on a default. The track is read from the header table location $000C and stored at $0051. (Recall that the driver set up the header table.) This memory location normally contains an $FF at powerup to let the drive know that formatting has not yet begun. We must reset it to the active track, or the drive will do a BUMP to track one to start the format. Similarly, we read the sector range from $000D, incremented this number to obtain a sector total for the track, and stored it at $0043. Line 300 is our try counter. Normally the drive makes 10 attempts to format a single track. We either get it right the first time or give up. (The driver erases the track as a safeguard.) We cannot allow the FDC to reattempt to format the track because it will bypass our machine language routine and re-enter the standard ROM routine. Lines 310-330 arbitrarily sets the tail gap to eight bytes in length. This avoids duplicating 245 bytes of code from $FB1D to $FC12. RAM is at a dire premium and we have neither

the overhead nor the desire.

Next we turn on the LED for cosmetic purposes (line 370) and build our header table and a dummy data block (lines 410-860). We incremented the data block identifier in line 420. Binary to GCR conversion is done in lines 900-1040. Now for the jump instruc¬

tion. First we reset the track number to 35 (lines 1080-1090) to let the FDC think that

this is the last track of a normal format. Why? We will be passing control to a standard ROM routine in a minute and will let the FDC execute it. In other words, we are going to work the 6502 in both IP and FDC modes. Formatting is done as a single job; one

149

-----------------------------------------------------Page 149-----------------------------------------------------
﻿
track at a time. When a track is formatted the FDC looks at $0051 to see if 35 tracks have been done. If not, it increments $0051 and does the next track as another discrete job. The IP is going to wait for the FDC to reformat the track and then retake control. We store the indirect buffer pointer to our data block buffer and a jump to $FCAA at $0600. This ensures that the data block will not be lost in the ensuing shuffle. We then set up the job queue for an execute of buffer number 3 ($0600) and away we go. The IP monitors the FDC while it is reformatting the track. (Not only that, but the FDC will verify the track to ensure that it was reformatted incorrectly!) When bit seven of the job code ($E0) goes low, the IP wrestles control away from the FDC and jumps

to ENDCMD ($C194) to terminate the routine. DOS ist gut!

7.13 How to Create 27 Errors on a Full Track

Limitations: None.

Parameters: Track number.

FULL TRACK 27 ERROR

100 REM 27M ERROR - 1541 110 DIMD*(25)

120 PRINT"{CLR3MULTIPLE 27 ERROR - 1541"

130 PRINT"{DOWN}INSERT CLONE IN DRIVE" 140 INPUT"{DOWN}DESTROY TRACK";T 150 IFT<1ORT >35THENEND

160 INPUT"{DOWN}ARE YOU SURE Y{LEFT 3}"

;Q*

170 IFQ*<>"Y"THENEND

180 0PEN15,8,15

190 PRINT#15,"10"

200 INPUT#15,EN*,EM*,ET*,ES*

210 IFEN*="00"G0T0260

220 PRINT"{DOWN}"EN*", "EM*","ET*","ES*

230 CLOSE15 240 END

250 REM SEEK

260 NS=20+2*(T>17)+(T>24)+(T>30) 270 S=NS

280 J0B=176 290 G0SUB580

300 FORI=OT023 310 READD

320 D*=D*+CHR*(D) 330 I*=I*+CHR*(0) 340 NEXTI

350 PRINT#15,"M-W"CHR*(0)CHR*(6)CHR*(24>

D*

360 REM EXECUTE

150

-----------------------------------------------------Page 150-----------------------------------------------------
﻿
370 PRINT"{DOWN}{RVS}DESTROYING{R0FF} TR ACK"jT

380 J0B=224 390 G0SUB580

400 PRINT#15,"M-W"CHR*(0)CHR*(6)CHR*(24)

I*

410 F0RJ=0T025 420 F0RI=0T07 430 READD

440 D*(J)=D*(J)+CHR*(D) 450 NEXTI 460 NEXTJ 470 1=0

480 F0RJ=0T025

490 PRINT#15,"M-W"CHR*(I)CHR*(4)CHR*(8)D

*(J)

500 1=1+8 510 NEXTJ

520 REM EXECUTE

530 PRINT#15,"M-E"CHR*(0)CHR*(4)

540 CLOSE15

550 PRINT"{DOWN}DONE!" 560 END

570 REM JOB QUEUE 580 TRY=0

590 PRINT#15,"M-W"CHR*(12)CHR*(0)CHR*(2)

CHR*(T)CHR*(S)

600 PRINT#15,"M-W"CHR*(3)CHR*(0)CHR*(1)C

HR*(JOB)

610 TRY=TRY+1

620 PRINT#15,"M-R"CHR*(3)CHR*(0) 630 GET#15,E*

640 IFE*=""THENE*=CHR*(0) 650 E=ASC(E*)

660 IFTRY=500G0T0690 670 IFE>127G0T0610 680 RETURN 690 CLOSE15

700 PRINT"{DOWN}{RVS}FAILED{ROFF}" 710 END

720 REM 21 ERROR

730 DATA 32,163,253,169, 85,141, 1, 28

740 DATA 162,255,160, 48, 32,201,253, 32

750 DATA 0,254,169, 1, 76,105,249,234

760 REM 27M ERROR

770 DATA169, 0,133,127,166, 12,134, 81 780 DATA134,128,166, 13,232,134, 67,169

151

-----------------------------------------------------Page 151-----------------------------------------------------
﻿
790 DATA 1,141, 32, 6,169, 8,141, 38 800 DATA 6,169, 0,141, 40, 6, 32, 0 810 DATA193,162, 0,169, 8,157, O, 3 820 DATA232,232.173, 40, 6,157, O, 3 830 DATA232,165, 81,157, O, 3,232,169 840 DATA 0,157, O, 3,232,157, O, 3 850 DATA232,169, 15.157, 0, 3,232,157 860 DATA O, 3.232,169, O, 93,250, 2 870 DATA 93,251, 2, 93,252, 2, 93,253 880 DATA 2,157,249, 2,254,249, 2,238 890 DATA 40, 6,173, 40, 6,197, 67,208 900 DATA186,138, 72,169, 75,141, O, 5 910 DATA162, 1,138,157, O, 5,232,208 920 DATA250,169, 0,133, 48,169, 3,133 930 DATA 49, 32, 48,254,104,168,136, 32 940 DATA229,253, 32,245,253,169, 5,133 950 DATA 49, 32,233,245,133, 58, 32,143 960 DATA247,169, 35,133, 81,169,169,141 970 DATA O, 6.169, 5,141, 1, 6,169 980 DATA133,141, 2, 6,169, 49,141, 3 990 DATA 6,169, 76,141, 4, 6,169,170 1000 DATA141, 5, 6,169,252,141, 6, 6

1010 DATA169,224,133, 3,165, 3, 48,252

1020 DATA 76,148,193,234,234,234,234,234

FULL TRACK 27 SOURCE LISTING

100 REM 27M.PAL 110 REM

120 0PEN2,8,2,"@0:27M.B,P,W"

130 REM

140 SYS40960

150 160 170 180 190 200 210 220 230 240 250 260 270 280 290

5

.OPT P,02

*= *0400 |S

;* INITIALIZATION

5

LDA #*00 STA *7F LDX *0C STX *51 STX *80 LDX *0D

INX

STX *43

300 LDA #*01

152

-----------------------------------------------------Page 152-----------------------------------------------------
﻿
310 STA 320 LDA 330 STA 340 LDA 350 STA
 *0620 #*08

*0626 #*00

*0628

i

?

TAIL GAP

SECTOR COUNTER

360 ;

370 JSR
 *C100

?

LED ON

380 ;

390 ;* CREATE HEADERS

400 :

*

410 LDX
 #*00

420 HEADER # LDA 430 STA

*0300,X

440 INX 450 INX

*0628

460 LDA

#*08

1

; HBID

CHECKSUM

470 STA 480 INX 490 LDA 500 STA 510 INX 520 LDA 530 STA
 *0300,X

*51

*0300,X

#*oo

*0300,X

?

*

m

SECTOR

TRACK

IDL

540 INX

550 STA 560 INX 570 LDA 580 STA
 *0300,X

#*OF

*0300,X

?

%

IDH

GAP

590 INX

600 STA

*0300,X

*

GAP

610 INX 620 ;

630 LDA 640 EOR 650 EOR 660 EOR 670 EOR 680 STA

#*00

*02FA,X *02FB,X

*02FC.X

*02FD,X *02F9,X

*

COMPUTE CHECKS

690 ;

700 INC

710 ;

720 INC 730 LDA 740 CMP 750 BNE 760 ;

770 TXA 780 PHA 790 ;

*02F9,X

*0628 *0628 *43

HEADER

5

INCREMENT CHEC

153

-----------------------------------------------------Page 153-----------------------------------------------------
﻿
800 ;* CREATE DATA *

810 ;

820 LDA #*4B 5 1541 FORMAT 830 STA *0500

840 LDX #*01 ; 1541 FORMAT

850 TXA

860 DATA STA *0500,X

870 INX

880 BNE DATA 890 ;

900 ;* CONVERT TO GCR * 910 ;

920 LDA #*00 930 STA *30 940 LDA #*03 950 STA *31

960 JSR *FE30 970 PLA 980 TAY 990 DEY

1000 JSR *FDE5 1010 JSR *FDF5 1020 LDA #*05 1030 STA *31

1040 JSR *F5E9 1050 STA *3A

1060 JSR *F78F 1070 ;

1080 ;* JUMP INSTRUCTION * 1090 ;

1100 LDA #*23 1110 STA *51 1120 ;

1130 LDA #*A9 1140 STA *0600 1150 LDA #*05 1160 STA *0601 1170 LDA #*85 1180 STA *0602 1190 LDA #*31 1200 STA *0603 1210 LDA #*4C 1220 STA *0604 1230 LDA #*AA 1240 STA *0605 1250 LDA #*FC 1260 STA *0606 1270 ;

1280 LDA #*E0 1290 STA *03

154

-----------------------------------------------------Page 154-----------------------------------------------------
﻿
1300 ;

1310 WAIT LDA *03 1320 BMI WAIT 1330 ;

1340 JMP *C194

Full Track 27 Error Source Annotation

See the annotation for 20M.PAL. The only major difference is in line 700 above. Note the header block identifier ($08) in line 420 is left alone.

7.14 How to Create a 22 Error on a Single Sector

Limitations: None.

Parameters: Track and sector number.

SINGLE SECTOR 22 ERROR

100 REM 22A ERROR - 1541

110 PRINT"{CLR}22A ERROR - 1541"

120 PRINT"{DOWN}INSERT CLONE IN DRIVE" 130 INPUT"{DOWN}DESTROY TRACK AND SECTOR

(T,S)";T,S

140 IFT<10RT>35THENEND

150 NS=20+2*(T>17)+(T>24)+(T>30) 160 IFS<OORS>NSTHENEND

170 INPUT"{DOWN}ARE YOU SURE Y{LEFT 3}" ;q*

180 IFQ*<>"Y"THENEND

190 0PEN15,8, 15

200 PRINT#15,"10"

210 INPUT#15,EN*,EM*,ET*,ES*

220 IFEN*="00"G0T0270

230 PRINT"{DOWN}"EN*", "EM*","ET*","ES*

240 CLOSE15 250 END

260 REM SEEK 270 J0B=176 280 G0SUB440

290 IFEO1G0T0550 300 REM READ 310 J0B=128 320 G0SUB44O

330 IFE< >1ANDE< >4ANDE< >5G0T0550

340 PRINT#15,"M-W"CHR*(71)CHR*(0)CHR*(D

CHR*(6)

350 REM WRITE 360 J0B=144

155

-----------------------------------------------------Page 155-----------------------------------------------------
﻿
370 G0SUB440

380 PRINT#15,"M-W"CHR*(71)CHR*(0)CHR*(1)

CHR*(7)

390 IFEO1G0T0550 400 CLOSE15

410 PRINT"{DOWN}DONE!" 420 END

430 REM JOB QUEUE 440 TRY=0

450 PRINT#15,"M-W"CHR*(8)CHR*(0)CHR*(2)C

HR*(T)CHR*(S)

460 PRINT#15,"M-W"CHR*(1)CHR*(0)CHR*(DC

HR*(JOB)

470 TRY=TRY+1

480 PRINT#15,"M-R"CHR*(1)CHR*(O) 490 GET#15,E*

500 IFE*=""THENE*=CHR*(0) 510 E=ASC(E*)

520 IFTRY=500G0T0540 530 IFEM27G0T0470 540 RETURN 550 CLOSE15

560 PRINT"{DOWN}{RVS}FAILED{ROFF}" 570 END

SINGLE SECTOR 22 ERROR SOURCE LISTING

None. Line 340 in the program creates a single sector 22 error by decrementing the data block identifier. Line 380 restores the status quo.

7.15 How to Duplicate a 22 Error on a Single Sector

Limitations: None (requires disk swapping).

Parameters: Track and sector number.

DUPLICATE A SINGLE SECTOR 22 ERROR

100 REM DUPLICATE A 22 ERROR - 1541

110 PRINT"{CLR}DUPLICATE A 22 ERROR - 15

41"

120 PRINT"{DOWN}INSERT MASTER IN DRIVE"

130 INPUT"{DOWN}TRACK AND SECTOR (T,S)";

T,S

140 IFT<10RT>35THENEND

150 NS=20+2*(T>17)+(T>24)+(T>30) 160 IFS<OORS>NSTHENEND

170 INPUT"{DOWN}ARE YOU SURE Y{LEFT 3}" ;q*

156

-----------------------------------------------------Page 156-----------------------------------------------------
﻿
180 IFQ*<>"Y"THENEND

190 0PEN15,8,15

200 PRINT#15,"10"

210 INPUT#15,EN*,EM*,ET*,ES*

220 IFEN*="00"G0T0270

230 PRINT"{DOWN}"EN*", "EM*","ET*","ES*

240 CLOSE15 250 END

260 REM SEEK 270 J0B=176 280 G0SUB550 290 REM READ 300 J0B=128 310 G0SUB550

320 PRINT#15,"M-R"CHR*(56)CHR*(0)

330 GET#15,D*

340 1FD*=""THEND*=CHR*(0) 350 CLOSE15

360 PRINT"{DOWN}REMOVE MASTER FROM DRIVE

It

370 PRINT"INSERT CLONE IN DRIVE"

380 PRINT"PRESS {RVS}RETURN{ROFF} TO CON TINUE"

390 GETC*:IFC*=""THEN390 400 IFC*OCHR*(13)G0T0390 410 PRINT"0K"

420 0PEN15,8,15

430 REM SEEK 440 J0B=176 450 G0SUB550

460 PRINT#15,"M-W"CHR*(71)CHR*(0)CHR*(D

D*

470 REM WRITE 480 J0B=144 490 G0SUB550

500 PRINT#15,"M-W'CHR*(71)CHR*(O)CHR*(1)

CHR*(7)

510 CL0SE15

520 PRINT"{DOWN}DONE!" 530 END

540 REM JOB QUEUE 550 TRY=0

560 PRINF#15,"M-W"CHR*(8)CHR*(0)CHR*(2)C

HR*(T)CHR*(S)

570 PRINT#15,"M-W"CHR*(1)CHR*(0)CHR*(1)C

HR*(JOB)

580 TRY=TRY+1

590 PRINT#15,"M-R"CHR*(1)CHR*(O) 600 GET#15,E*

610 IFE*=""THENE*=CHR*(O)

157

-----------------------------------------------------Page 157-----------------------------------------------------
﻿
620 E=ASC(E*)

630 IFTRY=500G0T0660 640 IFEM27G0T0580 650 RETURN

660 PRINT#15,"M-W"CHR*(71)CHR*(0)CHR*(D

CHR*(7)

670 CLOSE15

680 PRINT"{DOWN}{RVS}FAILED{ROFF}" 690 END

DUPLICATE A SINGLE SECTOR 22 ERROR SOURCE LISTING

None. Line 320 in the program reads the data block identifier from the master. Lines 460-490 duplicate the error on the clone. Line 500 puts our house back in order.

7.16 How to Format a Diskette with Multiple IDs

Limitations: None (requires disk swapping).

Parameters: None.

MULTIPLE ID FORMATTING

100 REM FORMAT A DISKETTE - 1541

HO DIMT(35),H*(35),L*(35>

120 PRINT"{CLR}FORMAT A DISKETTE - 1541"

130 PRINT"{DOWN}INSERT {RVS}MASTER{ROFF}

IN DRIVE"

140 GOSUB910

150 PRINT"{DOWN}{RVS}FETCHING{ROFF} FORM

ATTING ID"

160 0PEN15,8,15

170 F0RI=1T035 180 T(I)=1 190 NEXTI

200 J0B=176

210 F0RT=1T035

220 IFT(T)=0G0T0340 230 G0SUB970

240 IFE=1G0T0280 250 H*(T)=CHR*(0) 260 L*(T)=CHR*(0) 270 G0T0340

280 PRINT#15,"M-R"CHR*(22)CHR*(0) 290 GET#15,H*(T)

300 IFH*(T)=""THENH*(T)=CHR*(O)

310 PRINT#15,"M-R"CHR*(23)CHR*(0)

320 GET#15,L*(T)

158

-----------------------------------------------------Page 158-----------------------------------------------------
﻿
330 340 350 360 370 380
 IFL*(T)=""THENL*(T)

NEXTT T=18

G0SUB970 CLOSE15

PRINT"{CLR3F0RMAT A

=CHR*(0)

DISKETTE - 1541"

390

PRINT"{DOWN!

>INSERT
 {RVS3BLANK{R0FF}

IN DRIVE"

400 410 420 430 440 450 460 470 480 490

G0SUB910

0PEN15,8.15

F0RJ=0T06 F0RI=0T07 READD

D*(J)=D*(J)+CHR*(D)

NEXTI NEXTJ

1=0

F0RJ=0T06

500

PRINT#15, "M-

-W"CHR*(I)CHR*(4)CHR*(8)D

*(J)

510 1=1+8 520 NEXTJ

530 F0RI=1T035

540 PRINT#15,"M-W"CHR*(49+I)CHR*(4)CHR*(

1)L*(I)

550 PRINT#15."M-W"CHR*(84+I)CHR*(4)CHR*(

1)H*(I)

560 NEXTI

570 REM EXECUTE

580 PRINT"{DOWN}CRVS}FGRMATTING{ROFF} DI

SKETTE"

590 PRINT#15,"M-E"CHR*(0)CHR*(4) 600 INPUT#15,EN*,EM*,ET*,ES*

610 T=18 620 S=0

630 J0B=176 640 G0SUB970 650 J0B=128 660 G0SUB970

670 PRINT#15, "M-W"CHR*(0)CHR*(4)CHR*(3)C

HR*(18)CHR*(1)CHR*(65) 680 J0B=144 690 G0SUB970 700 S=l

710 J0B=128 720 G0SUB970

730 PRINT#15,"M-W"CHR*(0)CHR*(4)CHR*(2)C

HR*(0)CHR*(255) 740 J0B=144 750 G0SUB970

159

-----------------------------------------------------Page 159-----------------------------------------------------
﻿
760 CLOSE15

770 0PEN15,8,15

780 PRINT#15,"NO:1541 FORMAT" 790 INPUT#15,EN*,EM*,ET*,ES*

800 S=0

810 J0B=128 820 G0SUB970

830 PRINT#15,"M-W"CHR*(162)CHR*(4)CHR*(2

)CHR*(50)CHR*(54) 840 J0B=144 850 G0SUB970

860 PRINT#15,"M-W"CHR*(162)CHR*(7)CHR*(2

>CHR*(50)CHR*(54) 870 CLOSE15

880 PRINT"{DOWN}DONE!" 890 END

900 REM DELAY

910 PRINT"{DOWN}PRESS {RVS}RETURN{R0FF3 TO CONTINUE"

920 GETC*:IFC*=""THEN920 930 IFC* <>CHR*(13)G0T0920 940 PRINT"OK" 950 RETURN

960 REM JOB QUEUE 970 TRY=0

980 PRINT#15,"M-W"CHR*(8)CHR*(0)CHR*(2)C

HR*(T)CHR*(S)

990 PRINT#15, "M-W"CHR* (1) CHR* (O) CHR* (DC

HR*(JOB)

1000 TRY=TRY+1

1010 PRINT#15,"M-R"CHR*(1)CHR*(0) 1020 GET#15,E*

1030 IFE*=""THENE*=CHR*(0) 1040 E=ASC(E*)

1050 IFTRY=500G0T01070 1060 IFEM27G0T01000 1070 RETURN 1080 REM NEW

1090 DATA169, 0,133,127, 32, 0,193,169

1100 DATA 76,141, O, 6,169,199,141, 1

1110 DATA 6,169,250,141, 2, 6,169,224

1120 DATA133, 3,164, 81,185, 49, 4,133

1130 DATA 19,185, 84, 4,133, 18,192, 35

1140 DATA208,240,165, 3, 48,252, 76,148

1150 DATA193,234,234,234,234,234,234,234

160

-----------------------------------------------------Page 160-----------------------------------------------------
﻿
MULTIPLE ID FORMATTING SOURCE LISTING

100 110
 REM REM
 FAD.PAL

120
 0PEN2,8,2,"@0:

:fad.b,p,

,W"

130 140 150 160 170 180
 REM

SYS40960 5

.OPT P,02

5

*= *0400

190 200 210 220
 IDL IDH

LDA

= *0431

= IDL+35

#*00

230
 STA
 *7F

a

J

DRIVE

NUMBER

240

5

250
 JSR
 *C100

5

LED

260

5

270 280 290 300 310 320
 LDA STA LDA STA LDA STA
 #*4C

*0600 #*C7

*0601 #*FA

*0602

5

JUMP TO *FAC7

330 340 350 360 370

5

LDA
 #*E0

STA *03

5

TABLE LDY *51

5

TRACK
 NUMBER

380

»

390 400
 LDA STA

IDL,Y

*13

5

ID LO

410

5

420 430

LDA STA
 IDH,Y

*12

5

ID HI

440

?

450

CPY
 #*23

5

TRACK

35

460

BNE
 TABLE

470 480

5

WAIT LDA *03

490 500 510

BMI

5

J MP

WAIT

*C194

Multiple ID Formatting Source Annotation

This is a modification of the standard formatting routine, NEW ($EEOD). Embedded IDs are read from each track on the master and tabled in 1541 RAM starting at $0431

161

-----------------------------------------------------Page 161-----------------------------------------------------
﻿
by the driver. The appropriate ID for each track is stored as the master disk ID ($12/3) by the IP before control is passed to the FDC to format a track. After a track is format¬ ted, the IP retakes control, finds the next ID in the table, stores it at $12/3, and passes control back to the FDC. Because we do not have a N0:DISK NAME,ID command in the command buffer, we cannot use the later portions of the standard formatting routine to create the BAM and directory. Lines 670-780 of the driver clean up afterward.

7.17 How to Backup a DOS Protected Diskette

Limitations: Does not recreate any bad sectors. Requires six passes to backup a diskette

(see the annotation below).

Parameters: A formatted diskette.

1541 BACKUP

100 REM 1541 BACKUP 110 P0KE56,33 120 CLR

130 F0RI=1T0144 140 READD

150 P0KE49151+I,D

160 NEXTI

170 DIMT(35)

180 F0RI=1T035 190 T(I)=1 200 NEXTI

210 READSRW,ERW

220 PRINT"{CLR}1541 BACKUP"

230 PRINT"{DOWN}INSERT MASTER IN DRIVE" 240 G0SUB1110

250 0PEN15,8,15

260 RW=8448

270 F0RI=1T0126

280 P0KE8447+I,0

290 NEXTI

300 RAM=8704

310 P0KE252,34

320 C=0

330 REM SEEK

340 FORT=SRWTOERW

350 NS=20+2*(T >17) + (T >24) + (T >30) 360 IFT(T)=0G0T0410

370 J0B=176

380 GOSUB1190

390 IFE=1G0T0470 400 T(T)=0

410 RW=RW+(NS+1)

420 RAM=RAM+(256*(NS+1))

162

-----------------------------------------------------Page 162-----------------------------------------------------
﻿
430 P0KE252,(RAM/256)

440 R=R+(NS+1) 450 G0T0620 460 REM READ

470 F0RS=0T0NS 480 GOSUB1300

490 PRINT"{HOME}{DOWN 7}{RVS}READING{ROF F} TRACK "T*" - SECTOR "S* 500 J0B=128

510 G0SUB1190

520 IFE=1G0T0550 530 R=R+1

540 IFEO4ANDEO5G0T05S0 550 SYS49165 560 C=l

570 POKERW,1

580 RW=RW+1

590 RAM=RAM+256

600 P0KE252,(RAM/256)

610 NEXTS 620 NEXTT

630 CLOSE15

640 IFC=0G0T01010

650 PRINT"{CLR}1541 BACKUP"

660 PRINT"CDOWN}INSERT CLONE IN DRIVE" 670 G0SUB1110

680 0PEN15,8,15

690 RW=8448 700 RAM=8704

710 P0KE252,34

720 REM SEEK

730 FORT=SRWTOERW

740 NS=20+2*(T>17)+(T>24)+(T>30) 750 J0B=176

760 GOSUB1190

770 IFE=1G0T0S20

780 RAM=RAM+(256*(NS+1)) 790 W=W+(NS+1) 800 G0T0990

810 REM WRITE

820 IFT(T)=1G0T0870 830 RW=RW+(NS+1)

840 RAM=RAM+(256*(NS+1))

850 P0KE252,(RAM/256)

860 G0T099O

870 FORS=OTONS

880 IFPEEK(RW)=0G0T0950 890 GOSUB1300

900 PRINT"{HOME}{DOWN 7}{RVS}WRITING{ROF F} TRACK "T*" - SECTOR "S*

163

-----------------------------------------------------Page 163-----------------------------------------------------
﻿
910 SYS49228 920 J0B=144

930 GOSUB1190

940 IFE<>1THENW=W+1 950 RW=RW+1

960 RAM=RAM+256

970 P0KE252,(RAM/256)

980 NEXTS 990 NEXTT

1000 CLOSE15

1010 IFERWO35G0T0210

1020 PRINT"{HOME}{DOWN 2}READ ERRORS : "R

ii ii

1030 PRINT"{DOWN}WRITE ERRORS:"W"

ll

1040 PRINT" "

1050 PRINT"DONE!" 1060 PRINT"

1070 P0KE56,160

1080 CLR 1090 END

1100 REM DELAY

1110 PRINT"{DOWN}PRESS {RVS}RETURN{ROFF}

TO CONTINUE"

1120 IFC=0ANDSRW< >1GOTO1160 1130 GETC*:IFC*<>""THEN1130 1140 GETC*:IFC*=""THEN1140 1150 IFC*< >CHR*(13)GOTO1140 1160 PRINT"OK" 1170 RETURN

1180 REM JOB QUEUE 1190 TRY=0

1200 PRINT#15,"M-W"CHR*(8)CHR*(O)CHR*(2)

CHR*(T)CHR*(S)

1210 PRINT#15, "M-WCHR* (1) CHR* (O) CHR* ( 1)

CHR*(JOB)

1220 TRY=TRY+1

1230 PRINT#15, ,,M-R"CHR*(1)CHR*(0) 1240 6ET#15,E*

1250 E=ASC(E*+CHR*(O)) 1260 IFTRY=500G0T01280 1270 IFEM27G0T01220 1280 RETURN

1290 REM STR*(T,S)

1300 T*=RIGHT*("O"+RIGHT*(STR*(T),LEN(ST

R*(T))-1),2)

1310 S*=RIGHT*("0"+RIGHT*(STR*(S),LEN(ST

R*(S))-1),2)

1320 RETURN

1330 REM *C000

164

-----------------------------------------------------Page 164-----------------------------------------------------
﻿
1340 DATA 77, 45, 82

1350 DATA 45, 87, 0

1360 DATA251,141, 3

1370 DATA128,133,251

1380 DATA192, 96,162

1390 DATA O,189, O

1400 DATA224, 7,208

1410 DATA 15, 32,198

1420 DATA255,145,251

1430 DATA 32,204,255

1440 DATA192,240, 11

1450 DATA 32,141, 10

1460 DATA 32,201,255

1470 DATA 32,210,255

1480 DATA173, 10,192

1490 DATA251, 32,210

1500 DATA246,169, 13

1510 DATA255,169, O

1520 REM TRACK

1530 DATA1,6,7,12,13

O, 4,255,128, 77

4, 32,169, 0,133

192, 32, 34,192,169

141, 3,192, 32, 34

15, 32,201,255,162

192, 32,210,255,232

245, 32,204,255,162

255,160, O, 32,207

200,192,129,208,246

96,169, 0,141, 10

173, 10,192, 24,105

192,240, 47,162, 15

162, 0,189, 7,192

232,224, 6,208,245

133,251,160, 0,177

255,200,192, 32,208

32,210,255, 32,204

240,198, 96,234,234

17,18,24,25,30,31,3

1541 BACKUP SOURCE LISTING

100 REM BACKUP.PAL 110 REM

120 OPEN 2,8,2,"@0:M.B,P,W"

130 REM

140 SYS40960

150 ;

160 .OPT P,02

170 ;

165

-----------------------------------------------------Page 165-----------------------------------------------------
﻿
180 ; M-R / M-W ROUTINES 190 ;

200 *= *C000 210 ;

220 ; RAM LOCATIONS USED 230 ;

240 POINT = *00FB ;POINTER TO READ/WRITE

PAGE

250 ;

260 j ROM ROUTINES USED 270 ;

280 CHKOUT = *FFC9 ; OPEN CHANNEL FOR OUT PUT

290 CHROUT = *FFD2 ?OUTPUT A CHARACTER 300 CLRCHN = *FFCC ;CLEAR ALL CHANNELS 310 CHKIN = *FFC6 ;OPEN CHANNEL FOR INP

UT

-320 CHR IN = *FFSF ;INPUT A CHARACTER

330 ;

340 ; DISK M-R 3< M-W COMMANDS 350 ;

360 MR -ASC "M-R"

370 .BYTE *00,*04,*FF,*80

380 ;

390 MW .ASC "M-W"

400 TEMP .BYTE *00,*04,*20

410 ;

420 ; *

430 ;* READ FROM DISK ROUTINES *

440 ; *

450 ; M-R ENTRY POINT 460 ;

470 LDA #*00

480 STA POINT ;POINT TO FIRST HALF 490 STA MR+3 jASK FOR FIRST HALF 500 JSR READIT jREAD FIRST HALF 510 ;

520 LDA tt*80

530 STA POINT ;POINT TO SECOND HALF 540 STA MR+3 ;ASK FOR SECOND HALF 550 JSR READIT ; READ SECOND HALF 560 ;

570 RTS ;RETURN TO BASIC

580 ;

590 ; SUBROUTINE TO READ IN HALF PAGE 600 ;

610 READIT LDX #*0F ;PREPARE CHANNEL 15 FOR OUTPUT

620 JSR CHKOUT 630 ;

166

-----------------------------------------------------Page 166-----------------------------------------------------
﻿
640 LDX #*00

650 L00P1 LDA MR,X ;SEND M-R COMMAND

660 JSR CHROUT 670 INX

680 CPX #*07 690 BNE L00P1 700 ;

710 JSR CLRCHN ; CLEAR THE CHANNEL

720 ;

730 LDX #*0F ;PREPARE CHANNEL 15 FOR IMP

UT

740 JSR CHKIN

750 ;

760 LDY 4**00

770 L00P2 JSR CHRIN

780 STA (POINT),Y

790 INY

800 CPY #*81 810 BNE L00P2 820 ;

830 JSR CLRCHN ; CLEAR THE CHANNEL

840 RTS ;END OF READ HALF PAGE

850 ;

860 ; *

870 ;* SEND TO DISK ROUTINES * 880 ; *

890 ; FIRST M-W ENTRY POINT 900 ;

910 MRITE LDA #*00 ;INITIALIZE PART PAGE

POINTER

920 STA TEMP 930 BEQ ENTER 940 ;

950 L00P3 LDA TEMP 960 CLC

970 ADC #*20 980 STA TEMP 990 BEQ DONE 1000 ;

1010 ENTER LDX #*0F ;PREPARE CHANNEL 15

FOR OUTPUT

1020 JSR CHKOUT 1030 ;

104O LDX #*00

1050 L00P4 LDA MW,X ;SEND "M-W LO HI *20

II

1060 JSR CHROUT 1070 INX

1080 CPX #*06 1090 BNE L00P4

167

-----------------------------------------------------Page 167-----------------------------------------------------
﻿
lioo ;

1110 LDA TEMP ;POINT TO START OF PART PA

GE

1120 STA POINT 1130 ;

1140 LDY #*00 1150 ;

1160 LOOPS LDA (POINT),Y ; SEND 32 CHARAC

TERS

1170 JSR CHROUT 1180 INY

1190 CPY #*20

1200 BNE LOOPS ;NOT DONE 32 YET 1210 ;

1220 LDA #*OD 5 CARRIAGE RETURN 1230 JSR CHROUT

1240 JSR CLRCHN ;CLEAR THE CHANNEL 1250 ;

1260 LDA #*00

1270 BEQ L00P3 ;ALWAYS TO DO NEXT PART 1280 ;

1290 DONE RTS ;BACK TO BASIC

1541 Backup Source Annotation

The BASIC driver reads a sector from the master diskette into 1541 RAM using the job queue. The contents of the RAM are transferred into the C64 with a machine language memory-read. After a pass is complete, the clone is inserted into the drive. A machine language memory-write command is then used to transfer the bytes back to 1541 RAM. The BASIC drive writes the buffer out to the diskette using the job queue. The above routine illustrates how to do memory-read and memory-write commands in machine language. It is interesting to note that reading 256 bytes from 1541 RAM appears to take amost ten times as long as writing 256 bytes to 1541 RAM. However, the C64 in¬ ternal clock is not reliable at all while performing I/O to the disk drive. Bypassing a bad track can be done anywhere between lines 200-340 if necessary. Any of the previous 11 routines may be used to recreate any errors that you found on the master diskette after a backup is made.

7.18 How to Copy a File

Limitations: 125 blocks in length

Will not copy a relative file Wild cards are not permitted

Parameters: File name and file type.

168

-----------------------------------------------------Page 168-----------------------------------------------------
﻿
1541 COPY

100 REM 1541 COPY 110 P0KE56.16

120 CLR

130 P0KE251,0 140 P0KE252, 16 150 P0KE253,0

160 P0KE254,16

170 F0RI=1T072 180 READD

190 P0KE49151+I,D

200 NEXTI

210 PRINT"{CLR}1541 COPY"

220 PRINT"{DOWN}INSERT MASTER IN DRIVE" 230 G0SUB750 240 G0SUB810

250 INPUT"{DOWN}FILENAME";F*

260 IFLEN(F*X >0ANDLEN(F*)<17G0T0280 270 GOTO1000

280 INPUT"{DOWN}FILE TYPE (DSPU) P{LEFT

3}";T*

290 IFT*="D"ORT*="S"ORT*="P"ORT*="U"GOTO 310

300 GOTO1000 310 RW*="R" 320 G0SUB890 330 SYS49152 340 CL0SE2

350 INPUT#15,EN*,EM*,ET*,ES*

360 IFEN*="00"G0T0380 370 G0T0850 380 CLOSE15

390 PRINT"{DOWN}INSERT CLONE IN DRIVE" 400 G0SUB750 410 G0SUB810

420 PRINT#15,"M-R"CHR*(1)CHR*(1) 430 GET#15,D*

440 D=ASC(D*+CHR*(0)) 450 IFD=65G0T0490

460 PRINT"{DOWN}73,CBM DOS V2.6 1541,00,

00"

470 G0T0710

480 PRINT#15,"M-R"CHR*(250)CHR*(2)CHR*(3

)

490 GET#15,L*

500 L=ASC(L*+CHR*(O))

510 GET#15,B* 520 GET#15,H*

530 H=ASC(H*+CHR*(O))

169

-----------------------------------------------------Page 169-----------------------------------------------------
﻿
540 C=L+(H*256)

550 S=PEEK(252)+((PEEK(253)-16)*256) 560 B=INT((S/254)+.5) 570 IFC-B>=0G0T0600

580 PRINT"{DOWN}72,DISK FULL,00,00"

590 G0T0710 600 RW*="W" 610 G0SUB890 620 SYS49182 630 CL0SE2

640 INPUT#15,EN*,EM*,ET*,ES*

650 PRINT"{DOWN}bONE!"

660 CLOSE15

670 P0KE56,160

680 CLR 690 END

700 REM CLOSE 710 CL0SE15

720 PRINT"{DOWN}{RVS}FAILED{ROFF}" 730 G0T0670

740 REM DELAY

750 PRINT"{DOWN}PRESS {RVS}RETURN{ROFF} TO CONTINUE"

760 GETC*:IFC*=""THEN760 770 IFC*OCHR*(13)G0T0760 780 PRINT"OK" 790 RETURN

800 REM INITIALIZATION

810 0PEN15,8,15

820 PRINT#15,"10"

830 INPUT#15,EN*,EM*,ET*,ES*

840 IFEN*="00"THENRETURN

850 PRINT"{DOWN}"EN*", "EM*","ET*","ES*

860 CLOSE15 870 G0T0670

880 REM FILE NOT FOUND - FILE EXISTS

890 0PEN2,8,2,"O:"+F*+","+T*+","+RW* 900 INPUT#15,EN*,EM*,ET*,ES*

910 IFEN*="00"THENRETURN 920 CL0SE2

930 PRINT"{DOWN}"EN*", "EM*","ET*","ES*

940 PRINT"{DOWN}{RVS}FAILED{ROFF}"

950 INPUT#15,EN*,EM*,ET*,ES*

960 CLOSE15 970 G0T0670

980 REM LOAD - SAVE

990 DATA162, 2, 32,198,255.160, O, 32 1000 DATA228,255,145,251, 32,183,255, 41

1010 DATA 64,208, 8,200,208,241,230,252

170

-----------------------------------------------------Page 170-----------------------------------------------------
﻿
1020 DATA 76, 5,192,132,251, 32,204,255

1030 DATA 96,162, 2, 32,201

255,160,

1040 DATA177,253, 32,210,255,196,251,240

1050 DATA 3,200,208,244,230,254, 76, 38

1060 DATA192,165,254,197,252,208,242,132

1070 DATA253, 32,204,255, 96,234,234,234

COPY A FILE SOURCE LISTING

100 110 120 130 140 150 160 170 180 190 200 210 220 230 240 250 260 270 280 290 300 310 320 330 340 350 360 370 380 390 400 410 420 430 440 450
 REM COPY.PAL REM

0PEN2,S,2,"@0:i

REM

SYS40960 ?

.OPT P,02

5

*= *cooo

>

; LOAD

5

LDX #*02

JSR *FFC6

»

LOAD LDY #*00 READ JSR *FFE4

STA (*FB),Y

JSR *FFB7 AND #64

BNE READY

I NY

BNE READ

INC *FC

JMP LOAD

5

READY STY *FB JSR *FFCC RTS

>

; SAVE

?

LDX #*02

JSR *FFC9

>

SAVE LDY #*00

; 0PEN2,8,2

; IN

; READST

close:

J 0PEN2,8,2

171

-----------------------------------------------------Page 171-----------------------------------------------------
﻿
460 WRITE LDA (*FD),Y

470 JSR *FFD2 ; OUT 480 CPY *FB

490 BEQ BREAK 500 CONT INY 510 BNE WRITE 520 INC *FE 530 JMP SAVE 540 ;

550 BREAK LDA *FE 560 CMP *FC 570 BNE CONT 580 ;

590 STY *FD

600 JSR *FFCC ; CL0SE2 610 RTS

Copy a File Source Annotation

This routine emulates a LOAD and SAVE from machine language.

Conclusion

In conclusion, we hope that this chapter has taken some of the mystery out of DOS pro¬ tection schemes. We encourage serious readers to study the program listings carefully. The programming techniques employed are perhaps the most sophisticated applications of Commodore's direct-access commands that you will ever see.

172

-----------------------------------------------------Page 172-----------------------------------------------------
﻿
CHAPTER 8

GETTING OUT OF TROUBLE

The best way to get out of trouble is to stay out of trouble in the first place! It is much easier to recover a lost file by digging out an archival copy than trying to recover it from a blown diskette. Need we remind you? BACKUP! BACKUP! BACKUP!

However, since we feel that Murphy was a rash optimist, the likelihood of you always finding that backup copy is minimal, unless of course, you manage to recover that file on the diskette. Then, and only then, will the archival copy magically appear right where you thought you left it.

Since you are reading this chapter, you probably have a problem and are in desperate need of help. Please read on.

8.1 Unscratching a File

Inadvertently scratching a file is by far the most common problem. As long as you have not written any new information to the diskette since you scratched that file, it can be recovered. Recall that when a file is scratched, it is not erased from the diskette. Only two things have happened:

1. The file-type byte in the directory entry is set to $00.

2. The sectors associated with that file are freed in the BAM.

To unscratch a file, all you have to do is change the file-type byte back to its original

value and VALIDATE the diskette to re-allocate the sectors.

The programs VIRTUAL DIRECTORY and EDIT TRACK & SECTOR, which are listed in Appendix C, help you to do this. Here's how you should use these programs

to recover a scratched file.

STEP 1. Load and run the VIRTUAL DIRECTORY program on the diskette. The direc¬

tory will be displayed in groups of eight entries. Scratched files are highlighted in reverse video. Each group constitutes a different sector on track 18. Count the groups to determine which group the scratched entry is in. Note not only which group the scratched entry is in, but also whether it is in the first half or the last half of the group. (One of the first four file entries or one of the

last four.)

Consult the table below to determine the number of the sector containing the entry.

173

-----------------------------------------------------Page 173-----------------------------------------------------
﻿
Group - Sector

1 - 18,1 2 - 18,4 3 - 18,7

4 - 18,10 5 - 18,13 6 - 18,16

Group - Sector

7 - 18,2 8 - 18,5 9 - 18,8

10 - 18,11 11 - 18,14 12 - 18,17

Group - Sector

13 - 18,3 14 - 18,6 15 - 18,9

16 - 18,12 17 - 18,15 18 - 18,18

STEP 2. Load and run the EDIT TRACK & SECTOR program on the diskette with

the scratched file. When asked for the track and sector, enter track 18 and the sector number you read from the table. When prompted for the starting byte, enter 00 if the scratched file entry was one of the first four files in the group. Enter an 80 if the scratched file was displayed among the last four in the group.

STEP 3. When the hex dump of the half-sector is displayed, cursor over to the third

column of hexadecimal numbers on the display. Next locate the name of the file in the ASCII display on the right-hand side of the screen. Move the cur¬ sor down until it is on the same line as the start of the file name. If you have done things correctly you should be on a row labeled with a $00, $20, $40, $60, $80, $A0, $C0, or $E0. The byte under the cursor should be a 00. This is the file-type byte. The 00 indicates a scratched file. Type over the 00 value with the value that corresponds to the correct file type as indicated below.

File Type

PRG

SEQ

REL USR DEL

Value

82 81 84 83 80

STEP 4. Hold down the SHIFT key and press the CLR/HOME key. This will terminate

the edit mode. When asked whether to rewrite this track and sector, press

Y and the modified sector will be written to the diskette in a few seconds.

STEP 5. Load and list the directory to see if the file name now appears. If it does not,

you made a mistake and things may have gone from bad to worse. Hopefully,

the file will be listed.

STEP 6. VALIDATE the diskette by entering in direct mode:

OPEN 15,8,15,"VO":CLOSE15

If the drive stops and the error light is not flashing, everything has gone according to plan and the file has been recovered successfully. (If the VALIDATE command failed,

see sections 8.2 and 8.3.)

174

-----------------------------------------------------Page 174-----------------------------------------------------
﻿
NOTE: It is a good idea to practice these steps on a test diskette before you attempt to recover your lost Accounts Receivable! To do this: SAVE a file to disk, SCRATCH it, and follow the steps outlined above.

8.2 Recovering a Soft Error

In Chapter 7 we described in detail the read/write DOS errors. We did not, however, categorize these errors by type. Read/write errors fall into two categories: "hard" er¬ rors and "soft" errors. A hard error is one that cannot be recovered, period. Hard er¬

rors are errors that occur in a header block. Recall that a header block is never rewrit¬

ten after initial formatting. Since a header block cannot be rewritten, the data in a sec¬ tor containing a hard error is unrecoverable. (Unfortunately, this also means that the forward pointer has been lost and, for all intents and purposes, the remainder of the file as well.) Soft errors are errors that occur in a data block. Since data blocks can be rewritten, soft errors can sometimes be recovered if the diskette itself is not flawed or physically damaged. The table below indicates whether a read/write error is a hard

or soft error.

Soft Errors Hard Errors

22 Read Error 20 Read Error 23 Read Error 21 Read Error

27 Read Error 29 Read Error

Appendix C contains two programs that are useful in trying to recover a sector that has a soft error. However, recovery cannot be guaranteed in all cases. These two pro¬ grams are RECOVER TRACK & SECTOR and LAZARUS. The first program attempts to rewrite a damaged sector. LAZARUS will attempt to resurrect an entire diskette. The latter program returns a status report of the number of read errors encountered. It also reports the number of write errors that occurred. A write error indicates that a soft error encountered along the way was actually a hard error in disguise. Sorry about

that.

8.3 Recovering a Hard Error

A hard error does not necessarily mean that an entire file is unrecoverable. In all honesty, though, the technique that we are about to describe is a shot in the dark. Before you attempt the steps outlined below ask yourself the following question. Are you experien¬ cing errors on other diskettes in your library? If you answered yes to this question, the cause of these errors may be in the disk drive itself. Your 1541 may be out of align¬ ment and a trip to your nearest Commodore dealer is in order. If the problem occurs on only one diskette read on.

NOTE: This section does not apply to relative files. Refer to section 8.4 instead.

WARNING: The technique we are about to describe here is not for the faint-hearted. Consult with your physician before attempting this exercise.

175

-----------------------------------------------------Page 175-----------------------------------------------------
﻿
STEP 1. Load and run the VALIDATE A DISKETTE program contained in Appen¬

dix C. This program emulates the VALIDATE command from BASIC. It will chain through each active file entry in the directory and highlight a bad file without aborting.

STEP 2. Load and run FIND A FILE. This program will return the track and sector

locations of where the file resides in the directory as well as where it starts on the diskette. The directory track and sector is extraneous information for our present purpose. Note only the starting track and sector.

STEP 3. Load and run DISPLAY A CHAIN. This program requires you to input a

track and sector. Input the starting track and sector obtained in step 2. The program will chain through all forward track and sectors on the diskette from this entry point until an error is encountered. (If the error is a soft error, STOP! Do not pass GO. Go directly to section 8.2.) Ignore the sector where the error was encountered. The file is virtually lost from that point on. (Recall that the link has been destroyed.) Make note of the last successful track and sector displayed.

STEP 4. Load and run EDIT TRACK & SECTOR. You will want to input the track

and sector obtained in step 3. The starting byte is always 00. Change the first two bytes to 00 and FF, respectively. Rewrite the sector when prompted to

do so. You have in effect severed the forward track and sector link described

in Chapter 4. This allows you to manipulate the front end of the file. It is the only portion of the file that is clearly intact.

If it is a BASIC PRG file, the internal BASIC links have been destroyed. You can restore the links on the C64 with a machine language monitor or on the diskette with the EDIT TRACK & SECTOR program. If you do not restore the BASIC links, the C64 will crash as soon as you attempt to edit the last line of the program. Using EDIT TRACK & SECTOR, call up the sector that was just rewritten. You will have to inspect both half- pages of the block. Look for the last 00 byte in the page. Change the two bytes that immediately follow it to a 00 00 also. Note the position of the last 00 byte edited in hex¬ adecimal. If you are in the second-half of the block, rewrite the sector and then recall the first-half. Change the forward sector pointer to the hexadecimal position of the last 00 byte you changed. Rewrite the sector a final time. You will now be able to load, list, and edit the program. Hopefully, you will remember to save it to a different diskette

this time.

If it was a SEQ file, the recovered data is intact. You will have to read it into C64 RAM and rewrite it to another file. If you do not know how to manipulate a sequential file

contact someone who does.

8.4 Recovering a Relative File

The only realistic way to recover a REL file is to open it for a read and copy it record by record into a sequential file. The program to do this should not abort when an error is encountered. Simply skip over the record and go on. This way only the records that reside, in whole or in part, on the damaged sector are not recovered. If you do not know how to do this, take your diskette to an experienced programmer and see if he/she can assist you.

176

-----------------------------------------------------Page 176-----------------------------------------------------
﻿
8.5 Recovering an Entire Diskette

NOTE: This section applies only to a diskette that cannot be initialized.

Chapter 7 contains a program called 1541 BACKUP (section 7.15). Run this program to make a backup of your blown diskette. After you have made a backup, load and list the directory. If the directory appears normal, you will want to validate the backup. If the validate command fails, inspect and copy each intact file to a new diskette. Some files may be lost in the process.

If the directory cannot be displayed in its entirety, a hard error was encountered on track 18 during the backup operation. The sector containing the hard error could not be copied. As a result, the directory on the backup is corrupt. Load and run DISPLAY A CHAIN on the backup. Attempt to follow the chain starting at track 18, sector 1. The display will indicate the location of the uncopyable sector by aborting. Run EDIT TRACK & SECTOR on the backup to relink the directory around this sector. Refer to the table in section 8.1 to determine which sector normally follows the one in ques¬ tion. Keep in mind that eight files will be lost by this action. If all goes well you should be able to list the directory now. Inspect and copy all remaining files to a new diskette.

8.6 Recovering a Physically Damaged Diskette

If your diskette has sustained physical damage all is not lost. The most common forms of physical damage are a warped jacket or environmental contamination. In either case, the solution is to don a pair of plastic gloves, carefully slit open the protective jacket, remove the plastic disk, wash it if necessary, and insert it into another jacket. Obtain¬ ing a new jacket may mean destroying a perfectly good diskette, though. NOTE: Some brands of head cleaners come with a reusable jacket that is just right for this job.

Be sure to keep your fingers off the recording surface at all times! Handle the plastic disk only by the edges or the central hub ring. Also make a mental note as to which side faces up. (The reinforcing ring is usually affixed to this side.)

If the plastic disk is gummy, you will want to wash it carefully. Use a small amount of photographer's wetting agent to keep the water from leaving a residue. Allow the plastic disk to air dry.

Once you have inserted the plastic disk inside a new jacket, attempt to initialize it. If you cannot initialize it, try turning the diskette over. You may have the wrong side up.

If the diskette can be initialized, make a backup NOW!

8.7 Recovering an Unclosed File

An unclosed file is one whose file type is preceded by an asterisk in a directory listing (e.g., *SEQ, *PRG). Such files cannot be read normally. However, there is an un¬ documented read mode that will allow you to read an unclosed file. This is the M mode. The M stands for MODIFY. The way to open a file for a read normally looks like this:

177

-----------------------------------------------------Page 177-----------------------------------------------------
﻿
SYNTAX:

OPEN 2, 8, 2, "-file name,S,R" (SEQ file) OPEN 2, 8, 2, "file name,P,R" (PRG file)

To read an unclosed file substitute, an M for the R in the OPEN statement like this:

SYNTAX:

OPEN 2,

OPEN 2,

8, 8,

2,

2,

"file name,S,M" (SEQ file) "file name,P,M" (PRG file)

The file can now be read into the C64 and stored in RAM. There is one problem, though. You will have to display the incoming data bytes because an EOI will not be returned by the disk drive. Note that the last sector written to the diskette will contain an er¬ roneous forward track and sector pointer. As a result, there is no realistic way to deter¬ mine when you have read beyond the actual contents of the unclosed file itself. Watch the incoming data bytes carefully. Your read program should have an embedded break¬ point. When you think you've captured all of the data bytes, rewrite them to another

diskette.

Once you have the data safely stored on another diskette, use the techniques described

at the end of Section 8.3 to restore the internal BASIC links if it was a PRG file.

Don't forget to VALIDATE the diskette which has the unclosed file in the directory while you're at it. Recall that scratching an unclosed file poisons the BAM.

8.8 Recovering from a Short New

If you have inadvertently performed a short NEW on a diskette, there is more hope than you think. Recall that a short NEW only zeros out the BAM and sector 1 from track 18. Run the EDIT TRACK & SECTOR program on the diskette in question. Call up track 18, sector 1 and change the forward track and sector pointer from a 00, FF to a 12, 04.

Next, load and list the directory. If your diskette contained more than eight active files, all but the first eight files will be displayed on the screen. (The first eight files have been lost for now.) Do not attempt to VALIDATE the diskette because the directory sectors will not be reallocated. Copy all of the remaining files onto a new diskette.

If the first eight files are very important, you can attempt to recover them as well. However, it will not be easy! You must find the starting track and sector locations of these files yourself through a process of elimination. Begin by making a grid with a space

for each sector on the diskette like this:

178

-----------------------------------------------------Page 178-----------------------------------------------------
﻿
TRACK

12 3 4 5 6 7

SECTOR

0

1

2

3

:>

Next, VALIDATE the original diskette and then load and run the program DISPLAY A BLOCK AVAILABILITY MAP listed in Appendix C. Working from the display on the CRT, indicate on your chart which sectors are in use by other files. Once you have done this, you should see a blank area centered around track 18. This is where you lost

files reside.

Now, load and run the DISPLAY A CHAIN program. The first file probably starts on track 17, sector 0. Record the chain displayed to the screen on your chart. Once you have recorded the first chain, begin looking for the next one. It probably begins on an open space on track 17 or, if the first chain was a long one, on track 19, sector 0. Work outward from track 18 until you have located all eight missing files.

Once you have the starting track and sector locations for the files, use the EDIT TRACK & SECTOR program to reconstruct track 18, sector 1. The tables and hex dumps from Chapter 4 can be used as a guide. Be sure to substitute the starting track and sector locations that you found and not the ones in this manual.

Now copy the eight files onto another disk. Once this is done, take a break and meditate on the virtues of archival backups!

8.9 Recovering from a Full New

If you are reading this section in desperation, relax. It is already too late. However, if it dawns on you in the future that you are holding a blank diskette in your hand while the master that you were going to backup is being reformatted, don't PANIC! Attempt to regain your composure and pop the drive door open. At this point you don't care what the 1541 User's Manual says about opening the drive door when the red activity indicator is on. You are losing one full track every time you hear the stepper motor click.

Next attempt to make a backup copy of the diskette using the 1541 BACKUP program listed on page 162. (Please, try to remember which diskette you want to format this time.) Recall that formatting works from the outermost track (track 1) to the innermost

179

-----------------------------------------------------Page 179-----------------------------------------------------
﻿
track (track 35). If you threw the door in time track 18 will still be intact and so will most of your files. The DOS works outwards from track 18 when writing to a diskette. The outermost tracks were probably never in use.

Now load and run the VALIDATE A DISKETTE program to assess the damage. Often¬

times all files are recovered.

Conclusion

In short, recovering a damaged diskette is more art than science. The utilities that we have presented here can prove invaluable in time of need. When all is said and done, however, it is much easier to create errors than to pick up the pieces afterward.

180

-----------------------------------------------------Page 180-----------------------------------------------------
﻿
CHAPTER 9

OVERVIEW OF THE 1541 DOS

9.1 Introduction to 1541 DOS

Recall that in Chapter 2 we stated that the 1541 is an intelligent peripheral. It contains its own 6502 microprocessor, 2K of RAM, I/O chips, and the DOS program which is per¬ manently stored in 15.8K ofROM. The diagram below illustrates how the RAM, ROM,

and I/O chips are arranged.

$0000

$0100

2K of RAM

Job queue, constants, pointers & work area

$1800

$180F

Input-Output Chips

6522 VIA CHIP

Main I/O to computer

Stacks, work areas

$0200

$0300

and overflow buffer

Command buffer & work

$1C00

$1C0F

6522 VIA CHIP Main I/O to disk

Data buffer #0

$0400

Data buffer #1

$0500

$0600

$0700

$0800

Data buffer #2

Data buffer #3

Buffer for BAM

$C100

$F259

$FFFF

DOS in 15.8K of ROM

Communications and

file management

Disk controller

routines

9.2 The Hard Working 6502

The 1541 disk drive is a new addition to Commodore's line of disk drives. Commodore's

earlier drives, the 2040, 4040, 8050 and 8250 had three microprocessors: a 6502 to han¬ dle communications with the computer, a 6504 to act as a disk controller, and a 6532 to translate between normal 8-bit characters and the 10-bit GCR code that is actually written on the diskette. The 1541 has only one 6502 to do everything.

181

-----------------------------------------------------Page 181-----------------------------------------------------
﻿
The 6502 in the 1541 alternates between two modes of operation: Interface Processor (IP) mode and Floppy Disk Controller (FDC) mode. The 6502 switches to its FDC mode approximately every 10 milliseconds. The switch is made in response to an interrupt (IRQ) generated by one of the 6522 timers. The main IRQ handling routine checks to see if the IRQ was generated by the timer. If it was, the 6502 begins to execute the FDC routines. Once in FDC mode the interrupt signal is disabled and the 6502 remains in FDC mode until any jobs it has to do are completed. If the interrupt signal was not disabled, it might disrupt a read or write job.

9.3 Major IP Routines

One of the difficulties in using the detailed ROM maps in Appendix B is locating the routine you want. This section summarizes the major IP routines and their entry points to help you find your way around.

a) Initialization

When the disk drive is first switched on, the RESET line is held low. This causes the 6502 to do an indirect JMP via the vector at $FFFC to the initialization procedure at $EAA0. The main features of the initialization process are shown below.

OVERVIEW OF INITIALIZATION

$EAA0

$EAC9

$EAF0

$EB22

$EB4B

$EB87

$EBC2

$EBDA

Test zero page RAM

Do checksum test of ROM's

Test remainder of RAM

Initialize I/O chips

Set up buffer tables

Set up buffer pointers

JSR to inititialize FDC

Initialize serial bus

b) Main IP Idle Loop

Whenever the drive is inactive and the 6502 is in IP mode, the 6502 executes the code from $EBE7 to $EC9D looking for something to do.

182

-----------------------------------------------------Page 182-----------------------------------------------------
﻿
OVERVIEW OF IP MODE IDLE LOOP ($EBE7-$EC9D)

Is the command-waiting

flag ($0255) set?

No

Is the attention pending

flag ($0255) set?

No

Is there a file open?

No

Is the error flag set?

Yes

Yes

Yes

Yes

Parse and execute

the waiting command JSR PARSXQ ($C146)

Service the

attention request

JSR ATNSRV ($E85B)

Turn on the

drive active LED

Flash the

drive active LED

No

JMP to start of loop

c) Computer—Disk Drive Communications

The routines that handle communication on the serial bus are localized in one small area

of ROM, from $E853 to $EA6E. The entry points for the major routines are summariz¬

ed below.

Entry

$E853

$E85B $E909 $E9C9 $EA2E

Routine

ATNIRQ

ATNSRV TALK

ACPTR LISTEN

Function

An IRQ is generated when the computer sets the

ATN line of the serial bus low. Branch to here from

IRQ handler to set attention pending flag. Service an ATN signal on the serial bus

Send data out on the serial bus

Accept one byte of data from the serial bus Accept incoming data bytes from the serial bus

d) Execution of Disk Commands

When the computer sends the 1541 a disk command, such as NEW, VERIFY, or SCRATCH, the command is stored temporarily in the command buffer ($0200-$0229) and the command pending flag ($0255) is set. The next time the 6502 works its way though the IP idle loop ($EBE7-$EC9D) it finds that the command pending flag has been set. It then does a JSR to the PARSXQ routine ($C146) to parse and execute the command. The parser first checks the command table ($FE89-94) to see if this is a valid command. Next it checks the syntax of the command. If the command is correct, a JMP is made

183

-----------------------------------------------------Page 183-----------------------------------------------------
﻿
to the appropriate ROM routine. The table below summarizes the various disk commands and their entry points.

Entry $ED84 $D005 $C8C1 $CAF8

V

I

D M

Command

VALIDATE INITIALIZE DUPLICATE MEMORY-OP

Effect

Create a new BAM based on the directory. Initialize BAM by reading from disk. Make a backup of a disk (not on 1541). Perform a memory operation (M-R, M-W,

M-E).

$CC1B

B

BLOCK-OP
 Perform a block operation (B-P, B-A, B-F,

etc.).

$CB5C $E207 $E7A3 $C8F0 $CA88 $C823

$EE0D

U P & c R S

N

USER JMP POSITION UTIL LDR COPY

RENAME SCRATCH NEW

Execute user routines (UO, Ul, U2, etc.).

Position to record in relative file.

Load routine in disk RAM and execute it.

Copy a file (single disk only on 1541). Rename a file in the disk directory. Scratch a file in the directory.

Format a diskette (short and full).

For more details on these routines see Appendix B.

If no errors are encountered during the execution of a command, the routine is terminated with a JMP to the ENDCMD ($C194). If errors are encountered, A is loaded with an error code, and the routine is aborted with a JMP to the command level error process¬ ing routine at $E645.

e) File Management

File management is a major function of the interface processor. As a result, there are many ROM routines that deal directly or indirectly with the management of files, the directory and the BAM. A few of the major entry points are summarized below.

Entry

$C5AC $CBB4 $CE0E $D156

$D19D $D50E $D6E4 $D7B4 $DAC0 $DBA5 $DC46

Routine

SRCHST OPNBLK FNDREL RDBYT

WRTBYT SETJOB ADDFIL OPEN

CLOSE

CLSDIR

OPNRCH

Function of File Management Routine

Search directory for valid or deleted entry.

OPEN a direct access buffer. Find a record in a relative file.

Read byte from a file. Get next sector if

needed.

Write byte to file. Write sector if full. Set up read or write job for FDC. Add a file to the directory.

OPEN a channel for read, write, load, or save. Close the file associated with given channels. Close directory entry for a write file. OPEN a channel to read using double buffering.

184

-----------------------------------------------------Page 184-----------------------------------------------------
﻿
$DCDA

$DFDO $E31F $E44E $E4FC $E645

$EA6E $EAA8 $EC9E $EF5C $EF90 $F11E

OPNWCH

NXTREC ADDREL NEWSS

ERRTAB CMDER2 PEZRO

DSKINT STDIR

WFREE WUSED NXTTS

OPEN a channel to write using double buffering.

Set up next record for a relative file.

Add a new sector to a relative file. Add new side sectors to relative file.

IP mode error message table.

IP mode error handler.

Display error diagnostics by flashing LED.

Initialize IP side of disk.

Convert directory to pseudo program and load. Mark given sector as free in the BAM. Mark given sector as in use in the BAM.

Finds next available sector from the BAM.

9.4 Using the IP Routines

The interface processor routines in the 1541's ROM are relatively easy to use. They can be executed by using the command channel to send the disk drive the appropriate memory-execute (M-E) command.

Before you try to use one of the IP routines you should:

1. Use the ROM maps in this chapter to locate a routine.

2. Use the tools given in Section 9.13 to make a copy of that area of ROM.

3. Disassemble the routine.

4. Study the disassembly (use the ROM analysis in Appendix B as a guide) to deter¬

mine any setup that is necessary.

NOTE: You cannot use the memory-execute (M-E) technique described in this section when you are using any routine that involves reading from or writing to a diskette. The reason for this restriction is that memory-execute commands are carried out while the processor is in the IP mode. In this mode, the processor is interrupted every 10 milliseconds by an IRQ and switches into FDC mode. Any read or write operation will be interrupted if this occurs. See Section 9.6 for the technique to use if you want to

use a routine that reads from or writes to the diskette.

Once you are sure that the routine performs the operation you want and what setup is needed, you are ready to design your program. Your program will normally have three parts:

1. A Setup Section

This section normally consists of one or more memory-write (M-W) commands to poke any required setup values into the 1541's RAM memory.

2. A Section to Execute the Routine

This section normally consists of one memory-execute (M-E) command to force the 1541's microprocessor to execute the ROM routine.

185

-----------------------------------------------------Page 185-----------------------------------------------------
﻿
3. An Information Retrieval Section

This section normally consists of one or more memory-read (M-R) commands to peek the results of the routine out of the 1541's RAM for use by your program.

Let's take a look at a typical application of this technique.

Suppose we were writing a data base management program. One thing we would like to build into our program is a check to be sure that we can never produce an unclosed file (*SEQ). This would happen if the user entered too much data and completely filled the disk. We can't rely on checking the drive's error channel in this situation because the DOS sends the disk full error too late; the damage is already done. We are going to have to have some independent method of finding the number of blocks free on the

diskette before we write out the file.

Since we know that a directory listing shows the number of blocks free, we'll start by looking for some routines that deal with the directory. The chart of ROM routines that deal with file management in Section 9.3 (e) has one entry that looks promising: STDIR ($EC9E), convert directory to pseudo program and load. We now turn to Appendix B and look up this routine. Scanning through this routine doesn't turn up an algorithm that appears to calculate the number of blocks free and we're back to square one. What

about the initialize routine? From the chart on the execution of disk commands in Sec¬

tion 9.3 (d) we find that this routine starts at $D005. Back to Appendix B. Eureka! At $D075 we find the routine NFCALC. A bit of disassembly indicates that this routine probably needs very little setup to calculate the number of blocks free and that it stores the lo-byte of the count in NDBL ($02FA) and the hi-byte in NDBH ($02FC). Before we set up an elaborate program, let's check out these RAM locations using a test pro¬ gram like this:

10 OPEN 15,8,15,"I"

20 SOSUB 120IREM CHECK DISK STATUS

30 OPEN 1,8,5,"@0:TEST FILE,S,W"

40 GOSUB 120:REM CHECK DISK STATUS 50 FOR K=l TO 300

60 PRINT#1,"THIS IS TEST RECORD NUMBER";

K

70 PRINT K;:GOSUB 170:REM CHECK BLOCKS F REE

80 NEXT

90 CLOSE l:CL0SE15:END 100 :

110 REM SUB TO CHECK DISK STATUS

120 INPUT E,E*,T,S 130 PRINT E;E*;T;S

140 RETURN ISO :

160 REM SUB TO READ BLOCKS FREE

170 PRINT#15,"M-R"CHR*(250)CHR* < 2)CHR*(3

)

180 GET#15,X*:NL=ASC(X*+CHR*(0))

186

-----------------------------------------------------Page 186-----------------------------------------------------
﻿
190 GET#15,X*:REM JUNK

200 GET#15,X*:NH=ASC<X*+CHR*(0))

210 PRINT "BLOCKS FREE=" 256*NH+NL 220 RETURN

After trying our test program, we find our problem is solved. As we write out our records the DOS automatically updates the count in NDBL and NDBH to reflect the number of blocks left. We don't really need to execute a ROM routine after all. A memory-read command is all we need. The moral? A bit of time spent studying and testing can really simplify your life.

Since the "blocks free" example really didn't illustrate the use of an IP routine, let's try again. This time we are interested in converting normal bytes into their GCR equivalents to see what is actually written out to the disk. After snooping through the IP tables in Section 9.3 without any luck, we try the FDC tables in Section 9.5. We find what we need in 9.5 (c): PUT4GB ($F6D0), convert four data bytes into five GCR bytes. In checking Appendix B we find that, although this is nominally an FDC routine, it does not involve reading from, or writing to, a diskette. This means we can use the memory-execute technique.

After a bit of disassembly we know what set-up is required:

1. The routine expects to find four normal bytes stored in RAM from $52-$55.

2. The pointer at $30/31 should point to the start of where the five GCR bytes that result

from the conversion are to be stored. We'll use $0300-$0304.

3. The GCR pointer at $34 should be $00.

4. The entry point for the routine is definitely $F6D0.

Now that we know what we have to do, let's set up the program.

First, we'll start by inputting the four bytes we want to convert and storing them in disk RAM from $52 (82) to $55 (85) using a memory-write command (M-W). Second, we will use memory-write (M-W) commands to set the pointers at $30 (to 0), $31 (to 3), and $34 (to 0). Third, we'll execute the routine using a memory-execute (M-E) command. Finally, we will peek the results from $0300-4 of the disk RAM using a memory-read (M-R) command and five GET# statements. Here's what the program looks like:

100 REM CONVERT BINARY TO GCR

110 PRINT"<CLRJENTER FOUR BYTES (DECIMAL )<DOWN>"

120 B*(O)="0":B*(1)="1":F0RK=0T07:P(K)=2

~k:next

130 F0RK=0T07:P(K)=2'N<:NEXT

140 OPEN 15,8,15

150 :

160 REM INPUT BYTES & STORE IN DISK RAM (*52/5)

170 FOR K=0T03

180 PRINT"BYTE#"K"=";:INPUT X

187

-----------------------------------------------------Page 187-----------------------------------------------------
﻿
190 IF X<0 OR X>255 GOTO 180 200 PRINT"<UP>"TAB(18);:G0SUB430

210 PRINT#15,"M-W"CHR*<82+K)CHR*(0)CHR*<

1)CHR*(X) 220 NEXT 230 :

240 REM SET UP POINTER TO STORAGE AREA ( *30/31)

250 PRINT#15,"M-W"CHR*(48)CHR*(O)CHR*(2)

CHR*(O)CHR*(3) 260 :

270 REM SET UP GCR POINTER (*34)

280 PRINT#15,"M-W"CHR*(52)CHR*(0)CHR*(1)

CHR*(0) 290 :

300 REM EXECUTE PUT4GB (*F6D0) IPC ROUTI NE

310 PRINT#15,"M-E"CHR*(208)CHR*(246)

320 :

330 REM PEEK OUT AND DISPLAY RESULTS

340 PRINT#15,"M-R"CHR*(00)CHR*(3)CHR*(5>

350 PRINT"CDOWN>THE FIVE EQUIVALENT GCR BYTES ARE:{DOWN>" 360 FOR K=l TO 5

370 GET#15,X*:X=ASC(X*+CHR*(0))

380 PRINT"BYTE#"K"="X;TAB(18);:G0SUB430 390 NEXT

400 CLOSE 15:END 410 :

420 SUB TO DISPLAY BINARY EQUIVALENTS 430 PRINT"7.";

440 FOR L=7T00STEP-1 450 T=INT(X/2~L) 460 X=X-T*P(L) 470 PRINTB*(T);

480 NEXT:PRINT:RETURN

Many of the other IP ROM routines are just as easy to use. However, be careful because some are tricky. Some expect to find a particular command in the command buffer. These are tough to use because the memory-execute command will wipe out any set-up you have done in the command buffer area. In these cases you will have to store a short machine language routine in the disk RAM that sets up the proper command in the buf¬ fer before it JMP's to the IP routine. When you execute the routine, it should overwrite the M-E command in the buffer with the command you want there. Happy sleuthing!

9.5 Major FDC Routines

One of the difficulties in finding an FDC routine to do the job you want is finding your

188

-----------------------------------------------------Page 188-----------------------------------------------------
﻿
way through the detailed ROM maps in Appendix B. This section summarizes the ma¬ jor FDC routines and their entry points.

a) Initialization

When the disk drive is first switched on, the reset line is pulsed lo. This causes the 6502 to RESET and it does an indirect JMP via the vector at $FFFC to the initialization procedure at $EAA0. As part of the set up procedure, the variables and I/O chips for the FDC are initialized by the CNTINT routine ($F259-AF).

b) Main FDC Idle Loop

Every 10 milliseconds the 6522 timer generates an interrupt (IRQ) and the 6502 begins to execute the main FDC loop looking for something to do. The main features of this loop are summarized below.

OVERVIEW OF MAIN FDC LOOP ($F2B0)

Any jobs in job queue?

No

JMP to
 END

Yes

Is it a JMP job ($D0)?

No

Should drive motor be ON?

Yes

Yes

Do JMP job ($F370)

Motor ON & JMP to

END

No

Is drive up to speed?

No

JMP to
 END

Yes

Is the head stepping?

Yes

*► JMP to

END

No

Is this the right track?

No

Set # of the tracks to the step

END ($F99C)

Change in write protect?

No

Is head between tracks?

7 No

Yes

Yes

Yes

189

*- DO THE JOB

Set the change in status flag ($1C)

Move the head

JMP DOSTEP ($FA2E)

-----------------------------------------------------Page 189-----------------------------------------------------
﻿
i

„.„*— rnriT7»>

iuiii uxive muuui yjv r :

No

Is the head in step mode?

Yes

Yes

Turn OFF motor

JMP to the proper stepping routine

No

RTS to the IRQ routine

At the end of this loop, or when the job has been completed, the timer interrupt is re-

enabled and the 6502 leaves FDC mode.

c) Major FDC Entry Points

When in FDC mode the 6502 executes routines that directly control the operation of the disk drive. These include: turning the drive motor ON or OFF, controlling the step¬ per motor that moves the head from track to track, formatting a blank diskette, locating a specific sector and reading or writing data, and translating information back and forth between normal 8-bit bytes and the 10-bit GCR code that is actually recorded on a diskette's surface. The 6502 carries out these tasks in response to job requests placed in the job queue by the IP processor. The entry points for the major FDC routines are

summarized below.

Entry

$F259 $F2B0

$F367 $F37C $F3B1 $F4CA $F56E $F691

$F6D0 $F78F

$F7E6 $F8E0

$F934 $F99C

$FAC7

Routine

CNTINT LCC

EXE BMP

SEAK REED

WRIGHT VRFY

PUT4GB BINGCR

GET4GB GCRBIN

CONHDR END

FORMT

Function

Initialize important variables and the I/O chips. Main FDC idle loop (IRQ entry every 10

millisec).

Do execute job.

Bump head to track #1 (step out 45 tracks). Seek any header on a track.

Read in data block of specified sector. Write out data block of specified sector.

Read back data block to check for good write. Convert four data bytes into five GCR bytes.

Convert entire data buffer into GCR write

image.

Convert five GCR bytes into four data bytes. Convert GCR image of data block into normal

data.

Convert header into a GCR search image. End of idle loop to control drive & stepper

motor.

Format blank diskette.

190

-----------------------------------------------------Page 190-----------------------------------------------------
﻿
Since the read, write and format routines are of particular interest, let's look at them

in more detail.

d) Read Data Block of Specified Sector

Before the read job code ($80) is placed in the job queue, the IP puts the desired track

and sector numbers into the header table as indicated below.

Job queue

location

$0000 $0001 $0002 $0003 $0004 $0005

#

0 1 2 3 4 5

Use buffer

address

$0300-FF $0400-FF $0500-FF $0600-FF $0700-FF

NO RAM

Track # address

$0006 $0008

$000A $000C $000E $0010

Sector #

address

$0007 $0009 $000B $000D $000F $0011

Once the track and sector values are in place, the IP puts the read job code into the job queue in the location that corresponds to the data buffer where the data is to be stored. The next time the 6502 is in FDC mode it finds the job request. If necessary, it turns on the drive motor, waits for it to get up to speed, and moves the head to the proper track. It then executes the read routine outlined below:

OVERVIEW OF THE FDC READ ROUTINE

$F4D1

$F4D4

$F4ED

$F4F0

$F4FB

$F505

Find correct sector

Read data: first 256 into the data buffer and the rest into the overflow buffer

Convert GCR to normal

Check data block ID

Check data checksum

Exit, read was OK

e) Write Data Block of Specified Sector

Before the write job code ($90) is placed in the job queue, the IP puts the desired track

and sector numbers into the header table as indicated below.

191

-----------------------------------------------------Page 191-----------------------------------------------------
﻿
Job queue

location

$0000 $0001 $0002 $0003 $0004 $0005

#

0 1 2 3 4 5

Use buffer

address

$0300-FF $0400-FF $0500-FF $0600-FF $0700-FF

NO RAM

Track # address

$0006 $0008 $000A $000C $000E $0010

Sector #

address

$0007 $0009 $000B $000D $000F $0011

Once the track and sector values are in place, the IP puts the write job code into the job queue in the location that corresponds to the data buffer containing the data to be written. The next time the 6502 is in FDC mode it finds the job request. If necessary, it turns on the drive motor, waits for it to get up to speed, and moves the head to the proper track. It then executes the write routine outlined below:

OVERVIEW OF THE FDC WRITE ROUTINE

$F575

$F57A

$F586

$F589

$F58C

$F594

$F5B1

$F5BF

$F5CC

$F5D9

$F5DC

$F5E6

Calculate checksum.

Test if write protect on.

Convert buffer to GCR.

Find correct sector.

Wait out header gap.

Switch to write mode and

write out five $FF's as sync.

Write out overflow buffer.

Write out data buffer.

Switch to read mode.

Convert GCR back to 8-bit.

Change job code to VERIFY.

Go back to verify it.

f) Format a Blank Diskette

The IP format routine at $C8C6 sets up a JMP $FAC7 instruction at $0600 and then puts an EXECUTE job code ($E0) into the job queue ($0003). On its next pass through the idle loop the FDC finds the execute job code, executes the code at $0600, and jumps to the formatting routine outlined below.

192

-----------------------------------------------------Page 192-----------------------------------------------------
﻿
OVERVIEW OF THE FDC FORMATTING ROUTINE

$FAC7

$FACB

$FAE3

$FAF5

$FB00

$FB0C

$FB0F

$FB35

$FB7D

$FC36

$FC86

$FC8E

$FC9E

$FCAA

$FD24

$FD8B

$FD96

Check if this is first entry.

If not, branch to $FAF5.

Do bump to track #1 (CLUNK!)

Initialize error count and

bytes around track. Exit.

Check if on right track.

Check for write protect tab.

Erase track with sync.

Write half of track with sync and other half with non-sync.

Time sync & non-sync parts.

Compare times and calculate how long tail gaps should be.

Create images of headers.

Create dummy data block.

Convert headers to GCR.

Convert data block to GCR.

Write out sectors in sequence.

Go to read mode and verify.

All sectors OK; do next track.

All tracks done; exit.

9.6 Using the FDC Routines

Some of the floppy disk controller routines in the 1541's ROM are relatively easy to

use. Others are much more difficult.

The easy ones are those that do not involve reading or writing to a diskette. An exam¬ ple of this type of routine would be the GET4GB ($F7E6) routine that converts 5 GCR bytes into 4 normal 8-bit binary bytes. These routines can be executed by using the techniques described in Section 9.4.

193

-----------------------------------------------------Page 193-----------------------------------------------------
﻿
The tough ones are those that involve reading or writing to a diskette. To illustrate how to do this, we'll try something interesting. How about developing a routine that allows us to move the head anywhere on a diskette (say track 5) and read the next header (or whatever) that passes over the read/write head.

First we have to find out how to move the head around. A quick check of the map of the I/O chips at the end of Appendix A tells us that the stepper motor that moves the head is controlled by bits 0 and 1 of DSKCNT ($1C00). Cycling these two bits causes the head to move. Hmm... Cycling the bits must mean: 00-01-10-11-00 versus 11-10-01-00-11. Time out for a bit of testing. Here's our program:

100 REM MOVE THE 1541'S HEAD

110 PRINT"CCLR>CDOWN>COMMANDS: U=UP D=DO

WN Q=QUIT"

120 OPEN 15,8,15,"I"

130 PRINT#15,"M-R"CHR*(0)CHR*(28) 140 GET#15,X*:X=ASC(X*+CHR*(0))

150 BI=X AND 3

160 PRINT" CHOMEXDOWN 3>BI = "BI 170 GET A*

180 IF A*="U"THEN BI=BI+1 190 IF A*="D"THEN BI=BI-1

200 IF A*="Q"THEN CLOSE 15:END 210 BI=BI AND 3

220 R=(X AND 252)OR Bl

230 PRINT#15,"M-W"CHR*(O)CHR*(28)CHR*(1)

CHR*(R)

240 GOTO 130

After much peeking through the drive door with a flashlight we discover that our pro¬ gram actually does make the head move. When we press "U" the head moves closer to the center (higher track numbers) and when we press "D" the head moves outward (lower track numbers). We've got it! Quick let's write it down before we forget.

To move the head, cycle bits 0 and 1 of $1C00

00 —

0

11 —

3

01 —

1

10 —

2

10 —

2

01 —

1

11 —

3

00 —

0

00

0

11

3

head moves inwards

head moves outwards

The only problem that remains is to find out how much the head moves each time. Hmm ... If we read from a track and then peek at $1C00 . . . Time for more testing:

10 REM CHECK PHASE FOR ALL TRACKS

20 OPEN 15,8,15,"I"

194

-----------------------------------------------------Page 194-----------------------------------------------------
﻿
30 OPEN 1,8,5,"#"

40 FOR TR=1 TO 35

50 PRINT#15,"Ul:5 0"TR;0

60 PRINT#15,"M-R"CHR*(0)CHR*(28) 70 GET#15,X*:X=ASC(X*+CHR*(0)) 80 PRINT TRjX AND 3

90 NEXT

100 CLOSEl:CLOSE15

When we run this test program, we get a very interesting table:

1 8 15 22 29
 0 2 0 2 0
 2 9 16 23 30

2 0 2 0 2

3 10 17 24 31
 0 2 0 2 0

4 11 18 25 32

2 0 2 0 2
 5 12 19 26 33

0 2 0 2 0

6 13 20 27 34
 2 0 2 0 2

7 14 21 28 35

0 2 0 2 0

The phase of the stepper motor is always even (0 or 2) when the head is on a track. Therefore, the head must be moving half a track at a time. Very interesting indeed!

Now that we can move the head around, we want to find out how to read something. But before we go rummaging through the ROM's, wasn't there something about the clock rate being different for each zone? Ah, here it is. Bits 5 and 6 of $1C00 set the recording density. Let's see. Bit 5 represents 32 and bit 6, 64. Let's change one line of our last test program and try again. Here's the new line:

80 PRINT TR;X AND 96

When we run our revised program, we get another interesting table.

1 8 15 22 29

96 96 96 64 32

2 9 16 23 30

96 96 96 64 32
 3 10 17 24 31

96 96 96 64

0

4 11 18 25 32

96 96 64 32

0

5 12 19 26 33
 96 96 64 32

0

6 13 20 27 34
 96 96 64 32

0

7 14 21 28 35

96 96 64 32

0

By George, we've got it.

$1C00

Zone

1 2 3 4

Tracks

1-17 18-24 25-30 31-35

Bit 6

1 1 0 0

Bit 5

1 0 1 0

Number

96 64 32

0

Let's do some digging in those ROM's now. A quick scan through the table of Major FDC Entry Points in Section 9.5 (c) turns up SEAK ($F3B1), seek any header on the track. A check of the detailed analysis in Appendix B looks promising. A careful study of a disassembly of the routine indicates that this is just what we were looking for. And, we don't have to do much setup either. Here's all the information we need:

195

-----------------------------------------------------Page 195-----------------------------------------------------
﻿
1. The entry point is $F3B1.

2. JOB ($45) should be $30 so the branch at $F3E6 is taken.

3. JOBN ($3F) should contain the correct buffer number so the error handler routine at

$F969 works properly.

Now comes the tricky part. Since the routine involves reading from or writing to a diskette, we cannot execute the routine using a memory-execute command. We have to use a two step process:

1. Use a memory-write command to store a machine language routine (it does the set¬ up and then a JMP to $F969) into the start of one of the buffers (we'll use buffer -0 at $0300).

2. Force the 6502, while in FDC mode, to execute our routine by putting a JUMP or EXECUTE job code in the appropriate spot in the job queue (we'll put a JUMP code into $0000).

The program listed below puts it all together for us. It may appear a bit intimidating at first. But, if you are interested in exploring the innards of your drive it is one of the most powerful tools presented in this manual. It allows you to move the head anywhere you want and read the next header passing over the read/write head. The screen display shows you where the head is, what track and sector was read, and describes any read

errors that were encountered.

100 PRINT" iCLRy<.DOWN> MOVE THE 1541'S

READ/WRITE HEAD"

110 PRINT"CDOWN 2>INSERT TEST DISK"

120 PRINT"{DOWN 2>PRESS CRVS>RETURNCROFF > WHEN READY" 130 :

140 REM

HEADER

150 REM 160

MACHINE CODE ROUTINE TO READ A

RESIDES AT *0300 (BUFFER #0)

170 180 190 200 210
 DATA DATA DATA DATA DATA
 169,48: 133,69: 169,00:

1 JO « OO m

76,177,243

:REM :REM :REM :REM :rem

LDA STA LDA STA JMP
 #*30 *45

#*00 *3F

*F3B1

220 230

3)=' 240 250

D*(0)="00":D*(1) 11"

DIM FD*(16) FD*(0)="

■Ol":D*(2)="lO":D*(

260 270 280 290
 FD*(1)="01 FD*(2)="02 FD*(3)="03 FD*(9)="09

ALL OK

HEADER BLOCK NOT FOUND NO SYNC CHARACTER

HEADER BLOCK CHKSUM ER

300

T=ia:Ni*
 '"?"'. N2*= "?" : TR=255

310 320
 GET A*: IF A*OCHR*(13) GOTO 310

196

-----------------------------------------------------Page 196-----------------------------------------------------
﻿
330 OPEN 15,8,15,"I" 340 :

350 REM DIG OUT MASTER DISK ID 360 :

370 PRINT#15,"M-R"CHR*(18)CHR*(0)CHR*(2)

380 GET#15,II*:IFI1*=""THENI1*=CHR*(O)

390 GET*15,I2*:IFI2*=""THENI2*=CHR*(O)

400 :

410 PRINT"{CLR}" 420 :

430 REM READ THE DISK CONTROLLER PORT

440 :

450 PRINT#15,"M-R"CHR*(0)CHR*(28)

460 GET#15,A*:IF A*=""THEN A*=CHR*(0) 470 A=ASC(A*) 480 CV=3 AND A

490 A=(159ANDA)OR(96+32*((T>17)+(T>24)+( T>30)))

500 PRINT*15,"M-W"CHR*(O)CHR*(28)CHR*(1)

CHR*(A OR 4) 510 :

520 REM DISPLAY VALUES 530 :

540 PRINT"{HOME}{DOWN} MOVE THE 1541'S

READ/WRITE HEAD"

550 PRINT"{DOWN*CURRENT PHASE ="CV

560 PRINT"BITS 1 & O OF *1C00 ARE "D*(CV

)

570 PRINT"CD0WN3MASTER DISK ID: "11$;12* 580 PRINT"{DOWN>TRACK # FROM STEPPER:"T"

CLEFT*

590 PRINT"{DOWN*FDC ERROR:"FD*(E)

600 T*=STR*(TR) :S*=STR*(SE) : IF EOI THEN

T$="77M;Nl*="?":N2*="?":S*="??"

610 PRINT"{DOWN}TRACK # AS READ: "RIGHT *(T*.2)

620 PRINT"SECTOR # AS READ: "RIGHT*(S*,2

)

630 PRINT"ID OF TRACK READ: "N1*;N2* 640 PRINT"{DOWN 2}COMMANDS:"

650 PRINT"{DOWN} Fl = MOVE HEAD OUT (LO WER TRACK #)

660 PRINT" F3 = MOVE HEAD IN (HIGHER TR ACK #)

670 PRINT" F5 = ATTEMPT TO READ TRACK #

lc ID"

680 PRINT" F7 = TERMINATE PROGRAM"

690 PRINT" I = INITIALIZE (TO TRACK 18

) "

700 P=PEEK(197)

197

-----------------------------------------------------Page 197-----------------------------------------------------
﻿
710 IF P=3 GOTO 910

720 IF P=4 AND T>1 THEN C=-1:G0T0 800 730 IF P=5 AND T<35 THEN C=1:G0T0 800 740 IF P=6 GOTO 990

750 IF P=33 THEN PRINT#15."I":T=18:E=0:A =214:G0T0480 760 GOTO 450 770 :

780 REM CHANGE PHASE IN RESPONSE TO COMM AND

790 :

800 CV=(CV + OAND3

810 T=T+C*.5:IFT<1 THENT=1 820 IFT>36THENT=36 830 B=A AND 252 840 C=B+CV

850 PRINT*15,"M-W"CHR*(0)CHR*(28)CHR*(1)

CHR*(C) 860 E=0

870 GOTO 450 880 :

890 REM TERMINATE PROGRAM (DRIVE OFF) 900 :

910 PRINT#15,"M-W"CHR*(0)CHR*(28)CHR*(D

CHR*(240)

920 FOR k=itoio:geta*:next 930 CLOSE 15:END 940 :

950 REM ATTEMPT TO READ ANY HEADER 960 :

970 REM READ & SEND MACHINE CODE ROUTINE

980 :

990 RESTORE:C*=""

1000 FOR K=l TO li:READ X:C*=C*+CHR*(X):

NEXT

1010 PRINT*15,"M-W"CHR*(0)CHR*(3)CHR*(11

)C*

1020 :

1030 REM PUT JMP JOB IN THE JOB QUEUE

1040 :

1050 PRINT*15,"M-W"CHR*(0)CHR*(0)CHR*(1)

CHR*(208)

1060 :

1070 REM WAIT FOR JOB TO FINISH 1080 :

1090 PRINT*15,"M-R"CHR*(0)CHR*(O) 1100 GET*15,E*:E=ASC(E*+CHR*(O))

1110 IF E>127 GOTO 790 1120 :

198

-----------------------------------------------------Page 198-----------------------------------------------------
﻿
1130 REM "E" IS FDC ERROR CODE RETURNED 1140 IF EOI GOTO 450 1150 :

1160 REM CLEAN READ SO DIG OUT ID, TRAK

& SECT 1170 :

1180 PRINT#15,"M-R"CHR*(22)CHR*(0)CHR*(4

)

1190 GET*15,N1*

1200 GET*15,N2*

1210 GET*15,X*:TR=ASC(X*+CHR*(0))

1220 GET#15,X*:SE=ASC(X*+CHR*(0))

1230 GOTO 450

Although this program allows you to move the head and read data in half-track in¬ crements, you can't double the capacity of your drive by using all 70 "tracks." The magnetic path produced by the read/write head is just too wide. However, it may be possible to devise a protection scheme in which the "protected information" is recorded when the head is in an "odd phase" (1 or 3). Crosstalk from the two odd-phase tracks, though, would make the diskette unreadable except by a specialized routine like this.

9.7 The Recording Process

A floppy diskette consists of a circular piece of plastic. It is coated on both sides with a thin layer of magnetic particles, usually particles of iron oxide. Each particle is made up of a large number of extremely small atomic magnets called "magnetic domains." When a floppy diskette is new, these magnetic domains are oriented randomly and the surface is unmagnetized.

The record/play head consists of a coil of wire wrapped around a ring of iron or other magnetic material. A small segment of the ring is missing. This is the "gap." The gap is the part that comes in contact with the surface of the diskette. Magnified many times, the head looks something like this:

COIL

RECORD/PLAY

HEAD __

RING OF

MAGNETIC MATERIAL

GAP

199

-----------------------------------------------------Page 199-----------------------------------------------------
﻿
Write Mode:

In write mode an electric current passes through the coil. The current causes the head to become an electromagnet whose strength and polarity depends on the amount and direction of the electric current. The gap in the ring interrupts the magnetic field and causes it to flare outwards. If the gap is in contact with the surface of the floppy diskette, some of the magnetic domains on the surface shift position and line up with the magnetic field of the head. Some of these magnetic domains retain their new orientation even after leaving the vicinity of the gap, i.e., the surface of the diskette has become magnetized.

WRITE MODE

ZZZZ2ZZ2ZZZZZZZZZZZZZZZ2ZZZZZZZZZZ2ZZZZZZ2ZZZZ2Z

The amount and direction of the current flowing through the coil determines the strength and polarity of the electromagnet. The more current, the stronger the electromagnet, and the greater the magnetization of the surface of the diskette. In audio recording, the amount of current flowing through the coil fluctuates to match the changing audio signal. In digital recording, there are only two possible currents, full current in one direc¬

tion or full current in the other direction. When data is recorded onto the surface of

a floppy diskette, the track becomes a series of bar magnets laid end to end.

WRITING DATA

Read mode:

In read mode the moving magnetic areas on the surface of a diskette induce an elec¬ trical voltage in the head. Because of the nature of electromagnetic induction, the maximum induced voltage is NOT produced by the regions where the magnetic field is greatest. The maximum signal occurs where the magnetic fields change most rapidly. The signal from the head must, of course, be amplified and shaped before it is usable.

200

-----------------------------------------------------Page 200-----------------------------------------------------
﻿
Writing data to a diskette:

When data is being recorded onto a floppy diskette, the data is "clocked out" at a fixed rate. This permits an interesting recording scheme. The direction of the current flow¬ ing through the head changes only when a "1" bit is to be recorded. Zeros are represented by the absence of a transition at a particular location. The diagram below represents

what is actually recorded on a diskette.

N

N S

N
 N S

N

N S
 S

1 10 10 0 10 11

Note that the data recorded onto a diskette is not divided into bytes. There is just one continuous stream of bits. In order to know where to begin to read or write bits, we need some special identifying mark. This is the function of the SYNC mark, a string of 10 or more l's in a row. The GCR code (see Chapter 7) is designed so that no combina¬ tion of bytes can produce more than eight "1" bits in a row. This guarantees the unique¬ ness of the sync mark.

The 1541 records between 4000 and 6000 magnetic zones (bits) per inch. Since the diskette rotates at a constant angular velocity (300 rpm), you may wonder how Commodore manages to get more bits on the outer tracks than the inner ones. The 1541 manages this bit of magic by clocking out the data at different rates depending on the track. On the longer outer tracks, the data is clocked out faster than for an inner track (see table in Chapter 3). However, the increase in clock rate is not really proportional to the in¬ crease in track length. This means that the outer tracks have a bit density of only 4300

bits/inch while the inner tracks are recorded at 6000 bits/inch. If the clock were not in¬ creased for the outer tracks, the bit density on the outermost track would fall to about

3500 bits/inch.

Reading data from a diskette:

When data is being read from a floppy diskette, the data is "clocked in" at a fixed rate. A magnetic transition is interpreted as a "1" bit. The lack of a signal when data is ex¬ pected is interpreted as a "0" bit. Since the speed of the drive is not absolutely con¬ stant, we can run into problems if there are too many "0" (no signal) bits in a row. Com¬ modore's GCR code is designed so that no GCR byte, or combination of GCR bytes, ever contains more than two consecutive "0" bits. As a further precaution, the clock is zeroed (cleared) every time a "1" bit is read. This re-synchronizes the clock to the bit stream and prevents small fluctuations in the speed of the drive from causing read

errors.

9.8 Block Diagram of the 1541

This block diagram of the 1541 electronics emphasizes the components involved in reading and writing data.

201

-----------------------------------------------------Page 201-----------------------------------------------------
﻿
1541 BLOCK DIAGRAM

TO R-W HEAD

FROM

• R-W

HEAD

The divide-by-N counter determines the actual rate at which bits are read or written. For tracks 1-17 the clock divisor is 13, for tracks 18-24 it is 14, for tracks 25-30 it is 15,

and for tracks 31-35 it is 16.

9.9 Writing Data to a Diskette

The diagrams below highlight the important components and waveforms involved in the writing of a GCR encoded data byte to disk.

WRITE MODE

C�
 y

P-tS

Shift

r~Q/H flip r~\y"H

FLOP

DRIVER

»-TO DISK

6502

MPU

6522

Register

CLK

SO

BYTE RDY

o=

SO ENABLE

i-GH

QB

+ 16

COUNT

UP

CLOCK

202

-----------------------------------------------------Page 202-----------------------------------------------------
﻿
©_| i I o I i I o o I i r

©_J

1
 J

DATA BITS I CLOCKED J OUT II

I n|n

s s

NlN
 SIS

K -

BYTE READY LINE

S11" BIT CLOCKED OUT -►!

To help clarify the recording process let's follow a byte of data (10100110) as it is writ¬

ten to a diskette.

STEP 1. The 6502 converts the header block ID ($07), the 256 data bytes, the data block

checksum, and two null bytes into 325 GCR encoded bytes.

STEP 2. The head is positioned to the appropriate track and the clock divisor is set

to the correct value for this track.

STEP 3. The track is read until the correct sector header block is found. Wait out the

header gap.

STEP 4. Switch to write mode by ANDing the contents of the 6522's peripheral con¬

trol register (PCR) with $1F, ORing the result with $C0, and storing the final

result back in the PCR.

STEP 5. Write out five $FF characters as the data block sync mark.

STEP 6. Transfer the first 8-bit byte of the GCR encoded data to the data lines (D0-D7)

of the 6522 PIA.

STEP 7. Since Port A of the 6522 is configured as an output port, the data appears

on the Port A lines PA0 to PA7. This transfers the byte to the 74LS165 (UD3) parallel to serial shift register.

STEP 8. The bits are clocked out of the shift register (2) whenever the QB line (1) of

the 74LS193 hexadecimal counter (UF4) makes a transition from ground to

+5 volts.

203

-----------------------------------------------------Page 203-----------------------------------------------------
﻿
STEP 9. The bit stream from the shift register (2) is presented to the clock input of

the 74LS74 flip flop (UF6). The output of this flip flop (3) changes state whenever the bit stream (2) makes a transition from ground to +5 volts.

STEP 10. The output of the flip flop (3) is amplified and sent to the record/play head

of the drive. This causes the magnetic zones to be written onto the surface of a diskette. Note that the direction of the electric current, and hence the direction of magnetization, changes only when a "1" is to be written.

STEP 11. Once all 8 bits have been clocked out of the shift register, the byte ready

line goes high. This sets the overflow flag in the 6502 to indicate that it is time to send the next data byte to the 6522.

STEP 12. Once all the data bytes have been written, switch to read mode by ORing

the contents of the 6522's peripheral control register (PCR) with $E0 and storing the result back in the PCR.

9.10 Reading Data From a Diskette

The diagrams below highlight the important components and waveforms involved in reading a GCR encoded byte of data.

1541 BLOCK DIAGRAM

READ MODE

FROM

CLR CLK

S S

CLR CLK

NlN

CLR CLK CLR CLK

_ A A_

204

-----------------------------------------------------Page 204-----------------------------------------------------
﻿
1 DATA

1 BITS

IclockedI

IN 1

1

1 1

©_J—1_

n

© -

i_
 1

1

1

©

_l L

©i ■ i_

Shift

° 1

Shift

1 | 0

Shift Shift

o 1

Shift

1

Shift

1 | 0

Shift Shift

E READY

To help clarify the reading process let's follow a byte of data as it is read from a diskette.

STEP 1. The head is positioned to the appropriate track and the clock divisor is set

to the correct value for this track.

STEP 2. The track is read until the correct sector header block is found.

STEP 3. Wait for the sync mark at the start of the data block.

STEP 4. As the track passes over the record/play head a stream of weak electrical pulses

is induced in the head. A pulse is induced whenever the magnetic field changes its orientation. The pulse is amplified and shaped (1).

STEP 5. The stream of pulses from the shaper circuitry (1) is fed to the CLEAR input

of the 74LS193 hexadecimal counter (UF4) and to the 74LS02 (UE5) NOR gate. Whenever a pulse occurs, the hexadecimal counter (UF4) and the divide by N counter (UE7) are cleared to a count of zero. This ensures that the clock is always synchronized with the incoming stream of pulses.

STEP 6. Once the hexadecimal counter has been cleared, it begins to count up the clock

pulses it receives from the divide by 16 counter. QA (not shown) is the l's bit of the counter. QB (2) is the 2's bit of the counter. QC (3) and QD (4) are the 4's and 8's bits, respectively.

STEP 7. On each ground to +5 volt transition of QB (2), a bit is shifted into the 74LS164

serial to parallel shift register (UD2). The bit that is shifted in (5) is found by NO Ring the QC (3) and QD (4) lines of the counter. Note that whenever a pulse clears the divide by 16 counter, the next bit is read as a "1." If the counter has not been cleared before the next ground to +5 volt transition of QB (2), the next bit is read as a "0."

STEP 8. Once 8 bits have been clocked into the shift register, the byte ready line goes

205

-----------------------------------------------------Page 205-----------------------------------------------------
﻿
high. This sets the overflow flag in the 6502 to indicate that it is time to read the data byte from the 6522.

STEP 9. The 6502 reads the data byte from the 6522 and stores it in RAM.

9.11 Summary of Bugs in DOS 2.6

Over the years, various bugs have been reported in Commodore's disk operating systems. In some cases, the bugs have been real; in other cases, imaginary. This section sum¬ marizes our findings regarding the bugs in DOS 2.6. Please note that this information applies only to the 1541.

1. Incorrect dummy data block produced during formatting:

During formatting, all the Commodore disk drives (except the old 2040's) write out a dummy data block for each track and sector. On all the drives, except the 1541, this dummy data block consists of 256 null bytes ($00). On the 1541 the dummy data block consists of one $4B character followed by 255 $01 bytes. This is caused by an unnecessary INX instruction at $FC86. If this byte were replaced by a NOP ($EA), the normal dummy data block would be produced.

The difference in the dummy data blocks does not cause any real problems and pro¬ vides an easy way to identify a diskette formatted on the 1541.

2. The save and replace command "@0":

Over the years numerous writers have advised Commodore owners not to use the save and replace command because it contained a bug. Our study of the ROM routines and a lot of testing has convinced us that the bug in the replace command is a myth. There are, however, two situations in which the use of the @ replacement command can cause problems:

a) Replacing an unclosed file, *SEQ, *PRG, etc:

When you replace a file, the new file is written to diskette first. Then the DOS pro¬ ceeds to trace through the file chain of the old file and marks the sectors it finds as available-for-use in the BAM. If the old file was unclosed, the track and sector links may be incorrect and some of the blocks in a different active file on the diskette may be freed (see a more detailed description of what happens in Section 2.5 on scratch¬ ing a file). If this happens, subsequent writing to the diskette will overwrite the data in this file. This is the most likely cause of user complaints about a bug in the save and replace command on the 2040 and 4040 drives. The code at $C835 prevents this from happening on the 1541 drive.

b) Not enough space on disk:

When a file is replaced, the new file is written to diskette before the old file is scratched. If there is not enough space on the disk for the new copy of the file, the process aborts. When this occurs, the error light will come on (72, DISK FULL). Usually, this makes

206

-----------------------------------------------------Page 206-----------------------------------------------------
﻿
people wonder if something went wrong; so they VERIFY to be sure the file has been saved correctly. The file verifies as OK. A check of the directory indicates no unclosed files. However, the file may appear somewhat shorter than before. This did not occur because your program has been compacted. Rather, it was truncated by the DOS. It isn't all there! We hope you have a backup handy. If not, you may still be able to recover your file. A printout of the BAM and some quick work on editing the directory entry's starting track and sector are in order. (See Chapter 8.) The sectors shown as unallocated (free) in the BAM hold the only complete copy of your program, the original version that is. The latter portions of the @ replacement ver¬ sion of your program have been stored in disk WOM (Write Only Memory) by the DOS. Bye, bye.

3. The Block-Read (B-R) command:

This command has been replaced by the Ul command and with good reason. The B-R command has two serious bugs that make it unusable on the 1541. The use of this command is NOT RECOMMENDED! See Chapter 5 for the gory details.

4. The Block-Write (B-W) command:

This command has been replaced by the U2 command and with good reason too. The

B-W command is also unusable on the 1541. The use of this command is NOT RECOM¬

MENDED either. Chapter 5 again gives the scoop.

5. The Block-Allocate (B-A) command:

Although this command seems to work correctly on other Commodore drives, it does not work properly on the 1541. This command really has two functions:

a) To allocate a free sector in the BAM:

When the track and sector specified in the block-allocate command is free (not in use) in the BAM, the block allocate command should allocate the block in the BAM. The B-A command appears to do this correctly on the 1541.

b) Find the next available track & sector:

If the track and sector specified in the block-allocate command is already allocated (in use) in the BAM, the block allocate command should not change the BAM in any way. It should return a 65, NO BLOCK error and report the track and sector of

the next available block in the BAM. This feature of the B-A command was included

to allow the programmer who is creating his own random access files to determine

the next free block that he/she can use.

This feature of the B-A command does not work correctly on the 1541! The command does return the track and sector of a free block all right, but with a difference!

1. It occasionally returns a sector on track 18. This should not happen because track

18 is reserved for the directory.

207

-----------------------------------------------------Page 207-----------------------------------------------------
﻿
2. It ALLOCATES ALL THE BLOCKS on the track that it returns in the error

message in the BAM.

Because of these bugs, the use of the B-A command on the 1541 is NOT RECOM¬ MENDED. However, the CERTIFY A DISKETTE program listed in Chapter 5 does work. The reason for this is that this program stores a duplicate copy of the BAM in C64 RAM which is later rewritten to the diskette. This technique repairs the damage done by the B-A command.

6. UJ: or U: command:

Commodore disk drives have traditionally used one or both of these commands to enable the user to reset the drive (just as though the drive were turned OFF and then ON again). Neither command works correctly on the 1541 drive. The drive goes on a trip to never-never land and must be turned OFF and then ON again to recover

from one of these commands. The command "U;" is the one to use to reset the 1541.

7. Ul- command:

The 1541 manual indicates that this command is used to set the disk drive to operate correctly with the VIC-20. Current 1541's work with a VIC-20, period.

Summary

Despite its flaws, the DOS in the 1541 is a remarkably efficient peripheral. The DOS programs for most other microcomputers are vastly inferior to DOS 2.6; a little faster maybe, but not as smart. The support of relative file structures, read ahead buffering, and the underlying principles of asynchronous I/O make the 1541 an outstanding bargain in the world of microcomputing. These features are normally found only in multiuser or multiprocess operating systems.

9.12 Write Incompatability with 4040

Programs or data stored on a diskette formatted on a 1541 disk drive can be READ using a 2040 or 4040 disk drive. Conversely, a 1541 disk drive can READ a diskette formatted on either a 2040 or 4040 disk drive. However, these drives are not completely write compatible.

This write-incompatibility problem appears to be caused by two things: 1. Differences in the header gap length.

2. Alignment problems (particularly with the 1541).

Let's consider the differences in the header gap length first.

Differences in Header Gap Length

The 2040 and 4040 drives use a header gap that is nine GCR bytes long while the 1541 uses a header gap that is only eight non-GCR bytes long. On this basis we would expect

208

-----------------------------------------------------Page 208-----------------------------------------------------
﻿
the header gaps to be 90 and 64 bits long respectively. However, when we use a bit- grabber to view the gap we find that the actual header gaps as recorded on disk are 100 bits for the 4040 and 92 bits for the 1541. In read mode, this makes no difference. After reading the header bytes to check that this is the correct sector, all the drives simply wait for the next sync mark. The number of bytes in the header gap does not matter. Once the sync mark is over, the first character in the data block is read. This is the data block ID character. If it is not a $07, the DOS reports a 22 READ ERROR

(data block not found).

In write mode, however, the length of the header gap is important. After reading the header bytes to check that this is the correct sector, all the drives count off the bytes that make up the header gap. Once the correct number of bytes have been read, the drive flips to write mode and begins writing out the data block sync character. Since this is reputed to be an important aspect of the write incompatibility problem, let's ex¬ amine what happens in some detail.

The last part of the header gap and the start of the data block sync mark in a sector of a diskette that has just been formatted on a 1541 disk drive looks something like this:

Sync mark

1541 xxxxxxxxxxllllllllllllllllllllllllllllllllllll-*- 92 bits

The last part of the header gap and the start of the data block sync mark in a sector of a diskette that has just been formatted on a 4040 disk drive looks something like this:

Sync mark

4040 xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx 111111111111-*- 100 bits

When a sector of a diskette that was ORIGINALLY FORMATTED ON A 4040/2040

disk drive is REWRITTEN ON A 1541, the result is as follows:

Original Sync mark

4040 xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx 111111111111-*-

Rewrite Sync mark

1541 xxxxxxxxxx-11111111111111111111111111111111111-*-

Sync mark

Result xxxxxxxxxx-111111111111111111111111111111111111-*-

NOTE: The "-" marks when the drive switches into write mode. A transient current

appears to flow through the record/play head during this time interval.

The original sync mark on the diskette has been completely overwritten by the new one. This sector can be read cleanly on any drive. It appears that a 1541 drive should be able to write data onto a diskette that was originally formatted on a 4040 drive without causing any problems.

When a sector of a diskette that was originally formatted on a 1541 disk drive is rewrit¬

ten on a 4040/2040, the result is as follows:

209

-----------------------------------------------------Page 209-----------------------------------------------------
﻿
Original Sync mark

1541 xxxxxxxxxxmillllllllllllllllllllllllllllllll-*-

Rewrite Sync mark

4040 xxxxxxxxxxxxxxxxx-lllllllllllllllllllllllllllllL*-

Pseudo-sync Sync mark

Result xxxxxxxxxxlllllll-11111111111111111111111111111*-

NOTE: The "-" marks when the drive switches into write mode. A transient current

appears to flow through the record/play head during this time interval.

In this case, the original sync mark on the diskette has NOT been completely overwrit¬ ten by the new one. The start of the old sync mark is still there. What actually gets recorded at the start of the "new" sync mark depends on the speed of the drives, the polarity of the magnetic field used to record the original "1" at that spot on the diskette, and any transients that flow through the head as it switches into write mode.

Before you read this next section, be sure that you understand Section 9.7 on the Record¬ ing Process.

Let's take a look at an "exploded" view of that spot just before the new sync character is written. Remember, a "1" is not recorded as magnetization in a particular direction. It is simply a change in the direction. Now that you've got that straight, here is what that spot might look like.

Original

N

S

S

N

N
 S

S

N
 N
 S

S N

N
 S

S

N
 N
 S

1

]

I

*

I
 L

I

1

I
 L
 1

Everything appears normal. Now let's write that sync mark.

Original

by a 1541

N S

S N

N S

S N

N S

S N.

N S

S N

N

S

Replacement sync mark written ??

by a 4040

N S
 S N

N S.
 S N.
 N
 S

11

= effects of transient currents

Result

N S
 S N

N S

S ??

N S

S N
 N S
 S N

N

S

1

I
 1
 1

1

I

1

1

1

Everything worked out just fine. We have a clean sync mark and the sector can be read cleanly by either drive. However, suppose our 74LS74 flip-flop (UF6) had been in the opposite state or the speed of this drive did not exactly match this new one. What would happen? Take a look.

210

-----------------------------------------------------Page 210-----------------------------------------------------
﻿
Original

N SS N N

SS

N N

SS

N N

S S
 NN

S

by a 1541

sync mark written

??

S
 N N

S S

N N

SS

N

by a 4040

Result
 N S

?? = effects of transient currents

S NN SS ?? NN SS NN SS N

1

?0

1

1
 1

Argh! Potential problems. Because the magnetic polarity of the new "1" happened to match the polarity of the existing zone, we appear to have just created a double-length magnetic zone. If we have, this will be interpreted as a "0" bit. From a study of the bits actually recorded on disk, this appears to happen every time! If there are more than 10 preceeding "1" bits, this single "0" will be interpreted as the end of the sync mark and the drive will interpret the rest of the sync bits as data. Since this will definitely NOT be decoded as a $07 byte, the drive errs out with a 22 READ ERROR.

Since the header gaps only differ in length by 8 bits, we should always have only seven l's in the pseudo-sync. An examination of the bits recorded on the disk seems to sup¬ port this conclusion. As a further test we did some testing using recently aligned drives. We found surprisingly few errors when we use a 4040 disk drive to rewrite all non- directory sectors on a 1541 formatted disk. On a freshly formatted diskette, we found no errors at all after rewriting over 2400 sectors. If the sectors of the 1541 diskette had been rewritten several times using a 1541 before they were rewritten on a 4040, we did start to find a few errors. However, the error count was low. Usually less than two errors when rewriting all 640 sectors and these tended to occur in two specific areas: on tracks 25 or 26 or on tracks 31 or 32. These findings lead us to conclude that the differences in header gap length is NOT the cause of write compatibility problems be¬

tween the 1541 and 4040 disk drives.

If for some reason you want to reduce the difference in header gap further when writing onto a 1541 formatted diskette using a 4040 drive, enter the following magic incantation in either program or immediate mode.

OPEN 15,3,15

PRINT#15, "M-WCHR* < 157) CHR* < 16) CHR* (1) CHR* <8)

CLOSE 15

This will change the header gap length of the 4040 drive from 9 to 8 GCR bytes (actual length = 90 bits). You can now write to the 1541 diskette with little fear of damage. However, you must remember to reset your 4040 drive (turn it off or issue a UJ com¬ mand) before you insert one of your 4040 formatted diskettes. Otherwise, a magnetic plague will develop among your 4040 formatted diskettes. Don't say you weren't warned!

Head Positioning Problems

Since we encountered so few errors using properly aligned drives, we feel that most of the reported problems of incompatibilities are the result of head positioning errors.

211

-----------------------------------------------------Page 211-----------------------------------------------------
﻿
If a sector is rewritten on a different drive and the position of the read/write head is different, the new data will not completely replace the old as indicated below.

Original

on one

drive

Rewritten

N N N

s

S 1 S

s

s

S 1 s

N

N

0

s s s

S

on another drive

S 1 s

0

N N
 N 1

N

S S

Original

N

1

s

s

1

0

s

Rewritten
 S

N

N

s

by another
 S

1

0

N

N
 1

s

drive

s
 N

N

s

When this sector is read on the original drive, the head will pick up both the new signal and the old signal. The relative strengths of these two signals depend on the amount of the original signal remaining. If the two drives are sufficiently different, the read signal will be garbled and produce an abundance of 22 and 23 READ ERROR'S.

Summary

In conclusion, although there is a difference in header gap size between the 1541 and the 4040 drives, this does NOT appear to be the cause of write incompatibility problems. Most complaints about the write incompatibilities of various disk drives are probably due to problems in head positioning. Further evidence for this is the fact that some schools are experiencing similar difficulties when students use several different 1541 drives for saving programs on a single diskette.

9.13 TOOLS FOR EXPLORATION

To make your exploration of the 1541 easier we have developed two programs to assist

you.

a) Disk peek program

This program allows you to look at a hex dump of any area of the 1541's RAM or ROM. This is a very useful tool for examining the contents of the 1541's RAM.

b) Create a file program

This program allows you to read out any area of the 1541's RAM or ROM and store the contents into a program file with any load address you choose. You can then load the file into your 64's memory and examine it using an extended machine language

monitor such as SUPERMON.

212

-----------------------------------------------------Page 212-----------------------------------------------------
﻿
NOTE: Line 160 contains a special character #184 repeated 21 times. This character can be typed by holding down the Commodore logo key in the lower left corner and pressing the U key.

1541 DISK PEEK

100 REM 1541 DISK PEEK

110 REM BY GERALD NEUFELD

120 C0=0:C2=2:C7=7:CA=10:F=15:CG=16:H0=4

8:HX=127

130 Z*=CHR*(0):N*=""

140 M*=" <RVS> PRESS: P TO PAUSE Q

TO QUIT {ROFF}"

150 PRINT"<CLR>"TAB(9)"PEEK OF 1541'S ME MORY"

160 PRINTTAB<9)"{#184 21>"

170 PRINTTAB(4)" COPYRIGHT: G. NEUFELD,

1983"

180 PRINT"{DOWN} ONE MOMENT PLEAS

E

190 DIM HX*(255),H*<15)

191 FOR K=0 TO 9:H*<K)=CHR*(48+K):NEXT:F 0RK=10T015:H* <K)=CHR*(55+K):NEXT

200 F0RJ=0T0F:FORK=OTOF:HX* <J*16+K)=H* <J

>+H*(K):NEXT:NEXT

210 PRINT"{HOME}{DOWN 2}"M*

220 PRINT"{DOWN} INPUT START ADDRESS IN

HEXADECIMAL"

230 OPEN 15,8,15

240 PRINT"{DOWN} *0000":PRINT"{UP}"; 250 INPUT H*

260 HL=CO:HH=C0:FORK=1T02:C=ASC(MID*(H*,

K) >-H0: IFOCATHENC=C-C7

270 IF C<C0 OR OF THENPRINT"{UP 2}";:GO T0240

280 D=ASC(MID*(H*,K+2))-HO:IFD >CATHEND=D

-C7

290 IF D<CO OR D>F THENPRINT"{UP 2}";:G0 T0240

300 HH=HH+C*CG" (C2-K) : HL=HL+D*CG~ (C2-K) : NEXTK

310 PRINT"{UP}"TAB(6);

320 PRINT#15,"M-R"CHR*(HL)CHR*(HH)CHR*<8

)

330 0*="":FOR K=C0T0C7:GET#15.,A*: IF A*=N

*THENA*=Z*

340 A=ASC(A*):E=AANDHX:E*=".":IFE>31ANDE <97THENE*=CHR*(E)

350 0*=0*+E*:PRINT" "HX*(ASC(A*));:NEXT:

213

-----------------------------------------------------Page 213-----------------------------------------------------
﻿
PRINT" {RVS}"0*

360 FL=0:HL=HL+8:IFHL >255THENHL=HL-256:H

H=HH+1: FL=1". PRINTM*

370 IF HL=128 THEN FL=1:PRINTM*

380 PRINT" *"HX*<HH)HX*(HL)j:IFFL=1THENP RINT:PRINT"{UP}";:G0T0250 390 GET A*:IF A*=""G0T0 320

400 IF A*="P"THENPRINT:PRINT"{UP}"5:G0T0

250

410 CL0SE15

CREATE A FILE

10 PRINT"{CLR}{DOWN}"TAB(6)"DISK ROM TO

FILE"

20 INPUT"{DOWN}START AT LOCATION (HEX) C100{LEFT 6}";A*

30 Z*=A*:G0SUB280:S=Z:IF ZF=1 GOTO 20 40 PRINT"{UP}"TAB(31>Z

50 INPUT"{DOWN}QUIT AT LOCATION (HEX) F FFF{LEFT 6}";A*

60 Z*=A*:G0SUB280:Q=Z:IF ZF=1 GOTO 50 70 PRINT"{UP}"TAB(31)Z

80 INPUT"{DOWN}SAVE IN FILE NAMED ROM 1 541{LEFT 10}";F*

90 INPUT"{DOWN}WITH LOAD ADDRESS OF (HEX ) 1100{LEFT 6}";A*

100 Z*=A*:G0SUB280:L=Z:IF ZF=1 GOTO 90 110 PRINT"{UP}"TAB(31)Z

120 0PEN15,8,15,"10"

130 OPEN 1,8,5,"@0:"+F*+",P,W" 140 INPUT#15,EN,EM*,ET,ES

150 IF ENM9 THEN PRINT" {DOWN}DISK ERROR

"EN;EM*;ET;ES:CLOSE1:CL0SE15:STOP

160 PRINT"{DOWN 2}"

170 LH=INT(L/256):LL=L-256*LH

180 PRINT#1,CHR*(LL);CHR*(LH);

190 FOR K=S TO Q

200 KH=INT(K/256):KL=K-256*KH

210 PRINT#15,"M-R"CHR*(KL)CHR*(KH)

220 GET#15,A*:IF A*="" THEN A*=CHR*(0> 230 PRINT#1,A*;

240 PRINT"{UP}WORKING ON"K 250 NEXT

260 CL0SE1:CL0SE15:END 270 :

280 Z=0:ZF=0

290 IF LEN(Z*)>4 THEN ZF=1:PRINT"{DOWN}{ RVS}HEX STRING TOO LONG":RETURN

300 IF LEN(Z*)<4 THEN ZF=1:PRINT"{DOWN}{

214

-----------------------------------------------------Page 214-----------------------------------------------------
﻿
RVS}HEX STRING TOO SHORT":RETURN 310 FOR K=l TO 4

320 ZN=ASC(MID*(Z*,K))-48:IF ZN>9 THEN Z

N=ZN-7

330 IF ZN<0 OR ZN>15 THEN ZF=1:PRINT"{DO WN}{RVS}BAD HEX CHARACTER":RETURN 340 Z = Z + ZN * 16M4-K) 350 NEXT

360 RETURN

HAVE FUN!

Late Mews

In early 1984 Commodore began shipping the 1541 disk drives that contained a new $EOOO-$FFFF ROM. The part numbers of these ROMs are: original 901229-03 revised 901229-05. The changes in the new ROM are:

$E683 Eliminate JSR TO ITTERR($EA4E) to solve stack overflow $E68B problems.

$E780 to Eliminate power-on boot of the utility loader to solve possible $E7A1 problems during initialization.

$E9DC Insert JMP to patch at $FF20.

$EAA4 Insert JMP to patch at $EF10.

$EBDB/DD/E0/E2 Change initialization of the serial bus.

$FEE6 New ROM checksum.

$FF10 New patch to change the initialization of the serial bus during the

power-up routine DSKINT.

$FF20 New patch to the serial bus listen routine ACPTR.

The ROM in the SX-64 has an additional change. The header block gap at $F58D has been changed from $08 to $09 to eliminate the difference in header gap size between

the 4040 and SX-64.

215

-----------------------------------------------------Page 215-----------------------------------------------------
﻿

-----------------------------------------------------Page 216-----------------------------------------------------
﻿
APPENDIX A

1541 RAM VARIABLE DEFINITIONS

217

-----------------------------------------------------Page 217-----------------------------------------------------
﻿

-----------------------------------------------------Page 218-----------------------------------------------------
﻿
JOB QUEUE: $0000-$0005

The job queue is used to tell the disk controller what disk operations to perform. A disk command such as LOAD, SAVE, SCRATCH, etc. is interpreted by the drive's 6502

(while in its normal mode) and broken down into a set of

simple operations (jobs) such as: read track 9 sector 18 into data buffer #2, write the data in buffer #3 out to track 12 sector 5, etc. The track and sector information required for the job is placed into the header table and the JOB CODE corresponding to the job to be done is put in the job queue. The job code's position in the queue indicates which data buffer (if any) is to be used and

where the track and sector information is stored in the

header table. When the 6502 is next in its floppy disk controller mode (it switches every 10 milliseconds), it scans the job queue looking for jobs to do. If it finds one, it carries it out making use of the track and sector information in the header table. Once the job is done, or aborted, the disk controller replaces the job code with an error code that indicates the job status.

$80 $90

JOB CODES

READ a sector WRITE a sector

$01 $02

ERROR CODES

job completed successfully!

header block not found

$A0 $B0

VERIFY a

SEEK any

sector sector

$03 $04

no SYNC character

data block not found

$C0

BUMP (move) head

$05

data block checksum

error

to track

#1

$07

verify error after

write

$D0

JUMP to machine

$08
 write protect error

code in buffer
 $09

header block checksum

error

$E0

EXECUTE code in

buffer once up to speed & head ready

$0A $0B $10

data block too long

ID mismatch error

byte decoding error

ADDRESS| NAME

JOB QUEUE DEFINITIONS

$0000 $0001 $0002

JOBS

Use buffer #0 Use buffer #1 Use buffer #2

($0300+), find T/S ($0400+), find T/S ($0500+), find T/S

in in in

$06/7 $08/9 $0A/B

$0003 $0004

Use buffe Use buffe

r #3 r #4

($0600+), find T/S ($0700+), find T/S
 in in

$0C/D $0E/F

$0005

Use buffer #5

(no RAM), find T/S
 in

$10/1

HEADER TABLE: $0006-$0011

This is the area that specifies which tracks and sectors are to be used for the jobs in the job queue. Tracks and sectors are not needed for BUMP or JUMP jobs.

ADDRESS

$0006/7 $0008/9 $000A/B $000C/D $000E/F $0010/1

NAME

HDRS

HEADER TABLE DEFINITIONS

Track/sector for job in $0000 (buffer 0) Track/sector for job in $0001 (buffer 1) Track/sector for job in $0002 (buffer 2) Track/sector for job in $0003 (buffer 3) Track/sector for job in $0004 (buffer 4) Track/sector for job in $0005 (buffer 5)

219

-----------------------------------------------------Page 219-----------------------------------------------------
﻿
ADDRESS

$0012

$0014/5

$0016

$001B $001C

$001D $001E $001F

$0020

$0021 $0022 $0023

$0024- $002D

$002E/F $0030/1 $0032/3

$0034 $0035 $0036 $0037 $0038 $0039 $003A

NAME

DSKID

HEADER

ACTJOB WPSW

LWPT

DRVST

DRVTRK

STAB

SAVPNT BUFPNT HDRPNT GCRPNT GCRERR BYTCNT BITCNT BID

HBID

CHKSUM

1541 RAM VARIABLE DEFINITIONS

Master copy of disk ID. This is the ID specified when the disk was formatted. It is updated whenever a SEEK job is performed (see ROM patch $EF25). The initialize command performs a seek and therefore updates the master ID.

$0012 first ID character $0013 second ID character Unused - Disk ID for drive #1

Image of the most recent header read. The characters appear here in the same sequence that Commodore's manual says they are recorded onto the disk surface.

$0016 first ID character $0017 second ID character $0018 track number $0019 sector number $001A header checksum

NOTE: They are actually recorded onto

disk in the opposite sequence.

Not used

Flag to indicate that there has been a change in the write protect status.

UNUSED (WPSW for drive #1)

last state of the write protect switch UNUSED (LWPT for drive #1) Set to $01

on power-up

disk drive status

bit meaning

shut down drv motor? l=yes 0=no

drive motor l=on 0=off

head stepping l=on 0=off drive ready? l=no 0=yes UNUSED (DRVST for drive #1) Track currently under R/W head

UNUSED (DRVTRK for drive #1)

Work area for doing interconversions of binary data and its GCR write images

Temporary storage of pointers

Pointer to currently active buffer

Pointer to active values in header table Pointer to last character converted Not used

Byte counter for GCR/binary conversions

Not used

Data block ID character ($07) Header block ID character ($08)

Storage of data or header checksum

220

-----------------------------------------------------Page 220-----------------------------------------------------
﻿
ADDRESS

$003B $003C $003D $003E $003F $0040 $0041 $0042 $0043 $0044 $0045 $0046 $0047

$0048 $0049 $004A

$004B $004C $004D $004E

$004F

$0050

$0051

NAME

HINIB BYTE

DRIVE

CDRIVE JOBN

TRACC

NXTJOB NXTRK SECTR WORK JOB

CTRACK DBID

ACLTIM SAVSP STEPS

TMP

CSECT NEXTS NXTBF

NXTPNT

GCRFLG

FTNUM

1541 RAM VARIABLE DEFINITIONS

Unused Unused

Always $00 on 1541

Currently active drive ($FF if inactive) Position of last job in job queue (0-5) Byte counter for GCR/binary conversions Position of next job in job queue (0-5)

Next track to move head to

Sector counter. Used by format routine Temporary workspace

Temporary storage of job code

Unused

Data block ID code. Set on reset to $07.

This may be changed to write or read

data blocks with different data block

ID codes. However, the first nybble of the data block ID code should always be a zero ($0-). Otherwise, the controller will have difficulty detecting the end of the sync mark and the start of DBID. If you try to read a sector whose DBID is different from the value stored here, the disk controller will put an error code of $04 in the job queue and the drive will report a #22 error (DATA

BLOCK NOT FOUND).

Timer for acceleration of head

Temporary save of the stack pointer

The number of steps to move the head to get to the desired track. To move the head over 1 track, requires XX steps.

Values between 0 and 127 move the head

out (to lower track numbers). Values

over 128 move the head (256-value) steps in (to higher track numbers) Temporary storage Last sector read

Next sector to service

Hi byte of a pointer to the next buffer of GCR bytes to be changed into binary. The GCR bytes in the overflow buffer are translated first. This points to the

buffer that holds the rest of them.

Lo byte of a pointer to the next GCR byte location that is to be translated Flag to indicate whether the data in the currently active buffer has been left in binary (0) or GCR (1) form.

Used by the formatting routine to store the number of the track currently being formatted. Set on reset to $FF.

221

-----------------------------------------------------Page 221-----------------------------------------------------
﻿
ADDRESS NAME

1541 RAM VARIABLE DEFINITIONS

$0052/5

$0056/D

$005E

$005F $0060

$0061

BTAB

GTAB

AS

AF

ACLSTP

RSTEPS

Staging area for the four binary bytes being converted to GCR by PUT4BG($F6D0) or from GCR by GET4GB($F7E6).

Staging area for the five GCR bytes being converted from binary by PUT4BG ($F6D0) or to binary by GET4GB($F7E6). Number of steps to use to accelerate or decelerate when stepping the head ($04) Acceleration/deceleration factor ($04) Number of steps left to accelerate or decelerate when stepping the head

Number of steps left to step the head in fast stepping (run) mode.

$0062/3

$0064

NXTST

MINSTP

Pointer routine Minimum

move to

to the appropriate head stepping

Normally $FA05 (not stepping) number of steps for the head to make the use of fast stepping

$0065/6

$0067 $0068

$0069

$006A

$006B/C

$006D/E

VNMI

NMIFLG AUTOFG

SECINC

REVCNT

USRJMP

BMPNT

mode useful($C8). If fewer steps needed, use the slow stepping mode.

Pointer to start of NMI routine ($EB2E). Set on power up or drive reset.

Flag to indicate whether NMI in progress Flag to enable (0) or disable (1) the auto initialization of a disk (read BAM)

if ID mismatch detected.

Sector increment for use by SEQ routine. Set on reset to ($0A).

Counter for error recovery (number of attempts so far) Set on reset to $05 Pointer to the start of the user jump table($FFF6). Set on power up or reset. Pointer to the start of the bit map

($0400). Set when a disk is
 initialized.

$006F $0070 $0071

T0=TEMP Tl T2

Temporary work area Temporary work area Temporary work area

($6F on
 reset)

$0072 $0073 $0074

T3 T4

Temporary work area Temporary work area Temporary work area

($FF on reset)

$0075/6

IP

Indirect pointer variable

($0100)

$0077 $0078 $0079 $007A $007B $007C $007D $007E $007F $0080 $0081 $0082

LSNADR TLKADR LSNACT TLKACT ADRSED ATNPND ATNMOD PRGTRK DRVNUM TRACK

SECTOR LINDX

Set on power up or reset.

Listener address ($28 on reset) Talker address ($48 on reset) Active listener flag Active talker flag Addressed flag

Attention pending flag

6502 in attention mode

Last program accessed

Current drive number (always 0 in 1541) Current track number ($00 after use) Current sector number ($00 after use) Logical index (current channel*)

222

-----------------------------------------------------Page 222-----------------------------------------------------
﻿
ADDRESS

$0083 $0084 $0085 $0086 $0087 $0088 $0089 $008A

$008B/E $008F/3 $0094/5

$0096 $0097 $0098

NAME

SA

ORGSA DATA R0 Rl R2 R3 R4

RESULT ACCUM

DIRBUF ICMD MYPA CONT

1541 RAM VARIABLE DEFINITIONS

Current secondary address Original secondary address Temporary data byte Temporary result Temporary result Temporary result Temporary result Temporary result

Result area ($008B-$008E) Accumulator ($008F-0093)

Directory buffer ($0094-0095) $05/$02 IEEE command in (not used on 1541) MY PA flag $00

Bit counter for serial $00

Buffer byte pointers

These pointers (one for each buffer) are used to point at the next byte in the

buffer to be used. The B-P command sets

these pointers.

$0099/A $009B/C $009D/E $009F/0 $00Al/2 $00A3/4 $00A5/6

BUFTAB

Points to next byte in Points to next byte in Points to next byte in Points to next byte in Points to next byte in Points to next byte in Points to next byte in

buffer #0 buffer #1 buffer #2 buffer #3 buffer #4 CMD buffer ERR buffer

($0300) ($0400) ($0500) ($0600) ($0700) ($0200) ($02D6)

$00A7/D

$00AE/4

$00B5/A

BUFO

BUF1

RECL

Table of channeli's a the buffers. $FF is i Table of channel#'s a the buffers. $FF is i Table of lo bytes of

ssigned to each of

nactive buffer.

ssigned to each of

nactive buffer.

record numbers for

each buffer

$00BB/0

RECH

Table of hi bytes of
 record numbers for

each buffer

$00Cl/6 $00C7/C $00CD/2

$00D3 $00D4 $00D5 $00D6 $00D7

$00D8/C $00DD/1 $00E2/6 $00E7/B $00EC/1 $00F2/7

$00F8 $00F9

NR RS SS

F1PTR

RECPTR SSNUM SSIND

RELPTR ENTSEC ENTIND FILDRV PATTYP FILTYP CHNRDY EIOFLG JOBNUM

Table of next record Table of record size Table of side sectors

File stream 1 pointer

Pointer to start of r Number of side sector Index to side sector

Relative file pointer Sector of directory e Index of directory en Default flag, drive # Pattern, replace, clo Channel file type

Channel status

Temporary for EOI Current job number

numbers for buffers for each buffer for each buffer

ecord

to track

ntries tries

(all 0 on 1541) sed-flags, type

223

-----------------------------------------------------Page 223-----------------------------------------------------
﻿
ADDRESS

$00FA/E $O0FF/O $0101/2

$0103

$0200- $0229

$022A

$022B/D

$022E/3

$0244/9

$024A $024B $024C $024D $024E

$024F/0 $0251/2

$0253 $0254 $0255 $0256 $0257 $0258 $0259 $025A

$025B/F $0260/5 $0266/B

$026C $026D $026E $026F

NAME

LRUTBL NODRV

DSKVER

ZPEND

CMDBUF

CMDNUM LINTAB

CHNDAT

LSTCHR

TYPE

STRSIZ TEMPSA CMD

LSTSEC BUFUSE MDIRTY ENTFND DIRLST CMDWAT LINUSE LBUSED REC

TRKSS SECSS

LSTJOB DSEC DIND

ERWORD ERLED

PRGDRV PRGSEC

1541 RAM VARIABLE DEFINITIONS

Least recently used table

No drive flag for drives 0 and 1

DOS version taken from track 18 sector 0 for drives 0 and 1 Unused

STACK AREA $0104-$01FF

Command buffer ($0200-$0229)

Disk commands such as: N0:GAMES #1,G1

that are sent to the disk drive from

the computer over the serial bus are stored here. The command is parsed to locate special characters such as : , Once the command has been interpreted,

ROM routines are executed to do it.

Command code number

SA:LINDX table ($022B-$023D)

This table indicates the current status

of each data channel (secondary address) Each" position represents one channel, channel 0=$022B; 1=$022C; 2=$022D; etc. Possible channel status values are:

$FF - inactive $81 - open for write $41 - read/write $01 - open for read

Channel data byte ($023E-$0243)

The most recent byte read or written

for each channel

Channel last character pointer

Points to the last character read or written in the buffer for each channel

Active file type

Length of the string

Temporary secondary address Temporary job command

Work area for finding best sector to do

Buffer allocation

BAM dirty flag (drives 0/1) Directory entry found flag Directory listing flag Command waiting flag

LINDX use word

Last buffer used

Record size. Used by directory routines Side sector track. Used by dir routines Side sector sector. Used by dir routines Last job by buffer ($025B/C/D/E/F) Sector of directory entry by buffer Index of directory entry by buffer Error word for recovery

Error LED mask for flashing Last program drive Last program sector

224

-----------------------------------------------------Page 224-----------------------------------------------------
﻿
ADDRESS

$0270 $0271

$0272/3

$0274 $0275 $0276 $0277 $0278 $0279

$027A/F $0280/4 $0285/9

$028A $028B $028C $028D $028E

$028F $0290 $0291 $0292 $0293 $0294 $0295 $0296 $0297 $0298 $0299 $029A

$029B/C $029D/0 $02Al/0

$02Bl/4 $02D5/8

$02F9

$02FA/B $02FC/D $02FE/F

NAME

WLINDX RLINDX NBTEMP CMDSIZ CHAR

LIMIT F1CNT F2CNT F2PTR

FILTBL FILTRK FILSEC

PATFLG IMAGE

DRVCNT DRVFLG LSTDRV

FOUND

DIRSEC DELSEC DELIND LSTBUF INDEX

FILCNT TYPFLG MODE

JOBRTN EPTR TOFF UBAM TBAM BAM

NAMBUF ERRBUF

WBAM

NDBL NDBH

PHASE

1541 RAM VARIABLE DEFINITIONS

Write LINDX Read LINDX

# blocks temp

Command string size

Character under the parser PTR limit in comparison

File stream 1 count File stream 2 count

File stream 2 pointer

PARSER TABLES ( $027A-$0289)

Table of filename pointers First file link (Track) First file link (Sector)

Pattern presence flag File stream image

Number of drive searches

Drive search flag

Last drive w/o error. Used as the

default drive number.

Found flag in directory searches Directory sector

Sector of first available entry Index of first available entry

=0 if last block

Current index in buffer Counter of file entries

Match by type of flag Active file mode (R,W) Job return flag

Pointer for recovery

Total track offset

Last BAM update pointer

Track # of BAM image (drive 0/1) BAM images ($02A1-02B0)

OUTPUT BUFFERS ($02B1-$02F8)

Directory buffer ($02B1-$02D4)

Error message buffer ($02D5-$02F8)

Don't write BAM flag. Set to 0 at start and end of any disk command.

# of disk blocks free (lo byte 0/1) # of disk blocks free (hi byte 0/1) Current phase of head stepper motor

225

-----------------------------------------------------Page 225-----------------------------------------------------
﻿
ADDRESS
 NAME

1541 RAM VARIABLE DEFINITIONS

DATA BUFFERS ( $0300-$07FF)

$0300 $0400 $0500 $0600 $0700

BUFO BUF1 BUF2 BUF3 BUF4

Data buffer #0 Data buffer #1 Data buffer #2 Data buffer #3 Data buffer #4

($0300-$03FF) ($0400-$04FF) ($0500-$05FF) ($0600-$06FF) ($0700-$07FF)

BAM ONLY!

ADDRESS

$1800

NAME

PB

1541 I/O DEFINITIONS

SERIAL I/O 6522 ($1800-$180F)

DATA PORT B - Serial data I/O

BITS FOR SERIAL HANDSHAKE

DATIN

DATOUT CLKIN

CLKOUT ATNA ATN

Bit 0 Bit 1 Bit Bit Bit Bit
 $01 Data in line $02 Data out line $04 Clock in line $08 Clock out line

$10 Attention acknowledge line $80 Attention in line

$1801 $1802 $1803 $1804 $1805 $1806 $1807 $1808 $1809 $180A $180B $180C $180D $180E

PA1

DDRB1 DDRA1 T1LC1 T1HC1 T1LL2 T1HL2 T2LC1 T2HC1 SRI

ACR1 PCR1 IFR1 IER1

DATA PORT A - Unused

DATA DIRECTION FOR PORT B DATA DIRECTION FOR PORT A TIMER 1 LOW COUNTER TIMER 1 HIGH COUNTER TIMER 1 LOW LATCH TIMER 1 HIGH LATCH TIMER 2 LOW COUNTER TIMER 2 HIGH COUNTER SHIFT REGISTER

AUXILIARY CONTROL REGISTER PERIPHERAL CONTROL REGISTER INTERRUPT FLAG REGISTER INTERRUPT ENABLE REGISTER

Unused

$1C00

DSKCNT

DISK CONTROLLER 6522 ($1C00-$1C0F)

DATA PORT B - Disk controller I/O

Bit 0 - $01 Bits 0 & 1 are cycled to Bit 1 - $02 step the head

Bit 2 - $04 Motor on (1) or off (0) Bit 3 - $08 Drive active LED on/off Bit 4 - $10 Write protect sense Bit 5 - $20 Density select (0) Bit 6 - $40 Density select (1) Bit 7 - $80 SYNC detect line

226

-----------------------------------------------------Page 226-----------------------------------------------------
﻿
ADDRESS

$1C01 $1C02 $1C03 $1C04 $1C05 $1C06 $1C07 $1C08 $1C09 $1C0A $1C0B $1C0C $1C0D $1C0E

NAME

DATA2 DDRB2 DDRA2 T1LC2 T1HC2 T1LL2 T1HL2 T2LC2 T2HC2 SR2

ACR2 PCR2 IFR2 IER2

1541 I/O DEFINITIONS

DATA PORT A - GCR data I/O to diskette

DATA DIRECTION FOR PORT B DATA DIRECTION FOR PORT A TIMER 1 LOW COUNTER TIMER 1 HIGH COUNTER TIMER 1 LOW LATCH TIMER 1 HIGH LATCH TIMER 2 LOW COUNTER TIMER 2 HIGH COUNTER SHIFT REGISTER

AUXILIARY CONTROL REGISTER PERIPHERAL CONTROL REGISTER INTERRUPT FLAG REGISTER INTERRUPT ENABLE REGISTER

227

-----------------------------------------------------Page 227-----------------------------------------------------
﻿

-----------------------------------------------------Page 228-----------------------------------------------------
﻿
APPENDIX B

ANALYSIS OF THE 1541's ROM

Here be dragons and ogres! Travelers, walk not alone.

229

-----------------------------------------------------Page 229-----------------------------------------------------
﻿

-----------------------------------------------------Page 230-----------------------------------------------------
﻿
NAME

SETLDA

LEDSON

ERROFF

ERRON

PARSXQ

PS5

PS10

PS20

ADDRESS

$C100

$C118

$C123

$C12C

$C146

$C150

$C153

$C15D

$C160

$C163

$C16A

$C17A

$C181

DESCRIPTION OF WHAT ROM ROUTINE DOES

Turn on drive-active LED:

Set bit 3 of DSKCNT ($1C00) to turn on LED for the current drive (DRVNUM; $7F)

Turn on drive-active LED:

Set bit 3 of DSKCNT ($1C00) to turn on drive active LED for drive 0.

Turn off error LED:

Store $00 in ERWORD ($026C) and in ERLED ($026D) to clear any error status and

turn off drive-active/error LED.

Turn on error LED:

Store $80 in ERWORD ($026C) to ensure

LED will continue to flash and set bit

3 of DSKCNT to turn the LED on using

the LED mask from LEDMSK ($FECA).

Parse string in command buffer:

Clear the "don't write BAM" flag, WBAM ($02F9) and move the drive number of the last successful job from LSTDRV ($028E)

($028E) to DRVNUM ($7F). This makes the

last used drive the default drive.

JSR to OKERR ($E6BC) to clear any errors and move the OK error message into the

error buffer.

Check if the command's secondary address (ORGSA; $84) was $0F (command channel). If it was not $0F, exit with a JMP to OPEN ($D7B4).

If the secondary address was $0F, JSR to CMDSET ($C2B3) to interpret the command and set up the necessary variables and registers (on return .Y=0).

Move first character of command from the

command buffer ($0200) to CHAR ($0275). Search the command table (CMDTBL; $FE89) for this character. If not found, exit

by loading .A with a #$31 (BAD COMMAND) and jumping to the command level error

handler (CMDERR; $C1C8).

If found, store the command's position in the table (the command number) into CMDNUM ($022A). Check if this command must be parsed by comparing the command number with $09. If parsing is required (NEW, RENAME, SCRATCH, COPY, & LOAD), JSR to TAGCMD ($C1EE) to set tables, pointers and patterns.

231

-----------------------------------------------------Page 231-----------------------------------------------------
﻿
NAME

PS30

ENDCMD

SCREND

SCREN1

CLRCB

CMDERR

SIMPRS

PRSCLN

ADDRESS

$C184

$C194

$C1A3

$C1AD

$C1BD

$C1C8

$C1D1

$C1DB

$C1E5

DESCRIPTION OF WHAT ROM ROUTINE DOES

Move the address of the appropriate ROM routine from the tables, CJUMPL ($FE95) and CJUMPH ($FEA1) into $6F/$70 (TEMP).

Exit with an indirect JMP to the routine via the vector at TEMP ($6F).

Terminate command successfully:

Clear the "don't write BAM" flag, WBAM ($02F9). Load .A with the error status from ERWORD ($026C). If non-zero, an

error has occurred so exit with a JMP

to CMDERR ($C1C8).

If command completed with no errors, set TRACK ($80), SECTOR ($81), and the

pointer into the command buffer, CB($A3)

to $00. JSR to ERRMSG ($E6C7) and ERROFF

($C123) to clear any error status.

Move current drive number from DRVNUM

($7F) to last used drive number, LSTDRV ($028E). Set the drive-busy flag, NODRV ($FF) to $00 to indicate that the drive is inactive. JSR to CLRCB ($C1BD) to

zero the command buffer. JMP to FREICH

($D4DA) to clear the internal channel.

Clear the command buffer ($0200-$0228; Erase any old command information by overwriting the old command with $00.

Command level error handling:

Set TRACK ($80) and SECTOR ($81) to $00 and JMP to CMDER2 ($E645).

Simple parser:

Initialize .X and the file table pointer FILTBL ($027A) to $00. Load .A with a $3A (:) and JSR to PARSE ($C268) to scan the command string for a colon.

On return Z=l if ":" found and .Y points to its position in the command. If not found, leave FILTAB=$00 and exit. If ":" was found, set FILTAB=(":" position - 1)

and exit. All exits are with a JMP to SETANY ($C368) to set the drive number.

Find colon (:) in command string:

Load .X and .Y with $00 and .A with $3A

(:) and JMP to PARSE ($C268).

Tag command string, set up CMD structure and file stream pointers:

232

-----------------------------------------------------Page 232-----------------------------------------------------
﻿
NAME
 ADDRESS

DESCRIPTION OF WHAT ROM ROUTINE DOES

COMMAND STRUCTURE (Bit mapped)

The disk comma

and LOAD, are

to determine t the command is

($028B) are se the presence o

of the command

been analyzed, checked agains

for that comma

nds, RENAME, analyzed by

he command s

parsed, bit

t or cleared r absence of . Once the c its structu t the correc

nd given in

SCRATCH, NEW, this routine

tructure. As

s in IMAGE to indicate

various parts

ommand has

re image is

t structure

STRUCT($FEA5+)

Bit

7 6 5 4 3 2 1 0

Name

PI Gl Dl Nl P2 G2 D2 N2

Meaning

Wild cards present (Y=l)

More than one file implied (Y=l) Drive # specified (not default) Filenamel given

Wild cards present (Y=l)

More than one file implied (Y=l) Drive # specified (not default) Filename2 given

TAGCMD

TC25

TC30

TC35

TC40

$C1EE

$C1F3

$C1F8

$C1FD

$C1FE

$C200

$C20A

NOTE: Bits 7-4 refer to file #1

Bits 3-0 refer to file #2

JSR to PRSCLN ($C1E5) to locate the position of the colon (:) that is a necessary part of all these commands. e.g. R0:NEWNAME=OLDNAME (Rename)

If no colon was found, load .A with $34

to indicate a bad command and exit with

a JMP to CMDERR ($C1C8) .

If a colon was found, set FILTAB to the

colon position - 1.

Check if a comma was found before the colon (.X > 0 on return from PARSE).

If a comma was found, the syntax is bad so exit via TC25 ($C1F3) .

Load .A with $3D (=) and JSR to PARSE ($C268). On return .X=0 indicates that no wild-card characters (? or *) were

found. If any were found, set bit 6 (Gl)

of IMAGE ($028B) to indicate that the

command applies to more than one file. In all cases, set bit 5 (Dl) of IMAGE to indicate that a drive # is present and set bit 0 (N2) to indicate that a second file name is given (fixed later)

233

-----------------------------------------------------Page 233-----------------------------------------------------
﻿
NAME

TC50

TC60

TC70

TC75

TC80

ADDRESS

$C20F

$C216

$C223

$C228

$C22B

$C234

$C23E

$C245

$C24A

$C24C

$C254

$C260

DESCRIPTION OF WHAT ROM ROUTINE DOES

Increment .X and use it to set the

lengths of filenames 1 and 2, F1CNT and F2CNT ($0277/8). Filename 2 will default to the same length as filename 1.

Check if PARSE found any wild cards by loading PATFLG ($028A). If any found, set bit 7 (PI) of IMAGE ($028B).

Set pattern flag, PATFLG ($028A) to $00 to prepare for parsing the rest of the

command.

Check if there is any command left to parse by checking the value of .Y set by PARSE. If .Y=0, nothing left so branch to TC75 ($C254) to check structure.

Store value from .Y in filetable, FILTBL

($027A),X. Set the pointer to the start of filename #2, F2PNT ($0279) from the current value of F1CNT ($0277).

Load .A with $8D (shifted CR) and JSR to PARSE ($C268) to parse the rest of the

command. On return increment .X so it

points to the end of the string and put

the value into F2CNT ($0278). Decrement

the value of .X to restore its former value.

Check if any wild cards were found by PARSE in filename 2 by checking the pattern flag, PATFLG ($028A). If any were found, set 3 (P2) of IMAGE ($028B). Check if there was a second filename by checking if .X = F1CNT. If second file name is only 1 chr long, branch to TC70.

Set bit 2 to indicate that the command

implies more than one second file name.

Set bit 1 to indicate that a second

drive is specified and bit 0 to indicate that a second file name is given. EOR this with IMAGE (clears bit 0) and store the result back into IMAGE ($028B). Check IMAGE against the entry for that command (CMD number from CMDNUM, $022A) in the structure table, STRUCT ($FEA5+) If match, syntax is OK; exit with an RTS Store IMAGE in ERWORD ($026C). Load .A

with a $30 to indicate a bad syntax and

exit with a JMP to CMDERR ($C1C8) .

234

-----------------------------------------------------Page 234-----------------------------------------------------
﻿
NAME

PARSE

PR10

PR20

PR25

ADDRESS

$C268

$C26B

$C270

$C278

$C280

$C283

DESCRIPTION OF WHAT ROM ROUTINE DOES

Parse string:

On entry, .A contains the character to be found in the string, .Y points to the the character in the string where the scan is to start, and .X points into the file table, FILTAB,X.

The routine scans the string for special characters "*", "?", and "," as well as the desired character. In scanning the string .Y is used as a pointer to the character in the command string being examined and .X is a pointer into the file table, FILTAB ($027B+) for storing the positions (.Y value) of the start &

end of file names that are found. When a

wild card (* or ?) is found, the pattern flag PATFLG ($028A) is incremented. When a comma is found, its position is noted in the file table, FILTAB and a check is made to ensure that not too many file names are present.

When the special character is found or the end of the command is reached, the

routine ends. If no wild cards have been

found, the pattern type, PATTYP,X is set to $80. Otherwise it is left unchanged. On exit, .Y=0 and the Z flag =0 if the

desired character has not been found. If

it has been found, .Y = the position of the character and the Z flag is set.

Store the desired character in CHAR

($0275).

Start of loop using .Y as a counter to scan the command string. If ,Y is

greater than or equal to the length of the command string, CMDSIZE ($0274), branch to PR30 ($C29E).

Load command string character into .A

and increment .Y counter. Check if it is

the desired character. If it is, branch to PR3 5 ($C2A0).

Check if it is a wild card ("*" or "?").

If not, branch to PR25 ($C283). Increment the pattern flag, PATFLG ($028A) to count the # of wild cards. Check if it is a comma (","). If not, branch back to PR10 to get next command string character.

235

-----------------------------------------------------Page 235-----------------------------------------------------
﻿
NAME

PR28

PR30

PR35

PR40

CMDSET

CS07

ADDRESS

$C287

$C292

$C299

$C29E

$C2A0

$C2AD

$C2B1

$C2B3

$C2B7

$C2BA

$C2C1

$C2CA

DESCRIPTION OF WHAT ROM ROUTINE DOES

Transfer character count from .Y to .A

and store in the file table, FILTAB+1,X ($027B,X) to indicate where the file

name ends. Load .A with the pattern flag PATFLG and AND it with $7F. If the result is zero (no wild cards found),

branch to PR28.

Wild cards were present, so store $80 in PATTYP,X ($E7,X) to indicate this. Also store $80 into PATFLG to zero the count of wild cards but indicate that

there are wild cards in the string. Increment .X (counts number of files &

points into FILTAB) and compare it to $04 (the maximum number of file names allowed in a command string). If the maximum has not been exceeded, branch

back to PR10 to continue the scan.

Load .Y with $00 to indicate that the

desired character was not found.

Store a copy of the command size, CMDSIZ ($0274) into the file table, FILTAB+1,X ($027B,X). Load the pattern flag, PATFLG and AND it with $7F. If the result is 0,

no wild cards have been found so branch to PR40.

Wild cards were present, so store $80 in PATTYP,X ($E7,X) to indicate this.

Transfer character count from .Y to .A.

This sets the Z flag if the desired

character has not been found.

Initialize command tables & pointers Find length of command string and zero all variables and pointers.

Load .Y from BUFTAB+CBPTR ($A3). This is the length of the command that was sent from the computer. If ,Y=0, branch to CS08 ($C2CB).

Decrement .Y and if .Y=0, branch to CS07

($C2CA).

Load .A with the character from the

command buffer, CMDBUF,Y ($0200,Y) and see if it is a carriage return ($0D). If it is, branch to CS08 ($C2CB).

Decrement .Y and load the next character from the command buffer. If this is a

carriage return ($0D), branch to CS08

($C2CB). If not, increment .Y

Increment .Y pointer into command buffer

236

-----------------------------------------------------Page 236-----------------------------------------------------
﻿
NAME

CS08

CMDRST

ADDRESS

$C2CB

$C2D4

$C2DC

DESCRIPTION OF WHAT ROM ROUTINE DOES

Store length of command (.Y) in CMDSIZ ($027B). Compare length (.Y) with the maximum allowable length ($2A) to set the carry flag. Load .Y with $FF. If command length was OK, branch to CMDRST.

Command over-size so set command number

($022A) to $FF, load .A with $32 to

indicate a TOO LONG ERROR and exit with a JMP to CMDERR ($C1C8).

Zero all important variables & pointers:

BUFTAB+CBPTR ($A3) REC

($0258)

FILTBL ENTSEC ENTIND FILDRV PATTYP FILTRK FILSEC

($027A-7F) ($00D8-DC) ($00DD-E1) ($00E2-E6) ($00E7-EB) ($0280-84) ($0285-89)

TYPE

TYPFLG F1PTR F2PTR

PATFLG ERWORD

($024A) ($0296) ($00D3) ($0279) ($028A) ($026C)

ONEDRV

ALLDRS

AD10

SETDRV

$C312

$C320

$C325

$C32A

$C32D

$C335

$C33C

Set first drive & table pointers:

Change pointer to end of the first file name (F1CNT; $0277) to point to the end

of the second file name (use value from F2CNT; $0278). Store $01 in F2CNT and in F2PTR ($0279) to clear these variables

Set up all drives from F2CNT:

Load .Y with last drive used from LSTDRV

($028E) and .X with $00.

Save .X into F1PTR ($D3). Load .A from FILTAB,X ($027A,X) so it points to the start of the Xth file specified in the command string.

JSR to SETDRV ($C33C) to set drive #. On return .Y contains the drive number

specified in the command or the default. NOTE: Bits represent drives (If bit 7 set, use default. Bit 0 = drive #0/1) Recover .X pointer from F1PTR. Store .A in FILTAB,X ($027A,X). Move drive # from .Y to .A and store in FILDRV,X ($027A,X) Increment .X pointer and compare it to F2CNT ($0278) to see if any more files were specified. If more, branch back to AD10 to do the next one. If not, RTS

Set drive # from text or default to 0

On entry and exit .A is an index into

the command buffer.

On entry .Y is the default drive #. On exit it is the drive specified or the

default drive.

237

-----------------------------------------------------Page 237-----------------------------------------------------
﻿
NAME

SD20

SD22

SD24

SD40

SD50

SETANY

SA05

ADDRESS

$C33C

$C33D

$C33F

$C341

$C346

$C34B

$C34C

$C34D

$C34F

$C352

$C355

$C357

$C35B

$C361 $C362

$C368 $C36D $C370

DESCRIPTION OF WHAT ROM ROUTINE DOES

Move pointer into command buffer from

.A to .X

Load .Y with $00 to ensure that the 1541's default drive is ALWAYS DRIVE #0

Load .A with $3A (:) to prepare to hunt for a colon (drive # is just before :). Check for colon in command string at CMDBUF+1,X ($0201,X). Picks up syntax:

X#:FILENAME as in SO:JUNK If found, branch to SD40.

Check for colon in command string at CMDBUF,X ($0200,X). Picks up default drive syntax as in S:JUNK

If colon NOT found, branch to SD40.

Colon found so increment pointer (.X) so it points to the first character in the

filename.

Transfer .Y to .A to set up the default

drive

AND .A with $01 to ensure drive number in ASCII form ($30 or $31) is converted to $00 or $01.

Transfer .A to .Y to restore drive #. Transfer .X to .A to restore index into

command string and exit with an RTS.

Set drive # from command string with the syntax: X#:FILENAME. On entry .X points to the # in the command string.

Load .A with the drive number (in ASCII) from CMDBUF,X ($0200,X).

Increment .X twice so it points to the

first character in the file name.

Compare .A (drive number) to $30 (dr#0). If equal, branch back to SD22 ($C34D) Compare .A (drive number) to $31 (dr#l). If equal, branch back to SD22 ($C34D) If not equal, must be default drive so branch back to SD20 ($C34C).

Set drive # from command string with the syntax: X#,FILE or xx=FILE.

Transfer the drive number from .Y to .A.

OR .A with $80 to set the default drive bit and then AND the result with $81 to mask off any odd bits. Branch back to

SD24 ($C34F) to terminate routine.

Set drive # from any configuration:

Set IMAGE ($028B) to $00.

Load .Y from FILTBL ($027A).

Load .A with the (CB),Y character from the command string and JSR to TST0V1 to

test for a "0" or "1".

238

-----------------------------------------------------Page 238-----------------------------------------------------
﻿
NAME

SA10

SA20

TOGDRV

FS1SET

FS10

ADDRESS

$C371

$C377

$C37D

$C383

$C388

$C38C

$C38F

$C398

$C39D

$C3A2

$C3AC

$C3B0

DESCRIPTION OF WHAT ROM ROUTINE DOES

On return .A contains $00 or $01 if the

drive was specified. If not specified,

.A is $80 or $81. If the drive number was given, branch to SA20 ($C388) .

Increment the pointer into the command string (.Y). Compare the pointer value to the command length (CMDSIZ; $0274) to see if we are at the end. If we are, branch to SA10 ($C383) .

If not "0" or "1", set the pointer (.Y) to the end of the command less one (so

it points to the last character before the RETURN to pick up things like V0) and loop back to SA05 ($C370).

Decrement IMAGE (becomes $FF) to flag a

default drive status and load .A with a $00 to ensure default to 0 on the 1541. AND the drive number in .A with $01, and store the result in the current drive

number, DRVNUM ($7F).

Exit with a JMP to SETLDS ($C100) to turn on the drive active light.

Toggle drive number:

Load .A with current drive number from

DRVNUM ($7F). EOR it with $01 to flip bit #0, AND it with $01 to mask off the bits 1-7, and store the result back in DRVNUM ($7F).

Set pointers to one file stream and check type:

Zero .Y and load .A with the pointer to the end of file name 1 (F1CNT; $02 77) . Compare .A to the pointer to the end of file name 2 (F2CNT; $0278). If equal,

there is no second file so branch to

FS15 ($C3B8).

Decrement F2CNT and load .Y with its

value. Load .A with the pointer to the filetype in the command string from

FILTAB,Y ($027A,Y). Transfer this value to .Y and use it to load the file type into .A from the command string (CB),Y. Load .Y with $04 (the number of file types less 1).

Loop to compare the file type in .A to the list of possible file types,TYPLST,Y

When a match occurs, branch to FS15 ($C3B8). If no match found this time, decrement .Y and, if there are any file types left, loop back to FS10. NOTE: if no match occurs, file assumed to be DEL.

239

-----------------------------------------------------Page 239-----------------------------------------------------
﻿
NAME

FS15

TST0V1

T0V1

OPTSCH

OS10

OS15

OS30

OS35

OS45

ADDRESS

$C3B8

$C3BD

$C3C7

$C3CA

$C3D5

$C3E0

$C3E8

$C3EB

$C3EF

$C3FE

$C400

$C409

$C41B

DESCRIPTION OF WHAT ROM ROUTINE DOES

Transfer file type from .Y to .A and store in TYPFLG ($0296).

Test if character in .A is ASCII 0 or 1:

Compare .A to ASCII "0" ($30) and then

to ASCII "1" ($31). If a match in either case, branch to T0V1.

OR .A with $80 to set bit 7 to indicate

no match was found.

AND .A with $81 to convert ASCII to HEX and preserve bit 7.

Determine optimal search for LOOKUP and

FINFIL:

Zero TEMP ($6F) and DRVFLG ($028D) and push $00 onto the stack. Load .X with value from F2CNT ($0278). Note: TEMP is

the drive mask.

Pull .A from the stack and OR it with

the value in TEMP ($6F). Push the result back onto the stack. Load .A with $01

and store this value in TEMP. Decrement

.X (pointer into file table). If no files left (.X=$FF), branch to $OS30.

Load .A with the drive for the file from

FILDRV,X ($E2,X). If this file uses the default drive (bit 7 set), branch to OS15. Do two ASL's on TEMP ($6F).

Do one LSR on .A. If drive number in .A

was 1, the carry bit is set so branch

back to OS10.

Since drive number was 0, do one ASL on TEMP ($6F) and branch back to OS10.

Pull .A from the stack and transfer this value to .X. Use this value as an index and load .A with a value from the search

table, SCHTBL-1,X ($C43F,X). Push this value onto the stack, AND it with $03, and store the result in DRVCNT ($028C). Pull the original value off the stack and do an ASL. If bit 7 is not set,

branch to OS40.

If bit 7 was set, load A. with the value from FILDRV ($E2).

AND .A with $01 and store the result in DRVNUM ($7F). Load .A with DRVCNT($028C) and if $00, only one drive is addressed

so branch to OS60.

JSR to AUTOI ($C63D) to check the drive

status and initialize it if necessary.

On return, branch to OS70 if the drive

is ready (.A=0).

Drive is not ready so load .A with $74 to indicate the drive is not ready and

JSR to CMDERR ($C1C8).

240

-----------------------------------------------------Page 240-----------------------------------------------------
﻿
NAME

OS50

OS60

OS70

OS45

SCHTBL

LOOKUP

LK05

LK10

LK15

LK20

ADDRESS

$C420

$C42D

$C434

$C439

$C43C

$C440

$C44F

$C452

$C45A

$C45C

$C461

$C462

$C470

$C473

DESCRIPTION OF WHAT ROM ROUTINE DOES

JSR to TOGDRV ($C38F) to switch drives and JSR to AUTOI ($C63D) to check this drive's status and init it if necessary. On return, save the processor status on

the stack. JSR to TOGDRV to switch back

to the first drive. On return, pull the

status back off the stack. If the second

drive is active, branch to OS70.

Since second drive is not active, set DRVCNT ($020C) to $00 to indicate only

one drive addressed and branch to OS70.

JSR to AUTOI ($C63D) to check the drive status and initialize it if necessary. On return, branch to OS45 if the drive is NOT ready (.AO0) .

Teminate routine with a JMP to SETLDS

($C100) to turn on the drive active LEDs

Do a ROL on the value in .A and JMP to OS35 ($C400).

Search Table

BYTES $00, $80, $41

BYTES $01, $01, $01, $01 BYTES $81, $81, $81, $81 BYTES $42, $42, $42, $42

Look up all files in command string in the directory and fill tables with info. JSR to OPTSCH to find optimal search pattern and turn on drive active LEDs. Store $00 in DELIND ($0292), to indicate that we are NOT looking for a deleted or unused directory entry. But, for one or more specific file names. JSR to SRCHST

($C5AC) to start the search process. On return, branch to LK25 if a valid file name was found (Z flag =0)

Since no file name was found, decrement DRVCNT ($028C), the number of drive searches to be made. If any more left

(DRVCNT >= 0), branch to LK15.

Since there are no more drive searches

to be done, exit with an RTS.

Store $01 in DRVFLG ($028D) and JSR to TOGDRV ($C38F) to switch drives. JSR to SETLDS ($C100) to turn on the other LED.

Then JMP back to LK05 to begin the

search on the other drive.

JSR to SEARCH ($C617) to read the next valid file name in the directory.

On return, branch to LK30 to abandon the

search if a valid file name was NOT

found (Z flag = 1).

241

-----------------------------------------------------Page 241-----------------------------------------------------
﻿
NAME

LK25

LK26

LK30

FFRE

FF15

FFST

FF10

FNDFIL

ADDRESS

$C475

$C478

$C47D

$C47E

$C485

$C48A

$C48B

$C48E $C490

$C492

$C49D

$C4A5

$C4A7 $C4AA

$C4AF

$C4B5

DESCRIPTION OF WHAT ROM ROUTINE DOES

JSR to COMPAR ($C4D8) to compare the

list of files found with list of those

required. On return, FOUND ($028F) is 0

if all files have NOT been found.

Load .A with the value from FOUND. If

not all the files have been found yet,

branch to LK26 to continue the search. All files have been found so exit from the routine with an RTS.

Load .A with the value from ENTFND

($0253) to check if the most recent

compare found a match. If not (.A=$FF), branch to LK20 to search directory for

another valid file name. If a match was

found, branch back to LK25 to try again.

Load .A with the value from FOUND. If

not all the files have been found yet,

branch to LK10 to continue the search. All files found so exit with an RTS.

Find next file name matching any file in stream & return with entry stuffed

into tables:

JSR to SRRE ($C604) to set up and read in the next block of directory entries. If no files found, branch to FF10. If files were found, branch to FF25.

Store $01 in DRVFLG ($028D) and JSR to TOGDRV ($C38F) to switch to the other drive. JSR to SETLDS ($C100) to turn on the new drive active light.

Find starting entry in the directory: Store $00 in DELIND ($0292), to indicate that we are NOT looking for a deleted or unused directory entry. But, for one or more specific file names. JSR to SRCHST

($C5AC) to start the search process. On return, branch to FF25 if a valid file name was found (Z flag =0) Store .A value in FOUND ($028F).

Load .A from FOUND ($028F). If non-zero,

all files found so branch to FF40 & exit

Since there is nothing more on this drive, decrement DRVCNT by 1. If any more drives left, branch to FF15 to try the other drive. If none left, do an RTS

Continue scan of directory:

JSR to SEARCH ($C617) to retrieve the

next valid file name from the directory.

242

-----------------------------------------------------Page 242-----------------------------------------------------
﻿
NAME

FF25

FF30

FF40

COMPAR

CP02 CP05

CP10

ADDRESS

$C4B8

$C4BA

$C4BD

$C4C7

$C4C9

$C4CE

$C4D7

$C4D8

$C4E6 $C4E7

$C4EC

$C4F3

DESCRIPTION OF WHAT ROM ROUTINE DOES

On return, branch to FF10 if no more

entries available on this drive.

JSR to COMPAR ($C4D8) to see if any of

the names found match the ones needed.

On return, load .X from ENTFND ($0253). If a match on a name was found (.X<128), branch to FF30 to check the file type. If no match found (.X>127), load .A with the value from FOUND($028F) to check if all files have been found. If not(.A=0),

branch back to FNDFIL to load another

name from the directory.

If .AO0, all files have been found so

branch to FF40 and exit with an RTS.

Check the file type flag, TYPFLG($0296). If it is $00, there is no file type

restriction so branch to FF40 and exit.

Load the file pattern type from PATTYP,X ($E7,X), AND it with the file type mask #$07, and compare it to the value in

TYPFLG ($0296). If the file types do not match, branch back to FNDFIL to continue

the search.

Terminate the routine with an RTS.

Compare all file names in command list with each valid entry in directory. Any matches are tabulated.

Set the found-entry flag, ENTFND ($0253) to $FF and zero the pattern flag PATFLG ($028A). JSR to CMPCHK ($C589) to check

the file table for unfound files. If

there are unfound files (Z flag = 1), branch to CP10 to begin comparing.

Terminate routine with an RTS.

JSR to CC10 ($C594) to set F2PTR ($0279) to point to the next file needed on this drive. On return, branch to CP02 to exit

if no more files needed on this drive. Load .A with the current drive number

from DRVNUM ($7F) and EOR it with the

drive number specified for the file,

FILDRV,X ($E2,X). LSR the result. If the carry flag is clear, the drive number is

correct for this file so branch to CP20

to find the name in the directory list.

AND the value in .A with $40 to check if we are to use the default drive (NOTE: $40 rather than $80 because of the LSR). If we can not use the default drive, branch back to CP05 to set up the next

file name on our list of files needed.

243

-----------------------------------------------------Page 243-----------------------------------------------------
﻿
NAME

CP20

CP30

CP32

ADDRESS

$C4F7

$C4FE

$C502

$C50A

$C511

$C515

$C51B

DESCRIPTION OF WHAT ROM ROUTINE DOES

Compare DRVCNT ($028C) with $02. If

equal, don't use default drive so branch

back to CP05.

At this point we have a match on the drive numbers so check the directory

entries to see if we can match a name.

Load .A with the pointer to the position of the required file name from FILTBL,X ($027A,X) and transfer this value to .X.

JSR to FNDLMT to find the end of the

command string. On return, load the pointer into the directory buffer (.Y) with $03 (so it points past the file type, track and sector) and JMP to CP33. Compare the .Xth character in the

command string (the required filename) with the .Yth character in the directory buffer (the directory entry). If equal, branch to CP32 to set up for the next

character.

No exact match so check if the command buffer character is a "?" which will

match any character. If not, branch to to CP05 to try the next file name.

Compare the character we just used from the directory buffer with $A0 to see if

we've reached the end of the name. If

we have, branch to CP0 5 to try the next

file name.

Increment .X and .Y

CP33

$C51D

Compare .X with the length of

the

command string, LIMIT ($0276) at the end, branch to CP34.

. If

we are

$C522

Check if the new character in

name, CMDBUF,X ($0200,X) is a

is, it matches everything so

CP40 to tabulate this match.

the file

"*". If it

branch to

CP34

CP40

$C529

$C52B

$C52F

$C535

$C53B

If not a "*", branch to CP30 to keep on matching.

Compare .Y to $13 to see if we are at the end of the name in the directory.

If we are, branch to CP40 to tabulate. If not at the limit, check the character

in the directory entry name. If it isn't an $A0, we did not get to the end of the name so branch back to CP05 to try again The filenames match so keep track of it by storing the pointer to the entry from F2PNT ($0279) into ENTFND ($0253).

Get the file type pattern ($80,$81,etc) from PATTYP,X ($E7,X), AND it with $80,

and store it in PSTFLG.

244

-----------------------------------------------------Page 244-----------------------------------------------------
﻿
NAME

CP42

ADDRESS

$C542

$C547

$C54B

$C55A $C55C

$C562

$C56A

$C572

$C578

$C57D

$C582

DESCRIPTION OF WHAT ROM ROUTINE DOES

Get the pointer to the directory entry

from INDEX ($0294) and store it in the entry index, ENTIND,X ($DD,X).

Get the sector on track 18 on which the

entry is stored from SECTOR ($81) and store it in, ENTSEC,X ($D8,X).

Zero .Y and load .A with the file type of this directory entry from (DIRBUF),Y ($94),Y. Increment .Y. Save the type on the stack. AND the type with $40 to see if this is a locked file type, and store

the result in TEMP ($6F). Pull the file

type off the stack and AND it with $DF ($FF-$20). If the result is > 127 (the replacement bit not set), branch to CP42 OR the result with $20.

AND the result with $27 and OR it with the value stored in TEMP ($6F) and store the final result back in TEMP.

Load .A with $80, AND .A with the file pattern type from PATTYP,X ($E7,X), OR the result with the value in TEMP ($6F),

and store the final result back in PATTYP,X.

Load .A with the file's drive number

from FILDRV,X ($E2,X). AND it with $80 to preserve the default drive bit, OR it with the current drive number, DRVNUM ($7F) and store the result back into

FILDRV,X ($E2,X).

Move the file's first track link from

(DIRBUF),Y(.Y=1) to FILTRK,X ($0280) and

increment .Y.

Move the file's first sector link from

(DIRBUF),Y(.Y=2) to FILSEC,X ($0285). Check the current record length, REC ($0258). If NOT $00, branch to CMPCHK. Set .Y to $15 and move the file entry's record size from (DIRBUF),Y to REC.

CMPCHK

CC10

CC15

$C589

$C594

$C59A

Check table for unfound

Set all-files-found flag to $FF. Move the number from F2CNT ($0278) to F2

Decrement the file count

If any files left, branc If none left, exit with

Load .X with the number test from F2PTR. Load .A

pattern type from PATTYP

file has not been found

still set) abort search

files

, FOUND ($028F)

of files to test

PTR ($0279).

, F2PTR ($0279).

h to CC15. an RTS.

of the file to with the file's

,X ($E7,X). If yet (bit 7 is

by branching to

CC20.

245

-----------------------------------------------------Page 245-----------------------------------------------------
﻿
NAME

CC20

SRCHST

SR10

SR15

SR20

ADDRESS

$C5A6

$C5AC

$C5B5

$C5C1

$C5C4

$C5C9 $C5CA

$C5CF

$C5D7

DESCRIPTION OF WHAT ROM ROUTINE DOES

Load .A with the file's first track link from FILTRK,X ($0280,X). If non-zero, the file has been found, so branch back

to CC10 to test the next file.

Load .A with $00 and store it in the

all-files-found flag, FOUND ($028F) to

indicate that all files have NOT been found and exit with an RTS.

Initiate search of directory:

Returns with valid entry (DELIND=0) or with the first deleted entry (DELIND=1) Load .Y with $00 and store it in DELSEC. ($0291) . Decrement .Y to $FF and store

it in the found-an-entry flag, ENTFND

($0253) .

To start search at the beginning of the directory, set TRACK ($80) to $12 (#18) (from $FE79) and SECTOR ($81) to $01. Also store $01 in last-sector-in-file flag, LSTBUF ($0293).

JSR to OPNIRD ($D475) to open the

internal channel (SA=16) for a read and

to read in the first one or two sectors

in the file whose T/S link is given in TRACK ($80) and SECTOR ($81).

Test LSTBUF ($0293) to see if we have

exhausted the last sector in the

directory file. If not (LSTBUF <> $00),

branch to SR15.

Exit with an RTS.

Set the file count, FILCNT ($0295) to $07 to indicate that there are 8 entries

(0-7) left to examine in the buffer. Load .A with $00 and JSR to DRDBYT to

read the first byte in the sector (the

track link). On return store this value into LSTBUF ($0293). This sets LSTBUF to $00 if there are no more blocks left in

in the directory file.

JSR to GETPNT ($D4E8) to set the

directory pointer, DIRBUF ($94/5) to the data that was just read into the active buffer, BUFTAB,X ($99/A,X).

NOTE: DIRBUF does NOT point to the start of the data buffer ($0300, $0400,...). It points to the first data byte ($0302, $0402,...). As the entries are examined, it is update to point to the start of the entry ($0x02, $0x22, $0x42,...).

246

-----------------------------------------------------Page 246-----------------------------------------------------
﻿
NAME

SR30

SRRE

ADDRESS

$C5DA

$C5DF

$C5E3

$C5E8

$C5F0

$C5F8

$C5FA

$C5FB

$C602

$C604

$C60E

$C611

DESCRIPTION OF WHAT ROM ROUTINE DOES

Decrement the entry count, FILCNT and load .Y with $00 to begin examination of the first directory entry.

Test the entry's file type in (DIRBUF),Y If non-zero, this is NOT a deleted or blank entry so branch to SR30.

Process a scratched or blank entry

Test DELSEC ($0291) to see if a deleted entry has already been found. If it has (DELSEC <> $00), branch to SEARCH($C617) This is first deleted entry so JSR to CURBLK ($DE3B) to set up the current sector in SECTOR ($81). Save the sector number in DELSEC ($0291).

Load .A with the low byte of the pointer to the start of this entry (its position in the data buffer) from DIRBUF ($94) .

Load .X with the current value of DELIND

($0292). This sets the Z flag to 1 if

only valid entries are desired.

Store the pointer in .A into DELIND. If the Z flag is set, we need valid

entries, not deleted ones, so branch to

SEARCH to continue the search.

We wanted a deleted entry and we found

one so terminate routine with an RTS.

We have found a valid entry. Check if we are looking for one by comparing DELIND ($0292) to $01. If not equal, we want a

valid entry so branch to SR50.

If DELIND = 1, we want a deleted entry, not a valid one, so branch to SEARCH to continue the quest!

Re-enter the directory search:

Set TRACK ($80) to $12 (#18) from $FE85 Set SECTOR ($81) from the last directory

sector used, DIRSEC ($0290) .

JSR to OPNIRD ($D475) to open the

internal channel (SA=16) for a read and

to read in the first one or two sectors

in the file whose T/S link is given in

TRACK ($80) and SECTOR ($81) .

Load .A with the pointer INDEX ($0294) that points to the start of the last entry we were examining and JSR to

SETPNT ($D4C8) to set the DIRPNT ($94/5) to point to the start of the entry.

247

-----------------------------------------------------Page 247-----------------------------------------------------
﻿
NAME

SEARCH

SR40

SR50

AUTOI

ADDRESS

$C617

$C621

$C629

$C62F

$C634

$C637

$C63C

$C641

$C647

$C64C

$C64F $C651

$C655

$C659

$C65D

DESCRIPTION OF WHAT ROM ROUTINE DOES

Continue search of entries:

Set found-entry flag, ENTFND ($0253) to

$FF. Load .A with number of entries left in the buffer from FILCNT ($0295) . If none left, branch to SR40 to get the next buffer of directory entries.

There is at least one more entry left in

this buffer so load .A with $20� (the #

of characters in each entry) and JSR to INCPTR ($D1C6) to set DIRPTR ($94/5) to point to the start of the next entry. JMP to SR20 ($C5D7) to process it.

Get next buffer of entries:

JSR to NXTBUF ($D44D) to read in the next directory sector and JMP to SR10 to begin processing it.

We have found a valid entry so save how far we got and return.

Save low byte of the pointer to the

entry, from DIRBUF($94) in INDEX($0294). JSR to CURBLK ($DE3B) to store the

sector we are checking in SECTOR ($81) .

Save the current sector number from

SECTOR ($81) in DIRSEC ($0290) and RTS.

Check drive for active diskette, init

if needed. Return no drive status.

Test auto-initialization flag, AUTOFG ($68). If AUTOFG <> 0, auto-init is disabled so branch to AUT02 ($C669).

Load .X with the current drive number from DRVNUM ($7F). Test whether the

diskette has been changed by doing an LSR on the write-protect-change flag for the current drive, WPSW,X ($1C/D). If the carry flag, C, is clear, the disk has not been changed so branch to AUT02.

Load .A with $FF. Store this value as

the job return code in JOBRTN ($0298).

JSR to ITRIAL ($D00E) to do a SEEK to

the current drive to determine if a

diskette is present.

Load .Y with $FF (default to true).

Compare the value in return job code in .A with $02. If equal, NO SYNC was found

so branch to AUTOI to abort.

Compare the value in return job code in .A with $03. If equal, NO HEADER was

found so branch to AUTOI to abort.

Compare the value in return job code in

.A with $0F. If equal, NO DRIVE was

found so branch to AUTOI to abort. Seems OK so load .Y with $00.

248

-----------------------------------------------------Page 248-----------------------------------------------------
﻿
NAME

AUTOI

AUT02

TRNAME

TN10

TN20

TRCMBF

TRIO

TR20

ADDRESS

$C65F

$C666

$C669

$C66E

$C66F

$C672

$C675

$C67A

$C67F

$C681

SC687

$C688 $C68B

$C697

$C69C

$C69F

$C6A5

DESCRIPTION OF WHAT ROM ROUTINE DOES

Load .X with the current drive number DRVNUM ($7F). Transfer the value of ,Y into .A ($00 if OK;$FF if BAD) and store in the current drive status, NODRV,X ($FF,X). If status is bad (not $00),

branch to AUT02 to abort.

JSR to INITDR ($D042) to initialize the

current drive.

Load .A with the current no-drive status and terminate routine with an RTS.

NOTE: Z flag set if all is OK.

Transfer filename from CMD to buffer:

On entry, .A=string size; .X=starting index in command string; .Y=buffer # Save .A (string size) on the stack.

JSR to FNDLMT ($C6A6) to find the limit of the string in the command buffer that is pointed to by .X.

JSR to TRCMBF ($C688) to transfer the

command buffer contents from .X to LIMIT to the data buffer whose number is in .Y

Restore the string size into .A from the stack. Set the carry flag and subtract the maximum string size, STRSIZ ($024B).

Transfer the result from .A to .X. If

the result is 0 or negative, the string does not need padding so branch to TN20. String is short and needs to be padded so load .A with $A0.

Loop to pad the string in the directory

buffer with .X $A0's.

Terminate routine with an RTS.

Transfer CMD buffer to another buffer: .X=index to first chr in command buffer LIMIT=index to last chr+1 in CMD buffer

.Y=buffer#. Uses current buffer pointer.

Multiply .Y by 2 (TYA;ASL;TAY).

Use current buffer pointers, BUFTAB,Y ($99/A,Y) to set the directory buffer

pointers, DIRBUF ($94/5) .

Zero .Y (index into directory buffer) Move character from CMDBUF,X ($0200,X) to (DIRBUF),Y ;($94),Y.

Increment .Y. If .Y equals $00, branch

to TR20 to abort.

Increment .X. If .X < LIMIT ($0276)

branch back to TRIO to do next character Terminate routine with an RTS.

249

-----------------------------------------------------Page 249-----------------------------------------------------
﻿
NAME

FNDLMT

FL05

FL10

GETNAM

ADDRESS

$C6A6

$C6AD

$C6B0

$C6B4

$C6B8 $C6BC

$C6C3

$C6C8

$C6CB

$C6CD

$C6CE

$C6D1

$C6D4

$C6D7

$C6DD

DESCRIPTION OF WHAT ROM ROUTINE DOES

Find the limit(end) of the string in the command buffer that is pointed to by X Zero the string size, STRSIZ ($024B). Transfer the starting pointer from .X

to .A and save it on the stack.

Load .A with the Xth command string character, CMDBUF,X ($0200,X).

Compare the character to a ",". If they

match, we're at the end. Branch to FL10.

Compare the character to a "=". If they

match, we're at the end. Branch to FL10. Increment STRSIZ ($024B) and .X

Check if the string size, STRSIZ, has reached the maximum size of $0F (#15) . If it has, branch to FL10 to quit.

Compare .X to the pointer to the end of the command string, CMDSIZ ($0274). If

we're NOT at the end. Branch to FL05. Store the .X value (the last character

plus 1) into LIMIT ($0276).

Pull the original .X value off the stack

into .A and transfer it to .X Terminate routine with an RTS.

Get file entry from directory: (called by STDIR and GETDIR)

Save secondary address, SA ($83) on the

stack.

Save the current channel*, LINDX ($82)

on the stack.

JSR to GNSUB ($C6DE) to get a directory entry using the internal read channel

SA=$11(#17).

Pull the original SA and LINDX values

from the stack and reset these variables Terminate the routine with an RTS.

Get file entry subrout

me:

GNSUB

$C6DE

$C6E2

$C6E5

$C6E8

$C6ED

Set current secondary to $11 (internal read JSR to FNDRCH ($D0EB)

read channel.

JSR to GETPNT ($D4E8) directory buffer point from the pointer to th buffer using values fr Test the found entry f

to see if there are mo

are more (ENTFLG > 127

No more entries so tes to see if we have the

If DRVFLG <> 0, branch the other drive.

250

address, SA ($83) secondary address)

to find an unused

to set the

er, DIRBUF ($94/5) e currently active om BUFTAB ($30/1). lag, ENTFLG($0253)

re files. If there ), branch to GN05. t DRVFLG ($028D)

other drive to do.

to GN050 to do

-----------------------------------------------------Page 250-----------------------------------------------------
﻿
NAME

GN0 5

GN0 5 0

GN0 51

GN10

GN12

ADDRESS

$C6F2

$C6F5

$C6F7

$C6FC

$C701 $C704 $C707

$C70A

$C70E

$C716

$C719

$C71B

$C71D

$C71F

$C726

$C728

$C729

$C72E

$C732

$C736

$C737

$C73B

DESCRIPTION OF WHAT ROM ROUTINE DOES

JSR to MSGFRE ($C806) to send the BLOCKS FREE message.

Clear carry bit and exit with an RTS.

Test drive flag, DRVFLG ($028D). If $00,

branch to GN10.

Decrement drive flag, DRVFLG ($028D). If not $00, branch to GN051 to do a new directory.

Decrement drive flag, DRVFLG ($028D). JSR to TOGDRV ($C38F) to switch drives. JSR to MSGFRE ($C806) to send the BLOCKS FREE message.

Set the carry flag and exit with a JMP

to TOGDRV ($C38F) to switch drives.

Load .A with $00 and zero the hi byte of the number of blocks counter, NBTEMP+1 ($0273) and the drive flag DRVFLG($028D) JSR to NEWDIR ($C7B7) to begin a new directory listing.

Set the carry flag and exit with an RTS.

Load .X with $18 (#24), the length of an entry in a directory listing

e.g." 114 "PROGRAM FILENAME" PRG

Load .Y with $1D, the position of the hi byte of the # of blocks in the file. Load .A with the hi byte of the # of

blocks in the file. Store this into the

hi byte of the block counter, NBTEMP+1

($0273). If zero, branch to GN12.

Load .X with $16 (#22) the directory

length less 2.

Decrement Y so it points to the position of the lo byte of the # of blocks in

the file.

Load .A with the lo byte of the # of

blocks in the file. Store this into the

lo byte of the block counter, NBTEMP

($0272).

Compare .X to $16 (#22) the directory length less 2. If they are equal, branch

to GN14.

Compare .A (the lo byte of the blocks)

with $0A (#10). If .A<10 branch to GN14 Decrement .X (we will need less padding since # of blocks is at least 2 digits. Compare .A (the lo byte of the blocks) with $64 (#100). If A<100 branch to GN14 Decrement .X (we will need less padding since # of blocks is at least 3 digits.

251

-----------------------------------------------------Page 251-----------------------------------------------------
﻿
NAME

ADDRESS

DESCRIPTION OF WHAT ROM ROUTINE DOES

GN14 $C73C JSR to BLKNB ($C7AC) to clear the name

buffer for the next entry. On return Y=0 $C73F Load .A with the file type from the directory buffer (DIRBUF),Y and save the file type onto the stack.

$C742 Do an ASL of the value in .A to set the

carry bit if this is a valid file that

has not been closed, (see BCS $C764) $C7Ai if ,A<128, branch to GN15.

NOTE: The branch at $C742 and the code following is what produces the PRG<, SEQ<, etc. file types. Note that these file types are LOCKED and can't be SCRATCHED!

The locking and unlocking of files is by any Commodore DOS. To lock a file, file type in its directory entry from to $C0, $C1, etc. Reverse the process
 NOT supported change its

$80, $81, etc for unlocking

GN15

$C745 $C747

$C74A

$C74E

$C754 $C755

$C75B $C75C

$C762 $C764

$C766

Load .A with a $3C (a "<").

Store this value into the name buffer

NAMBUF+1,X ($02B1,X).

Pull the file type off the stack and AND it with $0F to mask off the higher bits.

Transfer it to .Y to use as an index.

Move last character in file type name from TP2LST,Y ($FEC5,Y) to the name buffer, NAMBUF,X ($02B1,X).

Decrement .X

Move middle character in file type name from TP1LST,Y ($FEC0,Y) to the name buffer, NAMBUF,X ($02B1,X).

Decrement .X

Move first character in file type name from TYPLST,Y ($FEBB,Y) to the name buffer, NAMBUF,X ($02B1,X).

Decrement .X twice

If carry bit is set (indicates valid entry; see $C742) branch to GN20.

Load .A with $2A (a "*") to indicate an

improperly closed file.

$C768

Store

the

in NAMBUF+1,X ($02B1,X)

GN20

GN2 2

$C76B

$C771

$C773

$C77E $C780

Store a shifted space, $A0 in the buffer (between name & type) and decrement .X Load .Y with $12 (#18) so it points to

the end of the name in the dir buffer.

Loop to transfer the 16 characters in the file name from the directory buffer

to the name buffer.

Load .A with $22 (a "" )

Store quotation mark before the name.

252

-----------------------------------------------------Page 252-----------------------------------------------------
﻿
NAME

ADDRESS
 DESCRIPTION OF WHAT ROM ROUTINE DOES

GN3 0

GN40

GN45

$C783

$C7A7

$C7AB

Loop to scan up

quote mark($22)

When either cha end of the name

(quote mark) at any remaining c with $7F to cle JSR to FNDFIL ( entry. On retur

Terminate the r

the name looking for a or a shifted space($A0).

racter is found or the

is reached, store a $22

that location. Then AND haracters in the name ar bit 7 for each one.

$C4B5) to find the next n, set the carry bit.

outine with an RTS.

BLKNB

BLKNB1

NEWDIR

ND10

ND15

ND20

$C7AC

$C7B0

$C7B6

$C7B7

$C7BA

$C7BD

$C7C0 $C7C4

$C7C9 $C7CE

SC7D0

$C7D5

$C7DA $C7DC

$C7E2

$C7E4 $C7E5

$C7EB

$C7ED

Blank the name buffer:

Load .Y with $1B, the length of the name buffer, and .A with $20, a space.

Loop to store $20's in all locations in

the name buffer, NAMBUF ($02B1-CB)

Terminate the routine with an RTS.

New directory in listing

JSR to BAM2X ($F119) to set BAM pointer

in buffer 0/1 tables and leave in .X

JSR to REDBAM ($F0DF) to read in the BAM to $0700-FF if not already present. JSR to BLKNB ($C7AC) to blank the name buffer, NAMBUF ($02B1-CB). Set TEMP ($6F) to $FF

Set NBTEMP ($0272) to the current drive number from DRVNUM ($7F)

Set NBTEMP+1 ($0273) to $00

Load .X with the position of the read BAM job in the queue from JOBNUM ($F9). Set high byte of the pointer to the

directory buffer, DIRBUF ($94/5) using a value (3,4,5,6,7,7) from BUFIND,X($FEE0) Set low byte of the pointer to the

directory buffer, DIRBUF ($94/5) using the value ($90) from DSKNAM ($FE88). DIRBUF now points to the start of the

disk name in the BAM buffer ($0x90)

Load .Y with $16 (#22), the name length. Load .A with character, (DIRBUF),Y and test if it is a shifted blank ($A0). If not, branch to ND20.

Since it is not a shifted blank, load .A with a $31 (ASCII "1") for version #1. BYTE $2C here causes branch to ND20. Load .A with character, (DIRBUF),Y and test if it is a shifted blank ($A0). If not, branch to ND20.

Since it is not a shifted blank, load .A with a $20 (ASCII space).

Store the character in .A into the name buffer, NAMBUF+2,Y ($02B3,Y).

253

-----------------------------------------------------Page 253-----------------------------------------------------
﻿
NAME

MSGFRE

FREMSG

ADDRESS

$C7F1

$C7F3 $C7F8 $C7FD $C800 $C805

$C806

$C809 $C80B

$C814

$C817

DESCRIPTION OF WHAT ROM ROUTINE DOES

If more characters left (.Y>=0) branch

back to ND15.

Store a $12 (RVS on) in NAMBUF ($02B1)

Store a $22 (quote) in NAMBUF+1 ($02B2) Store a $22 (quote) in NAMBUF+18($02C3) Store a $20 (space) in NAMBUF+19 ($02C4)

Terminate routine with an RTS.

Set up message "BLOCKS FREE"

JSR to BLKNB ($C7AC) to clear the name

buffer.

Load .Y with $0B (message length -1). Loop using .Y as index to move message from FREMSG,Y ($C817,Y) to NAMBUF,Y

($02B1,Y).

Terminate routine with a JMP to NUMFRE

($EF4D) to calculate the number free.

Message "BLOCKS FREE"

_ * _ *

SCRATCH ONE OR MORE FILES

_ * _ * _

SCRTCH

$C823

$C826

$C829

$C82C $C830

JSR to FS1SET ($C398) to set up for one

file stream.

JSR to ALLDRS ($C320) to all drives

needed based on F2CNT.

JSR to OPTSCH ($C3CA) to determine best sequence of drives to use. Zero file counter, R0 ($86)

JSR to FFST ($C49D) to find the first

directory entry. If not successful,

branch to SC30.

NOTE: THE FOLLOWING CODE PREVENTS FREEING THE SECTORS

OF AN UNCLOSED FILE.

SC15

$C835

$C838

JSR to TSTCHN ($DDB7) to test for active

files from index table.

If file active (carry clear), branch to

SC25.

NOTE: THE FOLLOWING CODE PREVENTS THE SCRATCHING OF

A LOCKED FILE (BIT 6 OF THE FILE TYPE SET).

$C83A $C83C

$C83E

$C840

$C842

Load .Y with $00.

Load .A with file type from (DIRBUF),Y

($94,Y).

AND the file type with $40 to test if it is a locked file (bit 6 of filetype set) If a locked file, branch to SC25.

JSR to DELDIR ($C8B6) to delete the

directory entry. Stores $00 as the file type and rewrite the sector on disk.

254

-----------------------------------------------------Page 254-----------------------------------------------------
﻿
NAME

ADDRESS
 DESCRIPTION OF WHAT ROM ROUTINE DOES

$C845 Load .Y with $13 (#19).

$C847 Test whether this is a relative file by

loading .A with 19th character of the entry (the track of the side-sector

pointer for a REL file) from (DIRBUF),Y

$C849 If $00, not a REL file so branch to SC17 $C84B Store track pointer into TRACK ($80). $C84D Increment .Y and move sector pointer

from (DIRBUF),Y into SECTOR ($81).

$C852 JSR to DELFIL ($C87D) to free the side

sectors by updating and writing the BAM

NOTE: THE FOLLOWING CODE PREVENTS FREEING THE SECTORS

OF A FILE IF ITS REPLACEMENT WAS INCOMPLETE (BIT 5 SET)

SC17

SC20 SC25

SC30

$C855

$C85A

$C85C

$C85E

$C863

$C868

$C86B $C86D

$C870

$C872

$C876 $C87A

Load .X with the directory entry counter ENTFND ($0253) and .A with $20.

AND .A with the file pattern type in PATTYP,X ($E7,X) to check if this is an opened but unclosed file.

If unclosed file, branch to SC20.

Move initial track link from FILTRK,X

($0280,X) into TRACK ($80).

Move initial sector link from FILSEC,X

($0285,X) into SECTOR ($81).

JSR to DELFIL ($C87D) to free the file blocks by updating and writing the BAM Increment the file counter, R0 ($86). JSR to FFRE ($C48B) to match the next filename in the command string. If a match found, branch to SC15

All done. Store number of files that have been scratched, R0 ($86) into TRACK ($80)

Load .A with $01 and .Y with $00 Exit with a JMP to SCREND ($ClA3)

Delete file by links

DELFIL

$C87D

$C880

$C883

$C886

JSR to FRETS ($EF5F) file block as free i JSR to OPNIRD ($D475

internal read channe in the first one or

JSR to BAM2X ($F119)

in the buffer tables

Load .A from BUF0,X it to $FF to see if If inactive (.A=$FF) Load write BAM flag, with $40 to set bit in WBAM to indicate

255

to mark the first

n the BAM.

) to open the

1 (SA=17) and read

two blocks.

to set BAM pointers

($A7,X) and compare

buffer inactive.

, branch to DEL2

WBAM ($02F9), OR it

6 and store it back both buffers active.

-----------------------------------------------------Page 255-----------------------------------------------------
﻿
NAME

ADDRESS

DESCRIPTION OF WHAT ROM ROUTINE DOES

DEL2

DELI

$C894

$C899

$C89C $C89E

$C8A1 $C8A3

$C8A7 $C8AA

$C8AD

Zero .A and JSR to

pointers to the cur JSR to RDBYT ($D156

byte (the track lin

Store track link in JSR to RDBYT ($D156 byte (the sector li

Store sector link i Test track link. If sector in this file JSR to MAPOUT ($EEF Exit with a JMP to free the internal r

JSR to FRETS($EF5F)

specified in TRACK

SETPNT($D4C8) to set rently active buffer. ) to direct read one

k from the buffer) to TRACK ($80)

) to direct read one nk from the buffer) nto SECTOR ($81)

not $00 (not final ), branch to DELI

4) write out the BAM. FRECHN ($D227) to

ead channel.

to de-allocate(free) ;$80) & SECTOR ($81)

DELDIR

$C8B0

$C8B3

$C8B6

$C8B8

$C8BB

$C8BE

in the BAM.

JSR to NXTBUF ($D44D) to read in the next block in the file (use T/S link).

JMP to DEL2 to de-allocate the new block

Delete the directory entry:

Load .Y with $00 (will point to the Oth character in the entry; the file type). Set the file type, (DIRBUF),Y; ($94),Y to $00 to indicate a scratched file. JSR to WRTOUT ($DE5E) to write out the

directory block.

Exit with a JMP to WATJOB ($D59 9) to wait for the write job to be completed.

DUPLICATE DISK
 NOT AVAILABLE ON THE 1541

$C8C1

Load .A with a $31 to indicate a bad command and JMP to CMDERR ($C1C8).

_ * _ * _

FORMAT DISKETTE ROUTINE

_ * _ *

This routine sets up a jump instruction in buffer 0 that points to the code used by the disk controller to do the formatting. It then puts an exectute job code in the job queue. The routine then waits while the disk controller actually does the formatting.

FORMAT

$C8C6

$C8D5

$C8DA

Store JMP $FABB ($4C,$BB,$FA) at the start of buffer 0 ($0600/1/2).

Load .A with $03 and JSR to SETH ($D6D3) to set up header of active buffer to the

values in TRACK ($80) and SECTOR ($81) . Load drive number, DRVNUM ($7F), EOR it with $E0 (execute job code) and store the result in the job queue ($0003).

256

-----------------------------------------------------Page 256-----------------------------------------------------
﻿
NAME

ADDRESS
 DESCRIPTION OF WHAT ROM ROUTINE DOES

FMT105 $C8E0 Load .A from the job queue ($0003) . If

.A > 127, the job has not been finished

yet so branch back to FMT105.

$C8E4 Compare .A with $02. if .A < 2, the job

was completed OK so branch to FMT110.

$C8E8 Error code returned by disk controller

indicates a problem so load .A with $03

and .X with $00 and exit with a JMP to ERROR ($E60A).

KMT'MO $C8EF Job completed satisfactorily so exit

with an RTS.

_ * _ * _

COPY DISK FILES ROUTINE

DSKCPY

$C8F0

$C8F5

$C8F8

$C8FB

$C8FF

$C904

$C907

$C909

Store $E0 in BUFUSE

BAM buffer.

JSR to CLNBAM ($F0D1

sector links in BAM

JSR to BAM2X ($F119)

LINDX in .X.

Store $FF in BUF0,X BAM as out-of-memory Store $0F in LINUSE

LINDXs.

JSR to PRSCLN ($C1E5 command string and f If colon found (Z fl

DX0000.

Colon not found in c command must be CX=Y

not supported on the a JMP to DUPLCT ($C8

($024F) to kill the

) to set track and to $00.

to return the BAM

($A7,X) to mark the

($0256) to free all

) to parse the

ind the colon.

ag =0), branch to

ommand string so

. This command is 1541 so exit with

CI) .

DX0000

DX0005

DX0010

$C90C

$C90F

$C912

$C919

$C91F

$C923

JSR to TC30 ($C1F8) to parse the command string.

JSR to ALLDRS ($C320) to put the drive

numbers into the file table.

Load .A with the command pattern image as determined by the parser from IMAGE ($028B). AND the image with %01010101 ($55). If the result is not $00, the

command must be a concatenate or normal

copy so branch to DX0020.

Check for pattern matching in the name (as in cl:game=0:*) by loading .X from FILTBL ($027A) and then loading .A from the command string, CMDBUF,X ($0200,X). The value in .A is compared to $2A ("*") If there is no match, there is no wild

so branch to DX0020.

Load .A with the $30 to indicate a

syntax error and JMP to CMDERR ($C1C8).

257

-----------------------------------------------------Page 257-----------------------------------------------------
﻿
NAME
 ADDRESS

DESCRIPTION OF WHAT ROM ROUTINE DOES

DX0020 I $C928

$C92F

Load .A with the command pattern image as determined by the parser from IMAGE ($028B). AND the image with %11011001 ($D9). If the result is not $00, the syntax is bad so branch to DX0010 and

abort.

JMP to COPY ($C952) to do the file copy. syntax error and JMP to CMDERR ($C1C8).

PUPS1

COPY

$C932

$C952

$C955

$C95C

$C962

$C968

Subroutine used to set up for copying entire disk (C1=0). Not used on 1541.

Copy file(s) to one file:

JSR to LOOKUP ($C44F) to look up the file(s) listed in the command string in the directory.

Load .A with the number of filenames in

the command string from F2CNT($0278) and compare it with $03. If fewer than three files, this is not a concatenate so branch to COP10 ($C9A1).

Load .A with the first file drive number

from FILDRV ($E2) and compare it to the second drive number in FILDRV+1 ($E3).

If not equal, this is not a concatenate

so branch to COP10 ($C9A1).

Load .A with the index to the first file

entry from ENTIND ($DD) and compare it

to the second file's index in ENTIND+1

($DE). If not equal, this is not a

concatenate so branch to COP10 ($C9A1).

Load .A with the first file's sector

link from ENTSEC ($D8) and compare it

to the second file's link in ENTSEC+1

($D9). If not equal, this is not a

concatenate so branch to COP10 ($C9A1).

CONCATENATE FILES

COP01

$C96E

$C971

$C979

$C97E

$C982

JSR to CHKIN file exists.

Set F2PTR ($0 OPIRFL ($C9FA channel, read

locate the na

JSR to TYPFIL

file type. If

branch to COP

Compare the f equal, it is

so branch to Bad file name indicate a fi

to CMDERR ($C

($CACC) to check if input

279) to $01 and JSR to

) to open the internal read in the directory file, and

med file.

($D125) to determine the $00, a scratched file so 01 (file type mismatch). ile type to $02. if not

not a deleted program file

COP05 to continue.

. Load .A with $64 to

le type mismatch and JSR

1C8) .

258

-----------------------------------------------------Page 258-----------------------------------------------------
﻿
NAME

COP05

COP10

CY

CY10

CY10A

CY15

CY20

ADDRESS

$C987

$C98B

$C991

$C996 $C999

$C99E

$C9A1 $C9A3

$C9A7

$C9AA

$C9B0

$C9B3

$C9B6 $C9B9 $C9BC

$C9BF

$C9C3

$C9C6

$C9C9

$C9CB

$C9CE $C9D2 $C9D5

$C9D8

$C9DB

DESCRIPTION OF WHAT ROM ROUTINE DOES

Set secondary address, SA ($83) to $12

(#18, the internal write channel) Move the active buffer pointer from LINTAB+IRSA ($023C) to LINTAB+IWSA

($023D).

Deactivate the internal read channel by storing $FF in LINTAB+IRSA ($023C).

JSR to APPEND ($DA2A) to copy first file Load .X with $02 and JSR to CY10 ($C9B9) to copy second file behind the first. Exit routine with a JMP to ENDCMD ($C194

COPY FILE

JSR to CY ($C9A7) to do copy.

Exit routine with a JMP to ENDCMD ($C194)

JSR to CHKIO ($CAE7) to check if file

exists.

Get drive number from FILDRV ($E2), AND it with $01 (mask off default bit), and store it in DRVNUM ($7F).

JSR to OPNIWR ($D486) to open internal

write channel.

JSR to ADDFIL ($D6E4) to add the new

file name to the directory and rewrite the directory.

Load .X with pointer from F1CNT ($0277). Store .X in F2CNT ($0278).

JSR to OPIRFL ($C9FA) to open internal

read channel and read in one or two

blocks of the directory.

Set secondary address, SA ($83) to $11, to set up the internal read channel. JSR to FNDRCH ($D0EB) to find an unused

read channel.

JSR to TYPFIL ($D125) to determine if

the file is a relative file.

If not a relative file (Z flag not set on return), branch to CY10A.

JSR to CYEXT ($CA53) to open copy the

relative file records.

Store $08 (EOI signal) into EOIFLG($F8).

JMP to CY20.

JSR to PIBYTE ($CF9B) to write out last byte to disk.

JSR to GIBYTE ($CA35) to get a byte from

the internal read channel.

Load .A with $80 (the last record flag) and JSR to TSTFLG ($DDA6) to see if this

is the last record.

259

-----------------------------------------------------Page 259-----------------------------------------------------
﻿
NAME

CY30

OPIRFL

ADDRESS

$C9E0

$C9E5

$C9E7

$C9EA

$C9F3

$C9FA

$CA03

$CA08

$CA0C

$CA0F

$CA14

$CA17

$CA21

$CA26

DESCRIPTION OF WHAT ROM ROUTINE DOES

On return if Z flag is set (test failed; this is not the last record) branch to

CY15 to do some more.

Last record done so JSR to TYPFIL($D125) to get file type.

On return if Z flag is set branch to

CY3 0 to do some more.

JSR to PIBYTE ($CF9B) to write out last byte to disk.

Check if there are more files to copy by loading .X from F2PTR ($0279),

incrementing it by 1, and comparing it to F2CNT ($0278). If the carry bit is clear, there are more files to copy so

branch back to CY10.

Since no more files to copy, set the SA ($83) to $12 (internal write channel) and JMP to CLSCHN ($DB02) to close the copy channel and file.

Open internal read channel to read file: Load .X with the file pointer F2PTR

($0279) and use this as an index to load

.A with the drive number of the file to

be read from FILDRV,X ($E2,X). AND this drive number with $01 to mask off the default drive bit, and store the value in DRVNUM ($7F) to set the drive number. Set the current TRACK ($80) to 18 ($12), the directory track.

Set the current SECTOR($81) to the sector containing the directory entry for this file from ENTSEC,X ($D8,X). the directory track.

JSR to OPNIRD ($D475) to open the

internal read channel to read the

directory.

Load .X with the file pointer F2PTR

($0279) and use this as an index to load .A with the pointer to the start of the

entry from ENTIND,X ($DD,X).

JSR to SETPNT ($D4C8) to set the track

sector pointers from the entry.

Load .X with the file pointer F2PTR

($0279) and use this as an index to load •A with the file's pattern mask from PATTYP,X ($E7,X). AND this value with $07 (the file type mask) and use it to set the file type in TYPE ($024A). Set the record length, REC ($0258) to $00 since this is not a relative file. JSR to OPREAD ($D9A0) to open a read

channel.

260

-----------------------------------------------------Page 260-----------------------------------------------------
﻿
NAME

OPIR10

GIBYTE

ADDRESS

$CA29

$CA2E

$CA30 $CA31 $CA32

$CA35

DESCRIPTION OF WHAT ROM ROUTINE DOES

Load .Y with $01 and JSR to TYPFIL

($D125) to get the file type.

If Z flag set on return (indicates that this is not a relative file) branch to

OPIR10.

Increment .Y by 1.

Transfer the value in .Y into .A

Exit with a JMP to SETPNT ($D4C8) to set

the track & sector pointers from the directory entry.

Get byte from internal read channel: Set the secondary address, SA ($83) to $11 (#17) the internal read channel.

Get byte from any channe

GCBYTE

GIB20

$CA39

$CA3C $CA3E

$CA42

$CA46

$CA48

$CA4D

$CA52

JSR to GBYTE ($D39B) to byte from the read chann Store the byte in DATA ( Load .X with the logical LINDX ($82) and use this

load .A with the channel

CHNRDY,X

EOR .A with $08, the not

and store the result in

If .A <> $00 (EOI was se

GIB20 and exit.

JSR to TYPFIL ($D125) to

type. If Z flag set on r

this is not a relative f GIB20 and exit.

Load .A with $80 (the la and JSR to SETFLG ($DD97 Terminate routine with a

get the next

el.

$85) .

file index

as an index to

status flag,

EOI send code

EOIFLG ($F8) .

nt!), branch to

get the file

eturn (indicates ile), branch to

st record flag) ) .

n RTS.

CYEXT

$CA53 $CA56

$CA59

$CA5F

$CA63

$CA66 $CA69

Copy relative records:

JSR to SETDRN ($D1D3) to set drive #. JSR to SSEND ($E1CB) to position side

sector and BUFTAB to the end of the last record.

Save side sector index, SSIND ($D6) and the side sector number, SSNUM ($D5) onto

the stack.

Set the secondary address, SA ($83) to $12, the internal write channel.

JSR to FNDWCH ($D107) to find an unused

write channel.

JSR to SETDRN ($D1D3) to set drive #. JSR to SSEND ($E1CB) to position side

sector and BUFTAB to the end of the last record.

261

-----------------------------------------------------Page 261-----------------------------------------------------
﻿
NAME

ADDRESS
 DESCRIPTION OF WHAT ROM ROUTINE DOES

$CA6C

$CA6F

$CA73

$CA77

$CA7F

$CA85

JSR to POSBUF ($E2C9)

proper data blocks in Set Rl ($87) to the c

the side sector index

Set RO ($86) to the c

the side sector numbe

Zero R2 ($88) and the record pointer RECPTR relative file pointer Restore the original side sector number, S sector index, SSIND (

Terminate the routine

to position the

to the buffers. urrent value of

, SSIND ($D6).

urrent value of

r, SSNUM ($D5). low bytes of the

($D4) and the ($D7).

values of the side

SNUM ($D5) and the $D6) from the stack

with a JMP to

RENAME

RN10

$CA88

$CA8B

$CA91

$CA95

$CA97 $CA99

$CA9C

$CA9F

$CAA5

$CAA9

$CAAC

$CAAF

ADDR1 ($E33B).

RENAME FILE IN THE DIRECTORY

JSR to ALLDRS ($C320) to set up all the drives given in the command string.

Load .A with the drive specified for the second file from FILDRV+1 ($E3), AND it with $01 to mask off the default drive bit, and store the result back in FILDRV+1 ($E3).

Compare the second drive number (in .A) with the first one in FILDRV ($E2). If equal, branch to RN10.

OR the drive number in .A with $80 to set bit 7. This will force a search of both drives for the named file.

Store the value in .A into FILDRV ($E2) JSR to LOOKUP ($C44F) to look up both file names in the directory.

JSR to CHKIO ($CAE7) to check for the

existance of the files named.

Load the value from FILDRV+1 ($E3), AND it with $01 to mask off the default

drive bit, and use the result to set the currently active drive, DRVNUM ($7F) .

Set the active sector number, SECTOR

($81) using the directory sector in

which the second file name was found

(from ENTSEC+1; $D9).

JSR to RDAB ($DE57) to read the

directory sector specified in TRACK($80)

and SECTOR ($81).

JSR to WATJOB ($D599) to wait for the

job to be completed.

Load .A with the pointer to the entry in the buffer from ENTIND+1 ($DE), add $03 (so it points to the first character in the file name), and JSR to SETPNT($D4C8) to set the pointers to the file name.

262

-----------------------------------------------------Page 262-----------------------------------------------------
﻿
NAME

ADDRESS
 DESCRIPTION OF WHAT ROM ROUTINE DOES

$CAB7

$CABA

$CAC3

$CAC6

$CAC9

JSR to GETACT ($DF93) to

active buffer number in Transfer the buffer numb .X from the file table F

.A with $10 (the number in a file name) and JSR

to transfer the file nam

command string to the bu the file entry.

JSR to WRTOUT ($DE5E) to revised directory sector JSR to WATJOB ($D599) to job to be completed.

Terminate the routine wi

store the

A.

er to .Y, load ILTBL ($027A),

of characters

to TRNAME($C66E)

e from the

ffer containing

write out the

wait for the

th a JMP to

CHKIN

CK10

CK20

CHKIO

CK25

CK30

$CACC

$CAD3 $CAD6

$CADA

$CADC

$CAE1

$CAE6

$CAE7

$CAEA

$CAEF

$CAF4

$CAF7

ENDCMD ($C194).

Check existance of input file:

Load .A with the first file type from PATTYP+1 ($E8), AND it with the file type mask ($07) and store it in TYPE

($024A).

Load .X from F2CNT ($0278).

Decrement .X by 1 and compare it with

the value of F1CNT ($0277).

If the carry is clear, the file has been

found so branch to CK10.

Load .A with the file's track link from

FILTRK,X ($0280,X). If link is NOT $00,

branch to CK10.

Since the file has not been found, load

.A with $62 and exit with a JMP to

CMDERR ($C1C8).

Terminate routine with an RTS.

Check existance of I/O file:

JSR to CHKIN ($CACC) to check for the existance of the input file.

Load .A with the file's track link from

FILTRK,X ($0280,X). If link equals $00,

branch to CK30.

The file already exists so load .A with $62 and exit with a JMP to CMDERR($C1C8) Decrement .X (file counter). If more files exist, branch back to CK25. CMDERR ($C1C8).

Terminate routine with an RTS.

MEMORY ACCESS COMMANDS (M-R, M-W, AND M-E)

MEM

$CAF8

Check that the second character in the

command is a "-" by: loading .A with the character from CMDBUF+1 ($0201), and comparing it with $2D ("-"). If not equal, branch to MEMERR ($CB4B).

263

-----------------------------------------------------Page 263-----------------------------------------------------
﻿
NAME

MEMEX

MEMRD

ADDRESS

$CAFF

$CB09 $CB0B

$CB0E

$CB12

$CB15

$CB19

$CB1D

$CB20

$CB24

DESCRIPTION OF WHAT ROM ROUTINE DOES

Set up address specified in command by moving the characters from CMDBUF+3 ($0202) and CMDBUF+4 ($0203) to TEMP ($6F) and TEMP + 1 ($70) .

Set .Y to $00.

Load .A with the third character of the

command (R,W,E) from CMDBUF+2 ($0202) . Compare .A with "R". If equal, branch to MEMRD ($CB20).

JSR to KILLP ($F258) to kill protection.

NOTE: this does nothing on the 1541! Compare .A with "W". If equal, branch to MEMWRT ($CB50).

Compare .A with "E". If NOT equal,

branch to MEMERR ($CB4B).

Do indirect jump using the pointer set up in TEMP ($006F).

Load .A with the contents of (TEMP),Y ($6F),Y and store the value in DATA($85) Compare the command string length,CMDSIZ

($0274), with $06. If it is less than or

equal to 6 (normally 5), branch to M30.

NOTE: PREVIOUSLY UNDOCUMENTED COMMAND!

PRINT#15,"M-R";CHR$(LO);CHR$(HI);CHR$(HOW MANY)

Multi-byte memory read:

MRMULT

$CB2B

$CB2E

$CB2F

$CB31

$CB33

$CB35

$CB37

$CB3A

$CB3E

Load .X with the 6th character in the

command string from CMDBUF+5 ($0205). Decrement .X (now $00 if only one to

read).

If the result is $00, all done so branch

to M30.

Transfer the value in .X to .A and clear

the carry flag.

Add the lo byte of the memory pointer

in TEMP ($6F). This value is the lo byte of the last character to be sent. Increment the lo byte pointer in TEMP ($6F) so it points to the second memory

location to be read.

Store the value in .A into LSTCHR+ERRCHN

($0249) .

Load .A with the current value of TEMP

($6A), the lo byte of the second memory

location to be read and store this value in CB+2 ($A5).

Load .A with the current value of TEMP+1

($70), the hi byte of the second memory

location to be read and store this value

in CB+3 ($A6).

264

-----------------------------------------------------Page 264-----------------------------------------------------
﻿
NAME

M30

MEMERR

MEMWRT

ADDRESS

$CB42

$CB45

$CB48

$CB4B

$CB50

$CB55

DESCRIPTION OF WHAT ROM ROUTINE DOES

Continue memory read with a JMP to GE20

($D443).

JSR to FNDRCH ($D0EB) to find an unused

read channel.

Terminate memory read with a JMP to GE15 ($D43A).

Load .A with $31 to indicate a bad command and JMP to CMDERR ($C1C8).

Move byte from CMDBUF+6,Y ($0206,Y) to memory at TEMP,Y ($BF,Y).

Increment .Y and compare .Y with the number of bytes to do, CMDBUF+5 ($0205),

$CB59 $CB5B

USER COMMANDS

If more to do, branch back to M10. Terminate memory write with an RTS.

NOTE: U0 restores pointer to JMP table

User jump commands:

USER

USRINT

US10

USREXC

OPNBLK

$CB5C

$CB5F

$CB63

$CB6B $CB6C

$CB6F

$CB72

$CB78

$CB7C $CB7D

$CB81

$CB84

$CB89

Load .Y with the second byte of the command string from CMDBUF + 1 ($0201) . Compare .Y to $30. If not equal, this

is NOT a U0 command so branch to US10.

Restore normal user jump address ($FFEA) storing $EA in USRJMP ($6B) and $FF in USRJMP+1 ($6C).

Terminate routine with an RTS.

JSR to USREXC ($CB72) to execute the code according to the jump table.

Terminate routine with a JMP to ENDCMD

($C194).

Decrement .Y, transfer the value to .A, AND it with $0F to convert it to hex, multiply it by two (ASL), and transfer

the result back into .Y.

Transfer the lo byte of the user jump

address from the table at (USRJMP),Y to IP ($75).

Increment .Y by 1.

Transfer the hi byte of the user jump

address from the table at (USRJMP),Y to IP+1 ($76) .

Do an indirect jump to the user code through the vector at IP ($0076).

Open direct access buffer in response

to an OPEN "#" command:

Use the previous drive number, LSTDRV ($028E) to set the current drive number

DRVNUM ($7F).

Save the current secondary address, SA

($83) on the stack.

265

-----------------------------------------------------Page 265-----------------------------------------------------
﻿
NAME

OB05

OB10

OB15

ADDRESS

$CB8C

$CB8F

$CB92

$CB96

$CB98

$CB9D $CBA0

$CBA5

$CBAA

$CBB1

$CBB8

$CBBF

$CBC6

$CBCD

$CBDD

$CBE2

DESCRIPTION OF WHAT ROM ROUTINE DOES

JSR to AUTOI ($C63D) to initialize the

disk. This is necessary for proper channel assignment.

Restore the original secondary address, SA ($83) by pulling it off the stack. Load .X with the command string length CMDSIZ ($0274). Decrement .X by 1. If .X not equal to zero, a specific

buffer number has been requested (e.g.#1)

so branch to OB10.

No specific buffer requested so get any available buffer by loading .A with $01 and doing a JSR to GETRCH ($D1E2). On return, JMP to OB30.

Load .A with $70 to indicate that no channel is available and JMP to CMDERR

($C1C8) .

Specific buffer requested so load .Y with $01 and JSR to BP05 ($CC7C) to check the block parameters.

Load .X with the number of the buffer

requested from FILSEC ($0285) and check it against $05 (the highest numbered buffer available). If too large, branch

to OB05 and abort the command.

Set TEMP ($6F) and TEMP+1 ($70) to $00 and set the carry flag.

Loop to shift a 1 into the bit position in TEMP or TEMP+1 that corresponds to the buffer requested. For example:

TEMP + 1 (00000000) TEMP(0000001)=buffer 0 TEMP+1(00000000) TEMP(0000100)=buffer 2 TEMP+1(00000001) TEMP(0000000)=buffer 8 Load .A with the value in TEMP ($6F)

and AND it with the value in BUFUSE

($024F) which indicates which buffers are already in use. If the result is

NOT $00, the buffer requested is already

in use so branch to OB05 to abort.

Load .A with the value in TEMP+1 ($70)

and AND it with the value in BUFUSE+1

($0250) which indicates which buffers are already in use. If the result is

NOT $00, the buffer requested is already

in use so branch to OB05 to abort.

Mark the buffer requested as in use by ORing the value in TEMP with the value

in BUFUSE and the value in TEMP+1 with the value in BUFUSE+1.

Set up the channel by loading .A with $00 and doing a JSR to GETRCH ($D1E2)

to find an unused read channel.

Load .X with the current channel* from LINDX ($82) .

266

-----------------------------------------------------Page 266-----------------------------------------------------
﻿
NAME

OB30

ADDRESS

$CBE4

$CBE9 $CBEA

$CBF1

$CBF3

$CBFB

$CBFD

$CC02

$CC07

$CC0D

$CC0F

$CC13

$CC18

DESCRIPTION OF WHAT ROM ROUTINE DOES

Use .X as an index to move the sector

link from FILSEC($0285) to BUFO,X($A7,X)

Transfer the sector link from .A to .X. Use .X as an index to move the current

drive number from DRVNUM($7F) to JOBS,X

($00,X) and to LSTJOB,X ($025B,X).

Load .X with the current secondary address, SA ($83) .

Load .A with the current value from the

logical index table, LINTAB,X ($022B,X).

OR this value with $40 to indicate that it is read/write mode and store the result back in LINTAB,X.

Load .Y with the current channel*, LINDX

($82) .

Load .A with $FF and store this value

as the channel's last character pointer LSTCHR,Y ($0244,Y).

Load .A with $89 and store this value in CHNRDY,Y ($00F2,Y) to indicate that

the channel is a random access one and

is ready.

Load .A with the channel number from

BUF0,Y ($00A7,Y) and store it in

CHNDAT,Y($023E,Y) as the first character Multiply the sector value in .A by 2

and transfer the result into .X

Set the buffer table value BUFTAB,X

($99,X) to $01.

Set the file type value FILTYP,Y ($EC,Y) to $0E to indicate a direct access file type.

Terminate routine with a JMP to ENDCMD

($C1C4).

BLOCK COMMANDS

(B-A;B-F;B-R;B-W;B-E;B-P)

Block commands:

BLOCK $CC1B Zero .X and .Y. Load .A with $2D ("-")

and JSR to PARSE ($C26 8) to locate the

sub-command (separated from the command with a "-").

$CC24 On return branch to BLK40 if Z flag is

not set ("-" was found).

BBK10 $CC26 Load .A with $31 to indicate a bad

command and JMP to CMDERR ($C1C8).

BLK30 $CC2B Load .A with $30 to indicate a bad

syntax and JMP to CMDERR ($C1C8).

BLK40 $CC30 Transfer the value in .X to .A. If not

$00, branch to BLK30.

$CC33 Load .X with $05 (the number of block

commands - 1).

267

-----------------------------------------------------Page 267-----------------------------------------------------
﻿
NAME

BLK50

BLK60

ADDRESS

$CC35

$CC38

$CC42

$CC48

$CC4B

$CC50

$CC5A

DESCRIPTION OF WHAT ROM ROUTINE DOES

Load .A with the first character in the sub-command from CMDBUF,Y ($0200,Y). Loop to compare the first character in

the sub-command with the characters in

the command table BCTAB,X ($CC5D,X). If a match is found, branch to BLK60. If NO MATCH is found, branch to BLK10.

Transfer the pointer to the command in

the command table from .X to .A. OR this value with $80 and store it as the command number in CMDNUM ($022A).

JSR to BLKPAR ($CC6F) to parse the block parameters.

Load .A with the command number from

CMDNUM ($022A), multiply it by 2 (ASL),

and transfer the result into .X.

Use .X as an index into the jump table BCJMP,X ($CC63) to set up a jump vector

to the ROM routine at TEMP ($6F/70).

Do an indirect JMP to the appropriate

ROM routine via the vector at TEMP($6F).

$CC5D

$CC63

Block sub-command

"AFRWEP"

.BYTE

Block jump table

table

($CC5D-$CC62)

($CC63-$CC6E)

$CC63/4
 $03,$CD

BLOCK-

-ALLOCATE $CD03

$CC65/6
 $F5,$CC

BLOCK-
 -FREE $CCF5

$CC67/8

$56,$CD

BLOCK-

-READ $CD56

$CC69/A
 $73,$CD

BLOCK-
 -WRITE $CD73

$CC6B/C
 $A3,$CD

BLOCK-

-EXECUTE $CDA3

$CC6D/E

$BD,$CD

BLOCK-
 -POINTER $CDBD

BLKPAR

BP05

BP10

$CC6F

$CC78

$CC7A $CC7C

$CC7F

$CC83

$CC87

$CC8B

$CC91

Parse the block parameter

Zero .X and .Y. Load .A w

and JSR to PARSE ($C26 8) colon, if any.

On return branch to BP05 not set (":" found; .Y= Load .Y with $03 (start o

Load .A with the .Yth cha

the command string.

Compare the character in (a space). If equal, bran Compare the character in (a skip chr). If equal, b Compare the character in (a comma). If NOT equal, Increment .Y. Compare .Y of the command string in If more left, branch back If no more, exit with an

s :

ith $3A (":")

to find the

if Z flag is

:"-position+1) f parameters)

racter from

A with $20,

ch to BP10.

.A with $29,

ranch to BP10.

A with $2C,

branch to BP2 0.

to the length

CMDSIZ ($0274).

to BP05.

RTS.

268

-----------------------------------------------------Page 268-----------------------------------------------------
﻿
NAME

BP20

ASCHEX

AH10

AH20

AH30

AH35

ADDRESS

$CC92

$CC95

$CC98 $CC9B

$CC9F

$CCA1

$CCA9 $CCAB

$CCAE

$CCB2

$CCB6

$CCB9

$CCC1

$CCC4

$CCCA

$CCD0 $CCD1

$CCD5 $CCD7 $CCDA

DESCRIPTION OF WHAT ROM ROUTINE DOES

JSR to ASCHEX ($CCA1) to convert ASCII

values into hex and store the results

in tables.

Increment the number of parameters processed F1CNT ($0277) .

Load .Y with the value in F2PTR ($0279)

Compare the value in .X (the original

value of F1CNT ($0277) to $04 (the maximun number of files - 1). If the value in .X <= $04, branch to BP10. If .X was > $04, the syntax is bad so branch to BLK30 ($CC2B).

Convert ASCII to HEX and store the

converted values in the FILTRK ($0280) and FILSEC ($0285) tables:

On entry: .Y = pointer into CMD buffer Zero TEMP($6F), TEMP+1($70), and TEMP+3

($72) as a work area.

Load .X with $FF.

Load .A with the command string byte from CMDBUF,Y.

Test if the character in .A is numeric

by comparing it to $40. If non-numeric,

branch to AH20.

Test if the character in .A is ASCII

by comparing it to $30. If it is not an ASCII digit, branch to AH20.

AND the ASCII digit with $0F to mask off the higher order bits and save this

new value on the stack.

Shift the values already in the table one position (TEMP+1 goes into TEMP+2; TEMP goes into TEMP+1).

Pull the new value off the stack and store it in TEMP.

Increment .Y and compare it to the

command length stored in CMDSIZ ($0274) . If more command left, branch back to

AH10.

Convert the values in the TEMP table

into a single hex byte:

Save the .Y pointer to the command string into F2PTR ($0279) , clear the the carry flag, and load .A with $00. Increment .X by 1 (index into TEMP). Compare .X to $03 to see if we're done yet. If done, branch to AH40. Load .Y from TEMP,Y ($6F,Y).

Decrement .Y by 1. If Y<0 branch to AH30 Add (with carry) the value from DECTAB,X ($CCF2,X) to .A. This adds 1, 10 or 100. If there is no carry, branch to AH35.

269

-----------------------------------------------------Page 269-----------------------------------------------------
﻿
NAME

AH4 0

DECTAB

BLKFRE

BLKALC

BA15

ADDRESS

$CCDF

$CCE4

$CCE5

$CCE8

$CCED

$CCF1

$CCF2 $CCF3 $CCF4

$CCF5

$CCF8

$CCFB

$CCFE

$CD03

$CD06

$CD09

$CD0C

$CD0E

$CD13

$CD19

DESCRIPTION OF WHAT ROM ROUTINE DOES

Since there is a carry, clear the carry, increment TEMP+3, and branch back to

AH35.

Save the contents of .A (the hex number)

onto the stack.

Load .X with the command segment counter from F1CNT ($0277).

Load .A with the carry bit (thousands) from TEMP+3 ($72) and store it in the table, FILTRK,X ($0280,X).

Pull the hex number off the stack and

store it in the table, FILSEC,X($0285,X)

Terminate routine with an RTS.

The decimal conversion table:

Byte $01 = 1 Byte $0A = 10 Byte $64 = 100

Free (de-allocate) block in the BAM: JSR to BLKTST ($CDF5) to test for legal block and set up track & sector.

JSR to FRETS ($EF5F) to free the block in the BAM and mark the BAM as changed.

Terminate routine with a JMP to ENDCMD

($C194).

Unused code: LDA #$01 / STA WBAM($02F9)

Allocate a sector (block) in the BAM: JSR to BLKTST ($CDF5) to test for legal block and set up track & sector.

Load .A with the current sector pointer, SECTOR ($81) and save this on the stack. JSR to GETSEC ($F1FA) to set the BAM and find the next available sector on this track.

If Z flag is set on return to indicate

that the desired sector is in use and

there is no greater sector available on this track, branch to BA15.

Pull the requested sector from the stack and compare it to the current contents of SECTOR ($81). If not equal, the requested sector is already in use so

branch to BA30.

Requested sector is available so JSR to WUSED ($EF90) to allocate the sector in the BAM and terminate the command with a JMP to ENDCMD ($C194).

Pull the desired sector off the stack. It is of no further use since that

sector is already in use.

270

-----------------------------------------------------Page 270-----------------------------------------------------
﻿
NAME

ADDRESS
 DESCRIPTION OF WHAT ROM ROUTINE DOES

BA20

BA3 0

BA40

$CD1A

$CD27

$CD2A

$CD2C

$CD31

Set the desired se

$00, increment the ($80) by 1, and ch

the maximum track from MAXTRK $FECB) the way, branch to JSR to GETSEC ($F1 find the next avai track.

If Z flag is set o

sector is availabl branch back to BA2

Requested block is

.A with $65 to ind

and JMP to CMDER2 No free sectors ar

.A with $65 to ind

and JMP to CMDERR

ctor, SECTOR ($81) to desired track, TRACK

eck if we have reached count of 35 (taken

. If we have gone all

BA40.

FA) to set the BAM and lable sector on this

n return, no greater

e on this track so

0 to try another track

not available so load icate NO BLOCK ERROR

($E645).

e available so load icate NO BLOCK ERROR

($C1C8).

BLKRD2

GETSIM

BLKRD3

BLKRD

$CD36

$CD39

$CD3C $CD3F

$CD41

$CD42 $CD45

$CD4A

$CD4D

$CD50

$CD55

$CD56

$CD59

$CD5C

B-R Sub to test parameters:

JSR to BKOTST ($CDF2) to test block parameters and set track & sector. JMP to DRTRD ($D460) to read block

B-R Sub to get byte w/o increment: JSR to GETPRE ($D12F) set parameters. Load .A with the value in (BUFTAB,X),

($99,X).

Terminate routine with an RTS.

B-R Sub to do read:

JSR to BLKRD2 ($CD36) to test parameters Zero .A and JSR to SETPNT ($D4C8) to set the track and sector pointers.

JSR to GETSIM ($CD3C) to read block. On return .Y is the LINDX.

Store the byte in .A into LSTCHR,Y ($0244,Y) as the last character.

Store $89 in CHNRDT,Y($F2,Y) to indicate

that it is a random access channel and

is now ready.

Exit routine with an RTS.

Block read a sector:

JSR to BLKRD3 ($CD42) to set up to read the requested sector.

JSR to RNGET1 ($D3EC) to read in the

sector.

Terminate routine with a JMP to ENDCMD

($C194).

271

-----------------------------------------------------Page 271-----------------------------------------------------
﻿
NAME

UBLKRD

BLKWT

BW10

BW2 0

ADDRESS

$CD5F

$CD62

$CD65

$CD6B

$CD70

$CD73

$CD76

$CD79 $CD7B

$CD7F $CD81 $CD83

$CD86

$CD8A

$CD8C

$CD8F

DESCRIPTION OF WHAT ROM ROUTINE DOES

Block read of a sector:

Ul:

NOTE: The only real difference between a B-R command and a Ul (preferred) is that the Ul command move the last byte into the data buffer and stores $FF as the last byte read.

JSR to BLKPAR ($CC6F) to parse the block parameters.

JSR to BLKRD3 ($CD42) to set up to read the requested sector.

Move the last character read from

LSTCHR,Y ($0244,Y) to CHNDAT,Y ($023E,Y) Store $FF in LSTCHR,Y ($0244,Y) as the

last character to be read.

Terminate routine with a JMP to ENDCMD

($C194) which ends with an RTS.

Block-write of a sector:

JSR to BKOTST ($CDF2) to test the buffer and block parameters and set up the drive, track, and sector pointers.

JSR to GETPNT ($D4E8) to read the active buffer pointers. On exit, .A points into

the buffer.

Transfer .A to .Y and decrement .Y.

If the value in .A is greater than $02,

branch to BW10

Load .Y with $01. Load .A with $00.

JSR to SETPNT ($D4C8) to set the buffer pointers.

Transfer the value in .Y to .A and JSR

to PUTBYT ($CFF1) to put the byte in .A

into the active buffer of LINDX.

Transfer the value of .X to .A and save it on the stack.

JSR to DRTWRT ($D464) to write out the

block.

Pop the value off the stack and transfer

it back into

,X.

$CD91

JSR to RNGET2

($D3EE) to set the channel

UBLKWT

$CD94

$CD97

$CD9A

ready status and last character.

Terminate routine with a JMP to ENDCMD

($C194) which ends with an RTS.

U2: Block write of a sector:

JSR to BLKPAR ($CC6F) to parse the block

parameters.

JSR to BKOTST ($CDF2) to test the buffer and block parameters and set up the drive, track, and sector pointers.

272

-----------------------------------------------------Page 272-----------------------------------------------------
﻿
NAME

BLKEXC

ADDRESS

$CD9D

$CDA0

$CDA3

$CDA6 $CDA9

$CDAD

$CDB4

$CDB7

DESCRIPTION OF WHAT ROM ROUTINE DOES

JSR to DRTWRT ($D464) to write out the block.

Terminate routine with a JMP to ENDCMD

($C194) which ends with an RTS.

Block execute a sector:

JSR to KILLP ($F258) to kill the disk protection. Does nothing on the 1541! JSR to BLKRD2 ($CC6F) to read the sector Store $00 in TEMP ($6F) as the lo byte of the JMP address)

Load .X from JOBNUM ($F9) and use it as

an index to load the hi byte of the JMP address from BUFIND,X ($FEE0,X) and store it in TEMP+1 ($70).

JSR to BE10 ($CDBA) to execute the

block.

Terminate routine with a JMP to ENDCMD

($C194) which ends with an RTS.

BE10
 $CDBA

JMP (TEMP)

Used by block execute.

BLKPTR

BUFTST

BT15

$CDBD

$CDC0

$CDC9 $CDCC

$CDCF

$CDD2

$CDD6

$CDD9

$CDE0

Set the buffer pointer:

JSR to BUFTST ($CDD2) to test for

allocated buffer.

Load the buffer number of the channel

requested from JUBNUM ($F9), multiply it by two (ASL), and transfer the result

into .X. Load .A with the new buffer

pointer value from FILSEC+1 ($0286) and store it in the buffer table BUFTAB,X

($99,X).

JSR to GETPRE ($D12F) to set up pointers JSR to RNGET2 ($D3EE) to ready the

channel for I/O.

Terminate routine with a JMP to ENDCMD

($C194) which ends with an RTS.

Test whether a buffer has been allocated

for the secondary address given in SA. Load .X with the file stream 1 pointer, F1PTR ($D3) and then increment the

original pointer F1PTR ($D3).

Load .A with that file's secondary address from FILSECX ($0285,X).

Transfer the secondary address to .Y. Decrement it by 2 (to eliminate the reserved secondary addresses 0 and 1) and compare the result with $0C (#12). If the original SA was between 2 and 14, it passes the test so branch to BT20. Load .A with $70 to indicate no channel is available and JMP to CMDERR ($C1C8).

273

-----------------------------------------------------Page 273-----------------------------------------------------
﻿
NAME

BT20

BKOTST

BLKTST

ADDRESS

$CDE5

$CDE7

$CDEC

$CDF1

$CDF2

$CDF5

$CDF7

$CDFE

$CE03

$CE08

$CE0B

DESCRIPTION OF WHAT ROM ROUTINE DOES

Store the original secondary address

(in .A) into SA ($83) as the active SA. JSR to FNDRCH ($D0EB) to find an unused read channel. If none available, branch

to BT15.

JSR to GETACT ($DF93) to get the active buffer number. On return, store the active buffer number in JOBNUM ($F9). read channel. If none available, branch

Terminate routine with an RTS.

Test all block parameters: buffer

allocated and legal block. If OK, set up drive, track, and sector values.

JSR to BUFTST($CDD2) to test if buffer is allocated for this secondary address.

Set the drive number, track, and sector values requested for a block operation

and test to see that these are valid. Load .X with the channel number from

F1PTR ($D3)

Load .A with the drive number desired

from FILSEC,X($0285,X), AND it with $01 to mask off the default drive bit, and

store the result as the current drive

number, DRVNUM ($7F) .

Move the desired sector from FILSEC+2,X

($0287,X) to SECTOR ($81).

Move the desired track from FILSEC+1,X

($0286,X) to TRACK ($80).

JSR to TSCHK ($D55F) to test whether the track and sector values are legal.

JMP to SETLDS to turn on drive active LED. Do RTS from there.

FIND RELATIVE FILE

INPUTS: (ALL 1 BYTE)

RECL - record # (lo byte) RECH - record # (hi byte)

RS - record size

RECPTR - pointer into record

OUTPUTS: (ALL 1 BYTE) SSNUM - side sector # SSIND - index into SS

RELPTR - pointer into

sector

FNDREL

$CE0E

$CE11

$CE14

$CE18

JSR to MULPLY($CE2C) to find total bytes

TOTAL = REC# x RS + RECPTR

JSR to DIV254 to divide by 254. The result is the record's location (in sectors) from the start of the file. Save the remainder (in .A) into RELPTR ($D7). This points into the last sector.

JSR to DIV120 to divide by 120. The

result points into the side sector file.

274

-----------------------------------------------------Page 274-----------------------------------------------------
﻿
NAME

MULPLY

MUL25

MUL50

MUL100

MUL200

MUL400

ADDRESS

$CE1B

$CE1F

$CE23

$CE2B

$CE2C

$CE31 $CE33

$CE37

$CE3B

$CE3D

$CE41

$CE4A

$CE4C

$CE50

$CE54

$CE57

$CE5A

$CE5E $CE6D

DESCRIPTION OF WHAT ROM ROUTINE DOES

Increment the pointer into the sector, RELPTR ($D7) by two to bypass the two

link bytes at the start of the sector. Move the quotient of the division by 120 from RESULT ($8B) to SSNUM ($D5).

Load .A with the remainder of the

division from ACCUM+1 ($90) , multiply it by two (ASL) because each side sector pointer occupies two bytes (t & s), add $10 (#16) to skip the initial link table in the sector, and store the resulting side sector index (points into the sector holding the side sectors) into SSIND ($D6).

Terminate routine with an RTS.

Calculate a record's location in bytes.

TOTAL = REC# X RS + RECPTR

JSR to ZERRES ($CED9) to zero the RESULT area ($8B-$8D).

Zero ACCUM + 3 ($92) .

Load .X with the LINDX ($82) and use it to move the lo byte of the record number from RECL,X ($B5) to ACCUM+1 ($90). Move the hi byte of the record number from RECH,X ($BB) to ACCUM + 2 ($91) . If the hi byte of the record number is not $00, branch to MUL25.

If the lo byte of the record number is $00, branch to MUL50 to adjust for

record #0 (the first record).

Load .A with the lo byte of the record size from ACCUM+1 ($90), set the carry flag, subtract $01, and store the result back in ACCUM+1. If the carry flag is still set, branch to MULT50.

Decrement the hi byte of the record size in ACCUM+2 ($91) .

Copy the record size from RS,X ($C7,X)

to TEMP ($6F).

Do an LSR on TEMP ($6F). If the carry flag is clear, branch to MUL200 (no add this time).

JSR to ADDRES ($CEED) to add. RESULT = RESULT + ACCUM+1,2,3

JSR to ACCX2 ($CEE5) to multiply the ACCUM+1,2,3 by two.

Test TEMP to see if done, if not branch

back to MUL100.

Add the byte pointer to the result.

Terminate routine with an RTS.

275

-----------------------------------------------------Page 275-----------------------------------------------------
﻿
NAME
 ADDRESS
 DESCRIPTION OF WHAT ROM ROUTINE DOES

DIVIDE ROUTINE:

RESULT ($8B)
 QUOTIENT ACCUM+1 ($90)

Divide by 254 entry point:

= REMAINDER

DIV254

DIV120

DIV150 DIV200

DIV300

DIV400

DIV500

$CE6E $CE70

$CE71 $CE73 $CE75 $CE84 $CE87 $CE89

$CE8D

$CE92

$CE9A

$CEA3

$CEA6

$CEA9

$CEAD

$CEB0

$CEBF

$CEC5

$CED0

Load .A with $FE (#254)

Byte $2C (skip over next instruction) Divide by 120 entry point:

Load .A with $78 (#120)

Store divisor into TEMP ($6F). Swap ACCUM+1,2,3 with RESULT,1,2

JSR to ZERRES ($CED9) to zero RESULT,1,2

Zero .X

Divide by 256 by moving the value in ACCUM+1,X ($90,X) to ACCUM,X ($8F,X). Increment .X. If .X is not 4 yet, branch

back to DIV200.

Zero the hi byte, ACCUM+3 ($92). Check if this is a divide by 120 by

testing bit 7 of TEMP. If it is a divide by 254, branch to DIV300.

Do an ASL of ACCUM ($8F) to set the carry flag if ACCUM > 127. Push the processor status on the stack to save the carry flag. Do an LSR on ACCUM to restore its original value. Pull the processor status back off the stack and JSR to ACC200 ($CEE6) to multiply the value in the ACCUM,1,2 by two so that we have, in effect, divided by 128.

X/128 = 2 * X/256

JSR to ADDRES ($CEED) to add the ACCUM

to the RESULT.

JSR to ACCX2 ($CEE5) to multiply the ACCUM by two.

Check if this is a divide by 120 by

testing bit 7 of TEMP. If it is a divide by 254, branch to DIV400.

JSR to ACCX4 ($CEE2) to multiply the

ACCUM by four. A=4* (2* A) =8*A Add in the remainder from ACCUM ($8F) to ACCUM+1. If a carry is produced, increment ACCUM+2 and, if necessary,

ACCUM+3.

Test if remainder is less than 256 by ORing ACCUM+3 and ACCUM+2. If the result is not zero, the remainder is too large

so branch to DIV to crunch some more. Test if remainder is less than divisor

subtracting the divisor, TEMP ($6F) from the remainder in ACCUM+1 ($90). If the remainder is smaller, branch to DIV600. Since the remainder is too large, add 1

to the RESULT.

276

-----------------------------------------------------Page 276-----------------------------------------------------
﻿
NAME

DIV600

ZERRES

ACCX4

ACCX2

ACC200

ADDRES ADD100

LRU INT LRUILP

LRUUPD

LRULP1

LRUEXT

ADDRESS

$CED6

$CED8

$CED9

$CEE1

$CEE2

$CEE5 $CEE6

$CEEC

$CEED $CEF0

$CEF6

$CEF9

$CEFA $CEFC

$CEFF

$CF04

$CF08

$CF09

$CF0D

$CF12

$CF16

$CF19

$CF1D

DESCRIPTION OF WHAT ROM ROUTINE DOES

Store the new, smaller remainder in ACCUM+1 ($90) .

Terminate routine with an RTS.

Zero the RESULT area:

Load .A with $00 and store in RESULT ($8B), RESULT+1($8C), and RESULT+2($8D)

Terminate routine with an RTS.

Multiply ACCUM by 4:

JSR ACCX2 ($CEE5)

Multiply ACCUM by 2: Clear the carry flag.

Do a ROL on ACCUM+1($90), ACCUM+2($91), and ACCUM+2($92).

Terminate routine with an RTS.

Add ACCUM to RESULT:

Load .X with $FD.

Add RESULT+3,X ($8E,X) and ACCUM+4,X ($93) and store the result in RESULT+3

Increment .X. If not $00 yet, branch

back to ADD100.

Terminate routine with an RTS.

Initialize LRU (least recently used)

table:

Load .X with $00.

Transfer .X to .A. Store the value in

.A into LRUTBL,X ($FA,X).

Increment .X and compare it to $04, the command channel number. If not yet equal, branch back to LRUILP.

Load .A with $06, the BAM logical index for the floating BAM, and store this value into LRUTBL,X ($FA,X).

Terminate routine with an RTS.

Update LRU (least recently used) table: Load .Y with $04, the command channel number. Load .X from LINDX ($82) the

current channel number.

Load .A with the value from LRUTBL,Y ($00FA,Y). Store the current channel

number (from .X) into LRUTBL,Y.

Compare the value in .A with the current channel number in LINDX ($82). If they are equal, branch to LRUEXT to exit.

Decrement .Y the channel counter. If no more channels to do (Y<0) branch to

LRUINT ($CEFA) since no match was found.

Transfer .A to .X and JMP to LRULPl

.A into LRUTBL,X ($FA,X).

Terminate routine with an RTS.

277

-----------------------------------------------------Page 277-----------------------------------------------------
﻿
NAME

DBLBUF

DBL0 5

DBL08

DBL10

DBL15

DBL20

ADDRESS

$CF1E

$CF21

$CF24

$CF26

$CF29

$CF2E

$CF31

$CF37

$CF3E

$CF45

$CF47

$CF4C

$CF51

$CF57

$CF5A

$CF5D

$CF63 $CF66

$CF6C

$CF6F

DESCRIPTION OF WHAT ROM ROUTINE DOES

Double buffer: Switch the active and inactive buffers.

JSR to LRUUPD ($CF09) to update the LRU

(least recently used) table.

JSR to GETINA ($DFB7) to get the LINDX channel's inactive buffer number (in .A) On return, if there is an inactive buffer, branch to DBL15.

There is no inactive buffer so make one! JSR to SETDRN ($D1D3) to set the drive

number to the one in LSTJOB.

JSR to GETBUF ($D28E) to get a free buffer number. If no buffers available,

branch to DBL30 and abort.

JSR to PUTINA ($DFC2) to store the new buffer number as the inactive buffer. Save the current values of TRACK ($80) and SECTOR ($81) on the stack.

Load .A with $01 and JSR to DRDBYT

($D4F6) to direct read .A bytes. Store the byte read as the current SECTOR($81) Load .A with $00 and JSR to DRDBYT ($D4F6) to direct read .A bytes. Store the byte read as the current TRACK($80). If the TRACK byte was $00 (last sector in the file), branch to DBL10.

JSR to TYPFIL ($D125) to determine the file type we are working on. If it is a relative file, branch to DBL05.

JSR to TSTWRT ($DDAB) to see if we are

writing this file or just reading it. If just reading, branch to DBL05 to read

ahead.

We are writing so JSR to TGLBUF ($CF8C) to toggle the buffers. On return, JMP

to DBL08.

JSR to TGLBUF ($CF8C) to toggle the

inactive and inactive buffers.

JSR to RDAB ($DE57) to read in the next sector of the file (into active buffer). Pull the old SECTOR($81) and TRACK($80)

values from the stack and restore them. JMP to DBL20.

Pull the old SECTOR($81) and TRACK($80)

values from the stack and restore them.

JSR to TGLBUF ($CF8C) to toggle the

inactive and active buffers.

JSR to GETACT ($DF93) to get the active buffer number (in .A). Transfer the

active buffer number into .X and JMP to

WATJOB ($D599) to wait until job is done

278

-----------------------------------------------------Page 278-----------------------------------------------------
﻿
NAME

ADDRESS
 DESCRIPTION OF WHAT ROM ROUTINE DOES

DBL3 0

$CF76

No buffers to to indicate a

steal so load .A NO CHANNEL error

with $70

and JMP

to CMDERR ($C1C8).

DBSET

$CF7B

Set up double

JSR to LRUUPD

buffering:

($CF09) to update the LRU

(least recently used) table.

$CF7E

JSR to GETINA

($DFB7) to get the number

$CF81

of the inactive buffer (in .A) If there is an inactive buffer to DBS10 to exit.

.

, branch

$CF83

JSR to GETBUF buffer. If no

($DF93) to find

buffers availabl

an unused e, branch

to DBL30 ($CF76) to abort.

$CF88

JSR to PUTINA found as the

($DFC2) to set the buffer

inactive buffer.

DBS10

TGLBUF

$CF8B

$CF8C

Terminate routine with an RTS.

Toggle the inactive & active buffers:

Input: LINDX = current channel #

Load .X with
 the channel number from

$CF94

LINDX ($82) a

load .A with

BUF0,X ($A7). to change its

store the mod Load .A with

BUF1,X ($AE). to change its

store the mod

nd use it as an i the buffer number

EOR this number active/inactive ified value back the buffer number

EOR this number

active/inactive

ified value back

ndex to

from

with $80

state and

in BUF0,X.

from

with $80

state and

in BUF1,X.

PIBYTE

PBYTE

$CF9A

$CF9B

$CF9F

$CFA2

$CFA5

$CFAA

$CFAF

Terminate routine with an RTS.

Write byte to internal write channel: Load .X with $12 (#18) the secondary

address of the internal write channel

and use it to set the current secondary address SA ($83) .

JSR to FNDWCH ($D107) to find an unused

write channel.

JSR to SETLED ($C100) to turn on the

drive active LED.

JSR to TYPFIL ($D125) to determine the current file type. If NOT a relative file, branch to PBYTE ($CFAF).

Load .A with $20 (the overflow flag bit) and JSR to CLRFLG ($DD9D) to clear the overflow flag.

Write byte to any channel:

Load .A with the current secondary address from SA ($83). Compare the SA with $0F (#15) to see if we are using the command channel. If SA=$0F, this is

the command channel so branch to L42

($CFD8). If not, branch to L40 ($CFBF).

279

-----------------------------------------------------Page 279-----------------------------------------------------
﻿
NAME

PUT

L40

L41

L46

L42

L50

L45

PUTBYT

ADDRESS

$CFB7

$CFBF

$CFC4

$CFC9

$CFCB

$CFCE

$CFD3

$CFD8

$CFDC

$CFE3

$CFE8

$CFEC $CFED

$CFF0

$CFF1

$CFF2

DESCRIPTION OF WHAT ROM ROUTINE DOES

Main routine to write to a channel:

Check if this is the command channel or

a data channel by loading the original secondary address from ORGSA ($84) , ANDing it with $8F, and comparing the result with $0F (#15). If less than 15,

this is a data channel so branch to L42. JSR to TYPFIL ($D125) to determine the file type. If we are NOT working on a sequential file, branch to L41.

Since this is a sequential file, load .A with the data byte from DATA ($85)

and JMP to WRTBYT ($D19D) to write the byte to the channel.

If Z flag not set, we are writing to a true random access file (USR) so branch

to L46.

We are writing to a relative (REL) file so JMP to WRTREL ($E0AB).

Since this is a USR file, load .A with the data byte from DATA ($85) and JSR to PUTBYT ($CFF1) to write it to the

channel.

To prepare to write the next byte: load

.Y with the channel number from LINDX

($82) and JMP to RNGET2 ($D3EE).

Since this is the command channel, set LINDX ($82) to $04 (the command channel number).

Test if command buffer is full by doing a JSR to GETPNT ($D4E8) to get the position of the last byte written and comparing it to $2A. If they are equal,

the buffer is full so branch to L50.

Since there is space, load .A with the command message byte from DATA ($85) and JSR to PUTBYT ($CFF1) to write it to the

command channel.

Test if this is the last byte of the message by checking the EOIFLG ($F8). If it is zero, this is the last byte so

branch to L45.

Terminate command with an RTS.

Increment CMDWAT ($0255) to set the command-waiting flag.

Terminate command with an RTS.

Put byte in .A into the active buffer

of the channel in LINDX:

Save byte in .A onto the stack.

JSR to GETACT ($DF93) to get the active buffer number (in .A). If there is an active buffer, branch to PUTB1.

280

-----------------------------------------------------Page 280-----------------------------------------------------
﻿
NAME

PUTB1

ADDRESS

$CFF7

$CFFD

$CFFF

$D002

$D004

DESCRIPTION OF WHAT ROM ROUTINE DOES

No active buffer so pull the data byte off the stack, load .A with $61 to

indicate a FILE NOT OPEN error, and JMP to CMDERR ($C1C8) .

Multiply the buffer number by 2 (ASL)

and transfer this value to .X

Pull the data byte off the stack and store it in the buffer at (BUFTAB,X)

($99,X).

Increment the buffer pointer BUFTAB,X NOTE: Z flag is set if this data byte

was stored in the last position

in the buffer!

Terminate routine with an RTS.

INITIALIZE DRIVE(S)

(Disk command)

Initialize drive(s):

INTDRV

$D005

JSR to SIMPRS ($ClDi;

to parse the

ID20

ITRIAL

IT20

IT30

$D008

$D00B

$D00E

$D011

$D018

$D01F

$D024

$D02C

$D031

disk command.

JSR to INITDR ($D042) to initialize the drive(s).

Terminate command with a JMP to ENDCMD

($C194) .

Initialize drive given in DRVNUM:

JSR to BAM2A ($F10F) to get the current BAM pointer in .A.

Transfer the BAM pointer to .Y and use

it as an index to load the BAM LINDX

from BUF0,Y ($A7,Y) into .X. If there

is a valid buffer number for the BAM

(not $FF), branch to IT30.

No buffer so we had better get one!

Save the BAM pointer in .A on the stack and JSR to GETBUF ($D28E) to find an unused buffer. If a buffer is available,

branch to IT20.

No buffer available so load .A with $70

to indicate a NO CHANNEL error and JSR

to CMDER3 ($E648).

Pull the BAM pointer from the stack and

transfer it to .Y. Transfer the new

buffer number from .X to .A, OR it with $80 (to indicate an inactive status), and store the result in BUF0,Y ($00A7,Y)

to allocate the buffer.

Transfer the buffer number from .X to

.A, AND it with $0F to mask off the inactive status bit, and store it in JOBNUM ($F9).

Set SECTOR ($81) to $00 and TRACK ($80) to $12 (#18) to prepare to read the BAM.

281

-----------------------------------------------------Page 281-----------------------------------------------------
﻿
NAME

ADDRESS

$D03A

$D03D

DESCRIPTION OF WHAT ROM ROUTINE DOES

JSR to SETH ($D6D3) to set up the seek image of the BAM header.

Load .A with $B0 (the job code for a

SEEK) and JMP to DOJOB ($D58C) to do the

seek to track 18. Does an RTS when done.

Initialize drive:

INITDR

$D042

$D045

$D048

$D04D

$D052

$D05D

$D060

$D06F

JSR to CLNBAM ($F0D1) to ze

numbers for the BAM.

JSR to CLDCHN ($D313) to al

channel for the BAM.

JSR to ITRIAL ($D00E) to al buffer for the BAM and seek

Store $00 in MDIRTY,X ($025

indicate that the BAM for d

NOT DIRTY (BAM in memory ma

the diskette).

Set the master ID for the d

DSKID,X ($12/3 for drive 0) track 18 header values ($16

during the seek to track 18

JSR to DOREAD ($D586) to re

into the buffer.

Load the disk version(#65 f

from the $0X02 position in

store it in DSKVER,X($0101, Zero WPSW,X ($1C,X) to clea protect switch and NODRV,X

clear the drive-not-active

ro the track

locate a

locate a track 18.

1) to

rive .X is

tches BAM on

iskette in

from the

/17) read

ad the BAM

or 4040/1541)

the BAM and

drive number) r the write

($FF,X) to

flag.

NFCALC

NUMF1

NUMF2

$D075

$D078

$D07D

$D082 $D083

$D08B

$D08F

Count the number of free blocks in BAM JSR to SETBPT ($EF3A) to set the bit map

pointer and read in the BAM if necessary

Initialize .Y to $04 and zero .A and .X

(.X will be the hi byte of the count). Clear carry and add (BMPNT),Y; ($6D),Y to the value in .A. If no carry, branch

to NUMF2.

Increment .X (the hi byte of the count). Increment .Y four times so it points to the start of the next track byte in the BAM. Compare .Y to $48 (the directory

track location). If .Y=$48, branch to

NUMF2 to skip the directory track.

Compare .Y to $90 to see if we are done.

If there is more to do, branch to NUMF1. All done. Save the lo byte of the count on the stack and transfer the hi byte

from .X to .A. Load .X with the current drive number from DRVNUM ($7F) and store

the hi byte of the count (in .A) into

NDBH,X ($02FC,X). Pull the lo byte of the count off the stack and save it in NDBL,X ($02FA,X).

282

-----------------------------------------------------Page 282-----------------------------------------------------
﻿
NAME

ADDRESS

$D09A

DESCRIPTION OF WHAT ROM ROUTINE DOES

Terminate routine with an RTS.

Start reading
 ahead:

STRRD

$D09B

$D09E

$D0A1

$D0A4

$D0A9

$D0AE

Use the values read a data bl

sector pointer

JSR to SETHDR

header image u

SECTOR ($8i) v

JSR to RDBUF (

block into the JSR to WATJOB

read job to be

JSR to GETBYT

byte from the

and store it i

JSR to GETBYT

byte from the

and store it i Terminate rout

in TRACK and SECTOR to ock. Use the track and

s to set up the next one.

($D6D0) to set up the sing TRACK ($80) and

alues.

$D0C3) to read the first

data buffer.

($D599) to wait for the

completed.

($D137) to get the first data buffer (track link) n TRACK ($80) .

($D137) to get the second data buffer (sector link) n SECTOR ($81).

ine with an RTS.

STRDBL

STR1

RDBUF

WRTBUF

STRTIT

$D0AF

$D0B2

$D0B6 $D0B7

$D0BA

$D0BD

$D0C0

$D0C3

$D0C7

$D0C9

$D0CC

Start double buffering: (reading ahead) JSR to STRRD ($D09B) to read in a data block and set up the next one.

Check the current TRACK ($80) value. If not $00, we are not at the end of the file so branch to STR1.

Terminate routine with an RTS.

JSR to DBLBUF ($CF1E) to set up buffers and pointers for double buffering and

set TRACK and SECTOR for the next block.

JSR to SETHDR ($D6D0) to set up the header image using TRACK ($80) and

SECTOR ($81) values.

JSR to RDBUF ($D0C3) to read the next

block into the data buffer.

JMP to DBLBUF ($CF1E) to set up buffers and pointers for double buffering and

set TRACK and SECTOR for the next block.

Start a read job of TRACK and SECTOR Load .A with $80, the job code for a read, and branch to STRTIT ($D0C9).

Start a write job of TRACK and SECTOR Load .A with $90, the job code for a

write.

Store command desired (in .A) as the current command in CMD ($024D).

JSR to GETACT ($DF93) to get the active buffer number (in .A). Transfer the active buffer number into .X.

283

-----------------------------------------------------Page 283-----------------------------------------------------
﻿
NAME

WRTC1

FNDRCH

FNDC20

FNDC2 5

FNDC3 0

ADDRESS

$D0D0

$D0D3

$D0DB

$D0E2

$D0E8

$D0EA

$D0EB

$D0F1

$D0F3

$D0F7

$D0F9

$D100

$D106

DESCRIPTION OF WHAT ROM ROUTINE DOES

JSR to SETLJB ($D506) to set up drive number (from the last job), check for legal track & sector, and, if all OK, do the job. On return .A=job number and

.X=buffer number.

Transfer buffer number from .X to .A and

save it on the stack. Multiply the

buffer number by two (ASL) and transfer

the result into .X and use it as an index to store $00 in the buffer table

pointer BUFTAB,X ($99,X)

JSR to TYPFIL ($D125) to get the file type. Compare the file type to $04. If this is not a sequential file, branch to

WRTC1.

Since this is a sequential file,

increment the lo byte of the block count in NBKL,X ($B5,X) and, if necessary, the hi byte in NBKH,X ($BB,X).

Pull the original buffer number off the

stack and transfer it back into .X. Terminate routine with an RTS.

Find the assigned read channel:

Compare the current secondary address

from SA ($83) with $13 (#19) the

highest allowable secondary address+1. If too large, branch to FNDC20. AND the secondary address with $0F

NOTE: This masks off the high order bits

of the internal channel sec adr's: Internal read $11 (17) -> $01 Internal write $12 (18) -> $02

Compare the sec addr in .A with $0F(15),

the command channel sec addr. If they are not equal, branch to FNDC25.

Load .A with $10, the sec addr error

value.

Transfer the sec addr from .A to .X,

set the carry flag, and load the

channel number from LINTAB,X ($022B,X). If bit 7 is set, no channel has been

assigned for this sec addr, so branch to FNDC30 to exit (with carry bit set).

AND the current channel number with $0F and store the result as the current

channel number in LINDX ($82) . Transfer

the channel number into .X and clear the

carry bit.

Terminate routine with an RTS.

284

-----------------------------------------------------Page 284-----------------------------------------------------
﻿
NAME

FNDWCH

FNDW13

FNDW10

FNDW15

FNDW2 0

TYPFIL

GETPRE

ADDRESS

$D107

$D10D

$D10F

$D113 $D114 $D115

$D117

$D119

$D121

$D123

$D125

$D127

$D129

$D12E

$D12F

$D132

$D134

$D136

DESCRIPTION OF WHAT ROM ROUTINE DOES

Find the assigned write channel:

Compare the current secondary address from SA ($83) with $13 (#19) the

highest allowable secondary address+1. If too large, branch to FNDW13. AND the secondary address with $0F

NOTE: This masks off the high order bits

of the internal channel sec adr's:

Internal read $11 (17) -> $01 Internal write $12 (18) -> $02

Transfer the sec addr from .A to .X, and load the channel number assigned to this sec addr from LINTAB,X ($022B,X).

Transfer this channel number to .Y. Do an ASL of the channel number in .A.

If a channel has been assigned for this sec addr (bit 7 of LINTAB,X is not set)

branch to FNDW15.

If no channel assigned has been assigned for this secondary address (bit 6 also set), branch to FNDW20 and abort.

Transfer the original sec addr from .Y to .A, AND it with $0F to mask off any high order bits, and store it in LINDX ($82) as the currently active channel.

Transfer the channel number to .X, clear the carry flag, and terminate with RTS. If bit 6 of LINTAB,X is set (indicates an inactive channel), branch to FNDW10. Abort by setting the carry flag and

terminate the routine with an RTS.

Get current file type:

Load .X with the current channel number

from LINDX ($82) .

Load .A with the file type from the file type table, FILTYP,X ($EC,X). Divide the file type by 2 (LSR), AND it with $07 to mask off higher order bits, and compare the result with $04

'(set the Z flag if it is a REL file!).

Terminate the routine with an RTS.

Set buffer pointers:

JSR to GETACT ($DF93) to get the active buffer number (in .A).

Multiply the buffer number by 2 (ASL)

and transfer the result into .X.

Load .Y with the current channel number

from LINDX ($82) .

Terminate the routine with an RTS.

285

-----------------------------------------------------Page 285-----------------------------------------------------
﻿
NAME

GETBYT

GETB2

GETB1

RDBYT

RD01

RD1

ADDRESS

$D137

$D13A

$D13D $D13F

$D142

$D149 $D14D

$D150 $D151

$D153 $D155

$D156

$D162

$D164

$D167 $D169 $D16A

$D16D

$D172

$D175

$D179

$D17B

$D180

DESCRIPTION OF WHAT ROM ROUTINE DOES

Read one byte from the active buffer: If last data byte in buffer, set Z flag. JSR to GETPRE to set buffer pointers. Load .A with the pointer to the last character read from LSTCHR,Y ($0244,Y). If pointer is zero, branch to GETB1. Load the data byte from (BUFTAB,X) ($99,X) and save it on the stack.

Load the pointer from BUFTAB,X ($99,X) and compare it to the pointer to the last character read in LSTCHR,Y. If the pointers are not equal, branch to GETB2. Store $FF in BUFTAB,X ($99,X)

Pull the data byte off the stack and increment BUFTAB,X ($99,X). This will set the Z flag if this is the last byte.

Terminate routine with an RTS.

Load the data byte from (BUFTAB,X)

($99,X).

Increment BUFTAB,X ($99,X).

Terminate routine with an RTS.

Read byte from file:

The next file will be read if necessary and CHNRDY($F2) will be set to EOI if

we have read the last character in file.

JSR to GETBYT to read a byte from the active buffer. On return, if Z flag is not set, we did not read the last byte

in the buffer so branch to RD3 and RTS.

We read the last byte so load .A with $80, the EOI flag.

Store the channel status (in .A) into CHNRDY,Y ($00F2,Y).

Load .A with the byte from DATA ($85).

Exit from routine with an RTS.

JSR to DBLBUF ($CF1E) to begin double buffering.

Load .A with $00 and JSR to SETPNT

($D4C8) to set up the buffer pointers

JSR to GETBYT ($D137) to read the first byte from the active buffer (track link) Compare the track link to $00. If it is $00, there is no next block so branch

to RD4.

There is another block in this file so store the track link in TRACK ($80) . JSR to GETBYT ($D137) to read the next byte from the active buffer(sector link) and store it in SECTOR ($81) .

JSR to DBLBUF ($CF1E) to begin double buffering.

286

-----------------------------------------------------Page 286-----------------------------------------------------
﻿
NAME

ADDRESS
 DESCRIPTION OF WHAT ROM ROUTINE DOES

RD3 RD4

$D183

$D186

$D189

$D18C

$D18F $D191 $D192

$D195

$D19A $D19C

JSR to SETDRN ($D1D3)

drive number.

JSR to SETHDR ($D6D0) next header image. JSR to RDBUF ($D0C3)

block in the file.

JSR to DBLBUF ($CF1E)

active & inactive buf

Load .A with the byte

Exit from routine wit

JSR to GETBYTE ($D137 byte.

Load .Y with the curr

from LINDX ($82) and character as the poin

character read from t

LSTCHR,Y ($0244,Y).

Load .A with the byte

Exit from routine wit

to set up the

to set up the

to read in the next

to toggle the

fers & read ahead.

from DATA ($85) .

h an RTS.

) to get the next

ent channel number store the new

ter to the last- he data buffer

from DATA ($85) .

h an RTS.

WRTBYT

WRTO

$D19D

$D1A0

$D1A2 $D1A3

$D1A6

$D1A9

$D1AB

$D1B3

$D1B8

$D1BB

$D1BE

$D1C1

Write character to the active channel:

If this fills the buffer, write the

data buffer out to disk.

JSR to PUTBYT ($CFF1) to write the byte

to the active channel.

If Z flag is set. on return, the buffer

is full so branch to WRTO.

Exit from routine with an RTS.

JSR to SETDRN ($D1D3) to set the current

drive number from the one in LSTJOB.

JSR to NXTTS ($F11E) to get the next

available track and sector.

Load .A with $00 and JSR to SETPNT

($D4C8) to set up the buffer pointers.

Load .A with the next available track

from TRACK ($80) and JSR to PUTBYT ($CFF1) to store the track link.

Load .A with the next, available sector

from SECTOR ($81) and JSR to PUTBYT ($CFF1) to store the sector link.

JSR to WRTBUF ($D0C7) to write out the

buffer to disk.

JSR to DBLBUF ($CF1E) to toggle the active and inactive buffers and set up

the next inactive buffer.

JSR to SETHDR ($D6D0) to set up the header image for the next block.

Load .A with $02 (to bypass the track

and sector link) and JMP to SETPNT to

set up the pointers to the next buffer.

287

-----------------------------------------------------Page 287-----------------------------------------------------
﻿
NAME

INCPTR

SETDRN

GETWCH

GETRCH

GETR2

ADDRESS

$D1C6 $D1C8

$D1CB

$D1D2

$D1D3

$D1D6

$D1DA

$D1DE

$D1DF

$D1E0

$D1E2

$D1E3

$D1E4

$D1E6

$D1E9

$D1EC

$D1EE

DESCRIPTION OF WHAT ROM ROUTINE DOES

Increment, the pointer of the active buffer by .A

Store the value from .A in TEMP ($6F). JSR to GETPNT ($D4E8) to get the active buffer pointer (in .A).

Clear the carry flag and add the value from TEMP ($6F). Store the result into BUFTAB,X ($99,X) and into DIRBUF ($94).

Terminate routine with an RTS.

Set drive number:

Sets DRVNUM to the same drive as was

used on the last job for the active

buffer.

JSR to GETACT ($D4E8) to get the active buffer number (in .A).

Transfer the buffer number to .X and use

it as an index to load the last job number from LSTJOB,X ($025B) into .A. AND the job number with $01 to mask off

all but the drive number bit and store the result as the current, drive number

in DRVNUM ($7F).

Terminate routine with an RTS.

Open a new write channel:

.A = number of buffers needed

The routine allocates a buffer number

and sets the logical file index, LINDX. Set. the carry flag to indicate that we

want a write channel. Branch to GETR2.

Open a new read channel:

•A = number of buffers needed

The routine allocates a buffer number

and sets the channel*, LINDX.

Clear the carry flag to indicate that we

want a read channel.

Save the processor status (the carry flag) onto the stack.

Save the number of buffer needed (in .A) into TEMP ($6F).

JSR to FRECHN ($D227) to free any

channels associated with this secondary

address.

JSR to FNDLNX ($D37F) to find the next free logical index (channel) to use and

allocate it.

Store the new channel number in LINDX as the current channel number.

Load .X with the current secondary address from SA ($83) .

288

-----------------------------------------------------Page 288-----------------------------------------------------
﻿
NAME

GETR5 2

GETR55

GETR3

GETERR

GETR5

GETR4

FRECHN

FRECO

ADDRESS

$D1F0

$D1F3

$D1F5

$D1F8

$D1FB

$D206

$D20A

$D20F

$D212

$D217

$D21A

$D21E

$D223

$D226

$D227

$D22D

$D22E

DESCRIPTION OF WHAT ROM ROUTINE DOES

Pull the processor status off the stack and if carry flag is clear (read),

branch to GETR55.

OR the channel number in .A with $80 to set bit. 7 to indicate a write file. Store the channel number (in .A) into the logical index table, LINTAB,X

($022B,X).

NOTE: Bit 7 set for a write channel AND the channel number in .A with $3F to mask off the write channel bit. and transfer the result to .Y.

De-allocate any buffers associated with this channel by storing $FF in BUF0,Y ($00A7,Y), in BUF1,Y ($00AE,Y), and in

SS,Y ($00CD,Y).

Decrement the value in TEMP ($6F). This

is the number of buffers to allocate.

If there are no more to allocate ($FF),

branch to GETR4 and exit.

JSR to GETBUF ($D28E) to allocate a new buffer. If a buffer was allocated,

branch to GETR5.

No buffers available, so JSR to RELBUF ($D25A) to release any buffers allocated

Load .A with $70 to indicate a NO

CHANNEL error and JMP to CMDERR ($C1C8). Store the buffer number (in .A) into BUF0,Y ($00A7,Y).

Decrement the value in TEMP ($6F). This

is the number of buffers to allocate.

If there are no more to allocate ($FF),

branch to GETR4 and exit.

JSR to GETBUF ($D28E) to allocate a new buffer. If a buffer was NOT allocated,

branch to GETERR and abort.

Store the buffer number (in .A) into BUF1,Y ($00AE,Y).

Terminate routine with an RTS.

Free channel associated with SA

Read and write channel's are freed. The

command channel is not freed.

Load .A with the secondary address from SA ($83). Compare it with $0F (#15), the command channel secondary address. If the secondary address is not $0F, branch

to FRECO.

Since we are not to free the command

channel, simply exit with an RTS.

Free data channel associated with SA:

Load .X with the secondary address from

SA ($83).

289

-----------------------------------------------------Page 289-----------------------------------------------------
﻿
NAME

RELINX

REL 15

REL10

FRE25

RELBUF

REL1

ADDRESS

$D230

$D237

$D23B

$D240

$D246 $D249

$D24D

$D250

$D251 $D253

$D259

$D25A

$D25C

$D262

$D267

$D26B

$D26D

$D273

$D278

DESCRIPTION OF WHAT ROM ROUTINE DOES

Load .A with the channel number

associated with this secondary address from LINTAB,X ($022B,X) . If it. is $FF,

there is no associated channel so branch to FRE25 and exit.

AND the channel number with $3F to mask

off the higher order bits and store the

result as the current channel in LINDX

($82) .

Free the channel by storing $FF into LINTAB,X ($022B,X).

Load .X with the channel number from

LINDX ($82) and store $00 as the channel status (free) in CHNRDY,X ($F2,Y).

JSR to RELBUF ($D25A) to release buffers

Load .X with the channel number from

LINDX ($82) and .A with $01.

Decrement. .X, the channel number. If it is $FF (no lower channel numbers),

branch to REL10.

Do an ASL on the value in .A. Note that

the bit set. shifts left one position each time through the loop.

If .A <> 0, branch to REL15 (always).

OR the value in the accumulator with LINUSE ($0256) to free the channel (bit = 1 for free; bit = 0 for used).

Store the resulting value back in LINUSE ($0256).

Terminate routine with an RTS.

Release buffers associated with channel: Load .X with the channel number from

LINDX ($82).

Load .A with the buffer number for this

channel from BUF0,X ($A7,X). Compare the buffer number with $FF (free) . If it. is already free, branch to REL1.

Save the buffer number on the stack and

store $FF into BUF0,X ($A7,X) to free

this buffer.

Pull the buffer number off the stack and JSR to FREBUF ($D2F3) to free the buffer Load .X with the channel number from LINDX ($82) .

Load .A with the buffer number for this

channel from BUF1,X ($AE,X). Compare the buffer number with $FF (free). If it is already free, branch to REL2.

Save the buffer number on the stack and

store $FF into BUF1,X ($AE,X) to free

this buffer.

Pull the buffer number off the stack and

JSR to FREBUF ($D2F3) to free the buffer

290

-----------------------------------------------------Page 290-----------------------------------------------------
﻿
NAME

REL2

REL3

GETBUF

GBF1

GBF2

ADDRESS

$D27C

$D27E

$D284

$D289

$D28D

$D28E

$D28E

$D290

$D297

$D29D

$D2A3

$D2A7

$D2AE

$D2B1

$D2B6

$D2B8

$D2B9

DESCRIPTION OF WHAT ROM ROUTINE DOES

Load .X with the channel number from

LINDX ($82) .

Load .A with the side sector for this

channel from SS,X ($CD,X). Compare the side sector with $FF (free). If it is already free, branch to REL3.

Save the side sector on the stack and

store $FF into SS,X ($CD,X) to free the side sector pointer.

Pull the side sector off the stack and

JSR to FREBUF ($D2F3) to free any buffer

Terminate routine with an RTS.

Get a free buffer number: .Y=channel # If successful, initialize JOBS & LSTJOB and return with buffer number in .A.

If not. successful, .A = $FF; N flag set. Save channel number by transferring it from .Y to .A and pushing it on the

stack.

Load .Y with $01 and JSR to FNDBUF

($D2BA) to find a free buffer (# in .X).

If one is found, branch to GBF1.

Decrement .Y and JSR to FNDBUF ($D2BA) to find a free buffer (# in .X). If one found, branch to GBF1.

Can't, find a free one so let's try to steal one! JSR to STLBUF ($D339) to try to steal an inactive one. On return, buffer # in .A so transfer it to .X. If

we didn't get one, branch to GBF2.

Wait till any job using JOBS,X ($00,X) is completed.

Clear the job queue by setting JOBS,X ($00,X) and LSTJOB,X ($025B,X) to the current drive number using the value from DRVNUM ($7F).

Transfer the buffer number from .X to .A

multiply it by two (ASL), and transfer

the result to .Y.

Store a $02 on BUFTAB,Y ($0099,Y) so the pointer points beyond the track and

sector link.

Restore the original .Y value from the

stack.

Transfer the buffer number from .X to .A

to set the N flag if not. successful.

Terminate routine with an RTS.

291

-----------------------------------------------------Page 291-----------------------------------------------------
﻿
NAME

FNDBUF FBI

FB2

FB3

FRI20

FREIAC

FRI10

ADDRESS

$D2BA $D2BC

$D2C4

$D2C7

$D2C8

$D2D1

$D2D5

$D2D8 $D2D9

$D2DA

$D2DC

$D2E0

$D2E5

$D2E9

$D2ED $D2EE

$D2F2

DESCRIPTION OF WHAT ROM ROUTINE DOES

Find a free buffer and set BUFUSE:

On entry: .Y = index into BUFUSE

Y=0 buffers 0-7; Y=l buffers 8-15 If successful, .X = buffer number

If not successful, .X = $FF; N flag set Load .X with $07 (for bit test)

Load .A with BUFUSE,Y ($024F,X). Each

bit indicates whether a buffer is free

(1) or in use (0). AND this value in .A with the bit mask, BMASK,X ($EFE9,X). Each of these masks has just one bit- set. If the result of the AND is $00,

we have found a free buffer so branch to FB2.

Decrement .X to try next buffer. If any left, branch back to FBI.

No more buffers to try (,X=$FF) so exit

with an RTS.

Found a free buffer so let's grab it! Load .A with the value in BUFUSE,Y ($024F,Y), EOR it. with the bit map for the free buffer, BMASK,X ($EFE9,X), and store the result, back in BUFUSE,Y.

Transfer the buffer number from .X to

•A and if .Y is $00, branch to FB3. Since .Y is $01 (never happens on the

1541), we have to add 8 to the buffer number. So: Clear the carry flag and add $08 to the buffer number in .A.

Transfer the buffer number from .A to .X Terminate routine with an RTS.

Free the inactive buffer:

Load .X with the current channel number

from LINDX ($82) .

Load .A with the buffer number from

BUF0,X ($A7,X). If bit. 7 is set, branch

to FRI10.

Transfer the channel number from .X to

.A, clear the carry flag, add $07 (the maximum number of channels +1), and

transfer the result back into .X. This is the alternate buffer for this channel

Load .A with the buffer number from

BUF0,X ($A7,X). If bit. 7 is NOT set,

this buffer is active too so exit to FRI20 (above).

Compare the buffer number to $FF. If it is $FF, the buffer is free already so

exit to FRI20 (above).

Save the buffer number on the stack.

Free the buffer by storing $FF into BUF0,X ($A7,X).

Pull the buffer number off the stack.

292

-----------------------------------------------------Page 292-----------------------------------------------------
﻿
NAME

FREBUF

FREB1

CLRCHN

CLRC1

CLDCHN

CLSD

ADDRESS

$D2F3

$D2F7 $D2F9

$D307

$D30B

$D30E

$D312

$D313

$D317

$D320

$D324

$D327

$D32B

$D331

$D334

$D338

DESCRIPTION OF WHAT ROM ROUTINE DOES

Free buffer in BUFUSE:

AND the buffer number with $0F to mask

off any higher order bits, transfer the result, into .Y and increment .Y by 1. Load .X with $10 (#16) 2*8 bits

Loop to ROR BUFUSE+1 ($0250) and BUFUSE ($024F) 16 times. Use .Y to count, down to 0. When .Y is zero, the bit that corresponds to the buffer we want, is in the carry flag so we clear the carry bit to free that buffer. We then keep looping until .X has counted down all the way from $10 to $FF. When .X reaches $FF, the bits are all back in the right places, so exit with an RTS.

Clear all channels except, the CMD one: Set the current secondary address in SA

($83) to $0E (#14)

JSR to FRECHN ($D227) to free the

channel whose secondary address is SA

Decrement the value in SA ($83). If it is not $00, branch back to CLRC1.

Terminate routine with an RTS.

Close all channels except the CMD one: Set the current, secondary address in SA

($83) to $0E (#14)

Load .X with the secondary address from SA ($83) and use it as an index to load •A with the channel number from LINTAB,X ($022B,X). Compare the channel number with $FF; if equal, no channel has been assigned so branch to CLD2.

AND the channel number with $3F to mask

off the higher order bits and store the

result in LINDX ($82) as the current.

channel number.

JSR to GETACT to get the active buffer number for this channel (returned in .A)

Transfer the buffer number to .X and

use it load .A with the last job number for this buffer from LSTJOB,X ($025B,X). AND the last job number with $01 and

compare it. with the current drive number in DRVNUM ($7F). If not equal, branch to

CLD2.

JSR to FRECHN ($D227) to free this

channel.

Decrement the secondary address in SA ($83) and if there are more to do (not

$FF yet), branch back to CLSD

Terminate routine with an RTS.

293

-----------------------------------------------------Page 293-----------------------------------------------------
﻿
NAME

STLBUF

STL05

STL10

STL20

STL30

STL40

ADDRESS

$D339

$D33E

$D340

$D344

$D348

$D34D

$D355

$D35A

$D35E

$D360

$D363

$D367

$D36B

$D36F

DESCRIPTION OF WHAT ROM ROUTINE DOES

Steal an inactive buffer:

Scan the least recently used table and

steal the first inactive buffer found. Returns the stolen buffer number in .A Save the value in TO ($6F) on the stack and zero .Y (the index to LRUTBL). Load .X (the channel index) with the value from LRUTBL,Y ($FA,Y).

Load .A with the buffer status for this channel from BUF0,X ($A7,X). If this buffer is active (status < 128), branch

to STL10.

Compare the status to $FF (unused). If not. equal, it's inactive so branch to

STL30 to steal it!

Transfer the channel number from .X to

.A, clear the carry flag, add $07 (the maximum number of channels +1), and transfer the result, back into .X. Note

•X now points to the alternative buffer

for this channel.

Load .A with the buffer status for this

channel from BUF0,X ($A7,X). If this buffer is active (status < 128), branch to STL3 0.

Increment .Y and compare the new value

with #$05 (the maximum number of

channels +1). If there are still some channels left to check, branch to STL0 5 No luck stealing a buffer so load .X with $FF (indicates failure) and branch

to STL60 to exit.

Store the channel number (in .X) into

TO ($6F) temporarily.

AND the buffer number in .A with $3F to

mask off any higher order bits and

transfer the result to .X.

Check if the buffer is being used for a job currently underway by loading .A with the job queue byte for the buffer from JOBS,X ($00,X). If bit 7 is set, a job is in progress so branch back to STL40 to wait for completion.

Compare the job queue value with $02 to see if any errors occurred. If there were no errors (job queue was $01),

branch to STL50 to steal the buffer. No luck so load .X with the value we

save into TO ($6F) and compare it to $07 (the maximum number of channels+1). If .X < $07 we still need to check the

alternative buffer for this channel so branch to STL10.

294

-----------------------------------------------------Page 294-----------------------------------------------------
﻿
NAME

STL50

STL60

FNDLDX

FND10

FND3 0

GBYTE

GET

ADDRESS

$D371

$D373

$D37A

$D37F

$D383

$D388

$D38E

$D391

$D399

$D39B

$D39E

$D3A1

$D3A4

$D3A9

$D3AA

DESCRIPTION OF WHAT ROM ROUTINE DOES

If .X >= $07, we were checking the

alternative channel so branch back to STL20 to check the next channel.

We've found an inactive buffer, now to

steal it!

Load .Y with the channel number from TO

($6F) and store $FF into BUF0,Y ($A7,Y)

to steal it.

Pull the original value of TO off the

stack and restore it. Transfer the buffer number from .X to .A (sets the

N flag if not successful) and terminate

routine with an RTS.

Find free LINDX and allocate in LINUSE

Load .Y with $00 and .A with $01.

Test whether the same bit is set in

LINUSE ($0256) and the accumulator. If a

bit is set in LINUSE, the corresponding

channel is free. If the test indicates a

free channel, branch to FND30.

Increment. .Y (the counter) and do an ASL

on the value in the accumulator to shift.

the test bit. one place left. If more tests are needed, branch to FND10.

No channel found so load .A with $70 to

to indicate a NO CHANNEL error and JMP

to CMDERR ($C1C8).

EOR the bit mask (in .A) with $FF to

flip the bits, AND the flipped mask with LINUSE to clear the appropriate bit, and store the result, back in LINUSE ($0256) . Transfer the channel number (LINDX) from

.Y to .A and exit with an RTS.

Get next byte from a channel:

JSR to FNDRCH ($D0EB) to find an unused

read channel.

JSR to SETLDS ($C100) to turn on the drive active light.

JSR to GET ($D3AA) to get one byte from any type of file.

Load .X with the current channel number

from LINDX ($82) and load .A with the data byte from CHNDAT,X ($023E).

Terminate routine with an RTS.

Get next byte from any type of file:

Load .X with the current, channel number

from LINDX ($82) JSR to TYPFIL ($D125) to determine the file type. If Z flag

not set on return, this is not a relative file so branch to GET00.

295

-----------------------------------------------------Page 295-----------------------------------------------------
﻿
NAME

GETOO

GETO

GET1

GET2

RNDGET

RNGET1

RNGET2

RNGET4

ADDRESS

$D3B1

$D3B4

$D3BA

$D3C0

$D3C3

$D3C7

$D3CE

$D3D2 $D3D3

$D3D7

$D3DE

$D3E1

$D3E8

$D3EC

$D3EE

$D3F0 $D3F3

DESCRIPTION OF WHAT ROM ROUTINE DOES

It is a relative file so JMP to RDREL

($E120) to do this type.

Test if the current secondary address from SA ($83) is $0F (the CMD channel). If it is, branch to GETERC ($D414).

Test if the last character we sent on

this channel was an EOI by checking if the channel status in CHNRDY,X ($F2,X) is $08. If the last character was NOT an EOI, branch to GET1.

Last, character was EOI so JSR to TYPFIL

($D125) to determine the file type. If the file type is NOT $07, a random access file, branch to GETO.

This is a direct access file so we will leave it. active. Store an $89 (random access file ready) as the channel status in CHNRDY,X ($F2,X) and exit, with a JMP to RNDGET ($D3DE) to get the next. character ready.

Last, character sent, was EOI so set the

channel status as NOT READY by storing a $00 in CHNRDY,X ($F2,X).

Terminate routine with an RTS.

Test, if this is a LOAD by testing if the secondary address in SA ($83) is a $00. If it is a LOAD, branch to GET6. It's not. a LOAD. Maybe it's a random access file. JSR to TYPFIL ($D125) to determine the file type. If the file type is less than $04, it. is NOT a

random access file, so branch to SEQGET.

It is a random access file so JSR to

GETPRE ($D12F) to set. up the right pointers in .X and .Y.

Load the pointer to the data byte into .A from BUFTAB,X ($99,X). Compare this

value to the pointer to the last

character pointer in LSTCHR,Y ($0244,Y) to see if we are up to the last one yet. If not, branch to RNGET1.

We're at the last character so wrap the pointer around to the start again by storing $00 in BUFTAB,X ($99,X).

Increment. BUFTAB,X ($99,X) to point, to

the next character.

Load .A with the data byte from BUFTAB,X ($99,X).

Save the data byte in CHNDAT,Y ($023E,Y) Load the pointer from BUFTAB,X and compare it to the value in LSTCHR,Y ($0244,Y) to see if this is the last

character we're supposed to get. If NOT,

branch to RNGET3.

296

-----------------------------------------------------Page 296-----------------------------------------------------
﻿
NAME

RNGET3 SEQGET

GET3

GET6

GETERC

GE10

GE15

GE20

GE30

ADDRESS

$D3FA

$D3FF $D400

$D403

$D408 $D409

$D40E

$D414

$D41B

$D421

$D428

$D42D

$D433

$D43A

$D43F

$D443

$D445

DESCRIPTION OF WHAT ROM ROUTINE DOES

Since this is the last, character, set the channel status in CHNRDY,Y to $00 to indicate an EOI (end of information).

Terminate routine with an RTS.

JSR to RDBYT ($D156) to read the next. data byte.

Load .X with the channel number from

LINDX ($82) and store the data byte in CHNDAT,X ($00F2,X).

Terminate routine with an RTS.

Seems to be a LOAD. Test, if it is a

directory listing by seeing if DIRLST

($0254) is a $00. If it is, this is not.

a directory listing so branch to SEQGET. It is a directory listing so JSR to GETDIR ($ED67) to get a byte from the directory and then JMP to GET3.

Get. byte from the error channel:

JSR to GETPNT ($D4E8) to read the active buffer pointer. If the buffer number is NOT $D4, lo byte of the pointer to one byte below error buffer, branch to GE10. Check if DIRBUF+1 ($95) equals $02, the hi byte of the pointer to the error buffer. If not, branch to GE10.

Store a $0D (#13; RETURN) in DATA ($85) and JSR to ERROFF ($C123) to turn off

the error LED.

Load .A with $00 and JSR to ERRTS0

($E6C1) to transfer the error message

to the error buffer.

Decrement. CB + 2 ($A5) so this pointer points to the start, of the message,

.load .�A with._$.8Q (Ed-out sJca-tUS.)-, anrL..

branch (always!) to GE30.

JSR to GETBYT ($D137) to read a byte of the error message. Store the bvte in DATA ($85) and, if not $00, branch to

GE20.

Load .A with $D4, the lo byte cf the pointer to one byte below the error

buffer and JSR to SETPNT ($D4C8) to set the pointers to the error buffer.

Store the hi byte of the pointer to the error buffer ($02) into BUFTAB+1,X

($9A,X).

Load .A with $88, the channel status byte for ready-to-talk.

Store the value in .A as the error

channel status in CHNRDY+ERRCHN ($F7).

297

-----------------------------------------------------Page 297-----------------------------------------------------
﻿
NAME
 ADDRESS

$D447

$D44C

DESCRIPTION OF WHAT ROM ROUTINE DOES

Load .A with the byte from DATA ($85) and store it as the channel data byte

for the error channel in CHNDAT+ERRCHN

($0243) .

Terminate routine with an RTS.

Read in the next block of

a file by

following the track and se

ctor link.

Set an EOF (end of file) i

ndicator if

the track link (first byte
 ) is $00.

NXTBUF

NXTB1

$D44D

$D452

$D456

$D45A

$D45F

JSR to GETACT ($DF9 3) to g

buffer number (in .A). Mul buffer number by 2 (ASL) a

to .X.

Store a $00 in BUFTAB,X ($ the buffer pointer to the Check first byte (track li buffer, (BUFTAB,X). If it are no more blocks to get

NXTB1.

Decrement the buffer point ($99,X) by 1 so it. is $FF

RDBYT ($D156). This forces

next sector because we set to the end of the current Terminate routine with an

et the active

tiply the

nd transfer it

9 9,X) to set first byte.

nk) in the

is zero, there

so branch to

er, BUFTAB,X

and JSR to

a read of the

the pointer

buffer. RTS.

DRTRD

DRTWRT DRT

OPNIRD

OPNTYP

$D460

$D464 $D466

$D46B

$D470

$D475

$D477 $D47A

Direct block read:

Load .A with $80, the job code for read

and branch to DRT.

Direct block write:

Load .A with $90, the job code for write OR the job code in .A with the current

drive number in DRVNUM ($7F) and store the result in CMD ($024D).

Load .A with the number of the buffer

to use for the job from JOBNUM ($F9) and JSR to SETH ($D6D3) to set up the header image for the job.

Load .X with the number of the buffer

to use for the job from JOBNUM ($F9) and JMP to DOIT2 ($D593) to do the job.

Open internal read channel: (SA=17) Use this entry point for PRG files. Load .A with $01 (program file type)

Open internal read channel (.A=any type) Use this entry point for any file type. Store file type (.A) into TYPE ($024A) Store $11 (#17) as the current secondary

address in SA ($83) .

298

-----------------------------------------------------Page 298-----------------------------------------------------
﻿
NAME

OPNIWR

NXDRBK

ADDRESS

$D47E

$D481

$D486

$D48A

$D48D

$D490

$D497

DESCRIPTION OF WHAT ROM ROUTINE DOES

JSR to OPNRCH ($DC46) to open a read

channel.

Set .A to $02 and JMP to SETPNT ($D4C8) to set the buffer pointer to point past

the track and sector link.

Open internal write channel (SA=18)

Store $12 (#18) as the current, secondary address in SA ($83).

JMP to OPNWCH ($DCDA) to open the write

channel.

Allocate the next directory block:

JSR to CURBLK ($DE3B) set. the TRACK ($80) and SECTOR ($81) values from the current

header.

Set TEMP ($6F) to $01 and save the current, value of SECINC ($69) , the sector increment used for sequential files, on the stack.

Set. the sector increment, SECINC ($69) to $03, the increment, used for the directory track.

$D49B

JSF to NXTDS ($F12D)

next available track

to determine and sector.

the

$D49E

$D4A1

Restore the original in SECINC ($69) from Set .A to $00 and JSR

sector increment the stack.

to SETPNT ($D4C8]

NXDB1

SETPNT

$D4A6

$D4AB

$D4B0

$D4B3

$D4B6

$D4BB $D4C0

$D4C3

$D4C8

to set the pointer to the first, byte in the active buffer (track byte).

Load .A with the next track from TRACK

($80) and JSR to PUTBYT ($CFF1) to

store the track link in the buffer.

Load .A with the next sector from SECTOR

($81) and JSR to PUTBYT ($CFF1) to

store the sector link in the buffer.

JSR to WRTBUF ($D0C7) to write the

buffer out to disk.

JSR to WATJOB ($D599) to wait until the

write job is complete.

Set .A to $00 and JSR to SETPNT ($D4C8) to set the pointer to the first, byte in the active buffer (track byte). Loop to zero the entire buffer.

JSR to PUTBYT ($CFF1) to store $00 as

the next track link.

Load .A with $FF and JMP to PUTBYT

($CFF1) to store $FF as the sector link.

Set up pointer into active data buffer On entry: .A contains new pointer value Save the new pointer (in .A) into TEMP ($6F) and JSR to GETACT ($DF93) to find

the active buffer number (in .A).

299

-----------------------------------------------------Page 299-----------------------------------------------------
﻿
NAME

FREICH

ADDRESS

$D4CD

$D4CF

$D4D3

$D4D9

$D4DA

$D4E1

DESCRIPTION OF WHAT ROM ROUTINE DOES

Multiply the buffer number by 2 (ASL)

and transfer the result into .X.

Move the high byte of the buffer pointer from BUFTAB+1,X ($9A,X) to DIRBUF + 1 ($95) Load the new buffer pointer value from TEMP ($6F) into .A. Store this new value into BUFTAB,X ($99,X) and DIRBUF ($94).

Terminate routine with an RTS.

Free both internal channels: (SA=17&18) Set SA ($83) to $11 (#17) the internal read channel and JSR to FRECHN ($D227) to free the internal read channel.

Set SA ($83) to $12 (#18) the internal write channel and JMP to FRECHN ($D227)

to free the internal write channel.

GETPNT

$D4E8

Get the active buffer po JSR to GETACT ($DF93) to

inter:

get the active

buffer number (in .A).

SETDIR

$D4EB

$D4ED

$D4F1

$D4F5

Multiply the buffer numb

and transfer the result.

Move the hi byte of the from BUFTAB+1,X ($9A,X) byte of the directory bu DIRBUF + 1 ($95) .

Move the lo byte of the from BUFTAB,X ($99,X) in

of the directory buffer ($94). (.A = lo byte of

Terminate routine with a

er by two (ASL)

into .X.

buffer pointer

into the hi

ffer pointer

buffer pointer to the lo byte pointer DIRBUF

the pointer)

n RTS.

DRDBYT

SETLJB

$D4F6

$D4F8

$D4FB

$D501

$D505

$D506

Direct read of a byte: (.A = position) On entry:.A = position of byte in buffer On exit:.A = data byte desired

Store lo byte of pointer to desired byte

(in .A) into TEMP+2 ($71).

JSR to GETACT ($DF9 3) to get the active buffer number (in .A).

Transfer buffer number into .X and load

.A with the hi byte of the active buffer pointer from BUFIND,X ($FEE0,X). Store this value into TEMP+3 ($72) . This

creates a pointer to the byte in $71/72.

Zero .Y and load .A with the desired

byte from (TEMP+2),Y; ($71),Y.

Terminate routine with an RTS.

Set up job using last job's drive:

NOTE: For this entry, job code is in CMD

and .X is buffer number (job #)

Load .A with previous job number from LSTJOB,X ($025B,X), AND the job number with $01 to leave just the drive number

300

-----------------------------------------------------Page 300-----------------------------------------------------
﻿
NAME

SETJOB

SJB2

SJB3

ADDRESS

$D50E

$D511

$D514

$D519

$D51D

$D522

$D523

$D525

$D52B

$D52D

$D530

SD535

$D538

DESCRIPTION OF WHAT ROM ROUTINE DOES

bits, and OR the result with the new job code on CMD ($024D). The resulting new job code is in .A.

Set. up new job:

NOTE: For this entry, job code is in .A

and .X is buffer number (job #)

Save new job code on the stack and store

the number of the buffer to use (.X) in JOBNUM ($F9) .

Transfer the buffer number from .X to

.A, multiply it by 2 (ASL) and transfer

it back into .X.

Move the desired sector from HDRS+1,X

($07,X) into CMD ($024D).

Load .A with the desired track from

HDRS,X ($06,X). If it is $00, branch to TSERR ($D54A).

Compare the desired track (in .A) with

the maximum track number from MAXTRK

($FED7) . If it. is too large, branch to

TSERR ($D54A).

Transfer the desired track number from

.A to .X.

Pull the job code off the stack and

immediately push it back onto the stack. AND the job code in .A with $F0 to mask off the drive bits and compare it to $90 (the job code for a write). If this is

not a write job, branch to SJB1. Pull the job code off the stack and

immediately push it. back onto the stack. Do an LSR on the job code in .A to

find the drive to use. If it is drive 1,

branch to SJB2.

Use drive 0 so load DOS version from DSKVER ($0101) and branch to SJB3. Use drive 1 so load DOS version from DSKVER+1 ($0102) .

If DOS version is $00 (no number), it is OK, so branch to SJB4.

NOTE: On the 1541 the DOS version code

(normally 65) is stored in ROM,

not in RAM as on the 4040. This

means you can not soft set a

DOS version number on the 1541!

However, a DOS version number of $00 is OK.

301

-----------------------------------------------------Page 301-----------------------------------------------------
﻿
NAME

SJB4

TSERR

TSER1

HED2TS

ADDRESS

$D53A

$D53F

$D54A

$D54D

$D552

$F556

$F55A

$F55E

DESCRIPTION OF WHAT ROM ROUTINE DOES

Compare the DOS version number with the

1541 DOS version number ($65) from

VERNUM ($FED5). If the version numbers do not match, branch to VNERR ($D572).

Transfer the desired track number from .X to .A and JSR to MAXSEX ($F24B) to

calculate the maximum sector number+1

for this track (returned in .A). Compare

this value with the desired sector number in CMD. If the desired sector

number is legal, branch to SJBJ.

Track and/or sector number is illegal so JSR to HED2TS ($D552) to store the

values in TRACK ($80) and SECTOR ($81) . Load .A with $66 to indicate a bad track and sector and JMP to CMDER2 ($E645).

Set desired track and sector values:

Load .A with the number of the buffer to

use for this job from JOBNUM ($F9). Multiply the buffer number by 2 (ASL)

and transfer it to .X.

Move the desired track number from

HDRS,X ($06,X) to TRACK ($80).

Move the desired sector number from

HDRS+1,X ($07,X) to SECTOR ($81).

Terminate routine with an RTS.

TSCHK

$D55F

$D563

$D5 6 8

$D571

Check f Load .A

is $00, Compare

number

large,

JSR to

maximum track.

Termina

or bad track an

from TRACK ($8

branch back to the track to t

allowed, MAXTRK

branch back to

MAXSEC ($F24B)

sector number

If too large, b

te routine with

d sector values:

0). If the track

TSER1 ($D54D).

he maximum track

($FED7). If too

TSER1.

to calculate the allowed on this ranch to TSER1.

an RTS.

VNERR

SJB1

$D572

$D575

$D57A

$D57C $D57D

Bad DOS version number:

JSR to HED2TS ($D552) to store the

values in TRACK ($80) and SECTOR ($81). Load .A with $73 to indicate a bad DOS version number and JMP to CMDER2 ($E645)

Conclude job set. up:

Load .X with the number of the buffer to

use for the job from JOBNUM ($F9). Pull the job code off the stack. Store the job code as the current

command in CMD ($024D), in the job queue at JOBS,X ($00,X) to activate the disk controller, and in LSTJOB,X.

302

-----------------------------------------------------Page 302-----------------------------------------------------
﻿
NAME

DOREAD

DOWRIT DOJOB

DOIT

DOIT2

WATJOB

TSTJOB

ADDRESS

$D585

$D586

$D58A $D58C

$D58E

$D590 $D593 $D596

$D599

$D59C $D59E $D59F

$D5A4 $D5A5

$D5A6

$D5A8

$D5AA

$D5AE

DESCRIPTION OF WHAT ROM ROUTINE DOES

Terminate routine with an RTS.

Do a read job; return when done OK:

Load .A with $80, the read job code and

branch to DOJOB.

Do a write job; return when done OK: Load .A with $90, the write job cede. OR the job code with the current drive number in DRVNUM ($7F).

Load .X with the number of the buffer to

use for the job from JOBNUM ($F9).

Store complete job code in CMD ($024D). Lead .A with job code from CMD ($024D). JSR to SETJOB ($D50E) to start job.

Wait, until job is completed:

JSR to TSTJOB ($D5A6) to check if job is done yet (error code returned in .A). If job not done yet, branch to WATJOB.

Save error cede on the stack.

Set job completed flag, JOBRTN ($0298) ,

to $00.

Recover error code from stack (in .A).

Terminate routine with an RTS.

Test if job done yet:

If not done, return. If done OK, then

return. If not OK, redo the job.

Load .A with value from the job queue, JOBS,X ($00,X).

If .A > 127, job not done yet so branch to NOTYET to exit with carry flag set. If .A < 2, job was completed with no

errors so branch to OK to exit with the

carry flag clear.

Compare the error code to $08. If it is $08, a fatal write protect error has

occured so branch to TJ10 and abort.

$D5B2

$D5B6

Compare the error code to $0B. If it $0B, a fatal ID mismatch error has

occured so branch to TJ10 and abort.

Compare the error code to $0F. If it

is

IS

TJ10

$D5BA

NOT $0F, a non-fatal error has occured so branch to RECOV and try again.

NOTE: an error code of $0F means a fatal drive-not-available error has occured.

Test bit 7 of the job return flag,

JOBRTN ($0298). If it is set, the disk

has been initialized and this is the

first attempt to carry out. the job, so branch to OK to return with the carry flag clear.

303

-----------------------------------------------------Page 303-----------------------------------------------------
﻿
NAME

OK

NOTYET

RECOV

REC01

RECO

REC1

ADDRESS

$D5BF $D5C2

$D5C4

$D5C6

$D5CB

$D5D2

$D5D9

$D5E0 $D5E3

$D5E9

$D5ED

$D5F4

$D600

$D606

$D60D

$D613

DESCRIPTION OF WHAT ROM ROUTINE DOES

JMP to QUIT2 ($D63F) to try to recover. Clear the carry flag and terminate the

routine with an RTS.

Set. the carry flag and terminate the

routine with an RTS.

Save .Y value and the current drive

number from DRVNUM ($7F) on the stack. Load the job code for the last job from LSTJOB,X ($025B,X), AND it with $01 to mask off the non-drive bits, and store

the result, as the current drive number

in DRVNUM ($7F) .

Transfer the drive number from .A to .Y and move the LED error mask from

LEDMSK,Y ($FECA,Y) to ERLED ($026D) JSR to DOREC ($D6A6) to do last job recovery. On return, if the error code (in .A) is $01, it worked so branch to

REC01.

Retry didn't, work, JMP to REC95 ($D66D) Load .A with the original job code from LSTJOB,X ($025B,X), AND it with $F0 to mask off the drive number bits, and save

it on the stack.

Check if the job code was $90 (a write job). If not, branch to RECO.

This is a write job. OR the current

drive number from DRVNUM ($7F) with $B8

(the job code for a sector seek) and store the result in LSTJOB,X ($025B,X). This replaces the original write job with a seek job during recovery.

See if the head is on track by checking bit 6 of REVCNT (6A). If this bit is set, the head is on track so branch to

REC 5.

Head net on track so zero the offset

table pointer, EPTR ($0299) and the total offset TOFF ($029A).

Load .Y with the offset table pointer EPTR ($0299) and .A with the total offset TOFF ($029A).

Set the carry flag and subtract the offset OFFSET,Y ($FEDB) from the total

offset in .A. Store the result as the

new total offset in TOFF ($029A).

Load .A with the head offset from

OFFSET,Y and JSR to HEDOFF ($D676) to move the head so it is on track.

Increment the offset table pointer and JSR to DOREC ($D6A6) to attempt to recover. On return, if the error code in .A < $02, the recovery worked so

branch to REC3.

304

-----------------------------------------------------Page 304-----------------------------------------------------
﻿
NAME

REC 3

REC 5

QUIT

QUIT2

REC7 REC5

REC8

ADDRESS

$D61D

$D625

$D631

$D635

$D63A

$D63F

$D644 $D645

$D64B

$D651 $D655

DESCRIPTION OF WHAT ROM ROUTINE DOES

That try at recovery did not work so increment the offset table pointer by 1

and load .A with the offset from

OFFSET,Y ($FEDB,Y). If the value loaded is not. $00, branch to REC1 to try again. One more try on the offset. Load .A with the total offset from TOFF ($029A) and JSR to HEDOFF ($D676). If no error on return, branch to REC9.

Check bit 7 of the error recover count

REVCNT ($6A). If this bit is clear,

branch to REC7 to do a bump to track 1. Pull the original job code off the stack. If it is NOT $90 (a write job)

branch to QUIT2.

For write jobs only, OR the job code in

•A with the drive number from DRVNUM

and put the result, in LSTJOB,X ($025B,X) to restore the original value.

Load .A with the error code from JOBS,X ($00,X) and abort, with a JSR to ERROR ($E60A).

Pull the job code off the stack (in .A). Check bit 7 of the job return flag JOBRTN ($0298). If this bit is set,

branch to REC95 to exit with job error. Push the job code back onto the stack. Do a bump to track 1 by loading .A with $C0 (BUMP job code), ORing it with the current drive number from DRVNUM ($7F), and storing the result, in the job queue

at JOBS,X ($00,X).

Wait for current job to be completed. JSR to DOREC ($D6A6) to try one more time. On return, if the error code (.A) is not $01 (no error), give up in disgust, and branch to QUIT.

REC9
 $D65C

Pull the original job code

off the stack

REC95

$D661

$D666

$D66D

$D670

and compare it to $90

(the job code for isn't, a write job,

a write job). If this

branch to REC9 5.

OR the job code (in .A) with the drive number from DRVNUM ($7F) and store the value in LSTJOB,X.

JSR to DOREC ($D6A6) to try one last

time. On return, if the error code (.A) is not $01 (no error), give up in disgust and branch to QUIT2.

Pull the original drive number off the stack and store it. in DRVNUM ($7F).

Pull the original .Y value off the stack

and restore .Y.

305

-----------------------------------------------------Page 305-----------------------------------------------------
﻿
NAME

HEDOFF

HOF1

HOF2

HOF3

ADDRESS

$D6 72

$D676

$D67A

$D67C

$D681

$D686

$D688

$D68D

$D692

DESCRIPTION OF WHAT ROM ROUTINE DOES

Load .A with the error code from JOBS,X

($00,X), clear the carry flag, and exit

with an RTS.

Adjust head offset:

On entry: .A = OFFSET

If .A=0, no offset required so branch

to HOF3.

If .A > 127, head needs to be stepped

inward so branch to HOF2.

We want to move head outward 1 track so:

load .Y with $01 and JSR to MOVHED

($D69 3) to move the head.

On return, set the carry flag and

subtract. $01 from the value in .A. If the result is not $00, the head has not

finished so branch back to HOF1.

If the head is finished moving, branch

to HOF3.

We want, to move head inward 1 track so:

load .Y with $FF and JSR to MOVHED

($D693) to move the head.

On return, clear the carry flag and add $0.1 to the value in .A. If the result is not $00, the head has not

finished so branch back to HOF2. Terminate routine with an RTS.

Step head inward o

r outward 1 track:

MCVHED

MH10

$D693 $D694

$D695

$D697 $D69A

$D69F

$D6A4 $D6A5

Save the value in Transfer the numbe

(phase) from .Y in

Load .Y with the c

from DRVNUM ($7F). Store the phase in Compare the phase in PHASE,Y ($02FE,

the controller hes head so branch bac

Store $00 in PHASE

won't move any mor Pull original valu

Terminate routine

.A onto the stack.

r of steps to move

to .A.

urrent drive number

to PHASE,Y ($02FE,Y).

in .A with the value

Y). If they are equal,

not yet moved the

k to MH10.

,Y ($02FE,Y) so head

e.

e of .A off the stack. with an RTS.

DOREC

DOREC1

$D6A6

$D6AB

Load .A with the retry counter, REVCNT ($6A), AND it with $3F to mask off the high order bits, and transfer the result

into .Y.

Load .A with the error LED mask from

ERLED ($026D), EOR it with the disk controller port B, DSKCNT ($1C00) and store it back in DSKCNT ($1C00) to turn the drive light OFF.

306

-----------------------------------------------------Page 306-----------------------------------------------------
﻿
NAME

DOREC2

DOREC3

SETHDR

ADDFIL

ADDRESS

$D6B4

$D6B9

$D6C1

$D6C4 $D6C5

$D6CE $D6CF

$D6D0

$D6D3

$D6D5

$D6DA

$D6DF

$D6E3

$D6E4

$D6F0

$D6F4

DESCRIPTION OF WHAT ROM ROUTINE DOES

Restart the last job by moving the job code from LSTJOB,X ($025B,X) to the job queue at JOBS,X ($00,X).

Loop to wait until the value in the job queue at JOBS,X ($00,X) is less than 127

(indicates job has been completed).

Test to see if the error code returned

is $01 (successful). If everything was

OK, branch to DOREC3.

It didn't work. Decrement the error

counter in .Y and, if .Y has not counted down to $00 yet, branch to DOREC1 and keep trying.

Save the error code onto the stack. Load .A with the error LED mask from

ERLED ($026D), OR it with the disk controller port B, DSKCNT ($1C00) and store it back in DSKCNT ($1C00) to turn the drive light back ON.

Pull the error code back off the stack. Terminate routine with an RTS.

Set up the header for the active buffer: Uses values in TRACK, SECTOR, & DSKID. JSR to GETACT ($DF93) to get the number of the active buffer (returned in .A).

Multiply the number of the active buffer

(in .A) by 2 (ASL) and transfer the

result into .Y.

Move the track number from TRACK ($80) to HDRS,Y ($0006,Y).

Move the sector number from SECTOR ($81) to HDRS+1,Y ($0007,Y).

Load .A with the current drive number

from DRVNUM ($7F), multiply it by 2(ASL)

and transfer the result to .X.

NOTE: this last bunch of code really

does nothing. On the 4040 it is done in preparation for moving

the ID characters. However, this

is not done here on the 1541! Terminate routine with an RTS.

Add new filename to the directory: Save the followinq variables onto the stack: SA ($83), LINDX ($82), SECTOR

($81), and TRACK ($80).

Set the current secondary address, SA ($83) to $11 (#17), the internal read

channel.

JSR to CURBLK ($DE3B) to find a read channel and set. TRACK ($80) and SECTOR ($81) from the most recently read header

307

-----------------------------------------------------Page 307-----------------------------------------------------
﻿
NAME

AF08

AF10

AF15

ADDRESS

$D6F7

$D6FB

$D701

$D706

$D709

$D715

$D71A

$D71E

$D726

$D72E

$D730

DESCRIPTION OF WHAT ROM ROUTINE DOES

Save the file type, TYPE ($024A) of the

file to be added onto the stack.

Load .A with the drive number for the

new file, and it with $01, and store the result as the current drive, DRVNUM($7F)

Load .X with the last, job number from

JOBNUM ($F9).

EOR the drive number in .A with the

last job code from LSTJOB,X ($025B,X), divide the result by 2 (LSR), and check if the carry flag is clear. If it is,

the new file uses the same drive as the

last, job so there is no need to change

the drive and we can branch to AF08.

Store $01 in DELIND ($0292) to indicate that we are searching for a deleted entry and JSR to SRCHST ($C5AC). On return, if .A=0, all directory sectors

are full so branch to AF15 to start a

new sector. If .AO0, we have found a spot to put the new entry so branch to

AF20.

Since we have used this drive before, some of the directory information is in memory. Check if DELSEC ($0291) is $00. If it is, we didn't locate a deleted entry the last time we read in the directory so branch to AF10. Since DELSEC is not $00, it is the number of the sector containing the

first available directory entry. See if this sector is currently in memory by comparing this sector number with the one in SECTOR ($81). If they are equal, the sector is in memory so branch to

AF20.

Since the desired sector is not in

memory, set SECTOR ($81) to the desired sector number and JSR to DRTRD ($D460)

to read in the sector. Now branch to AF20.

Store $01 in DELIND ($0292) to indicate that we are looking for a deleted entry

and JSR to SEARCH ($C617) to find the first, deleted or empty directory entry. On return, if .A is not. equal to $00, a deleted or empty entry was found so

branch to AF20.

Nc> empty entries so we have to start a new sector so JSR to NXDRBK ($D4 8D) to find us the next available sector.

308

-----------------------------------------------------Page 308-----------------------------------------------------
﻿
NAME

AF20

AF25

AF50

ADDRESS

$D733

$D73D

$D743

$D747

$D74B

$D74D

$D750

$D757

$D75E

$D762

$D766

$D76D

$D776

$D77D $D77F

$D785

$D78B

$D790

$D793

$D797

DESCRIPTION OF WHAT ROM ROUTINE DOES

Move the new sector number from SECTOR

($81) to DELSEC ($0291) and set DELIND ($0292) to $02.

Load .A with the pointer that points to first character in the directory entry, DELIND($0292), and JSR to SETPNT($D4C8) to set. the pointers to this entry. Pull the file type off the stack and store it back in TYPE ($024A).

Compare the file type to $04 (REL type). If this is not a relative file, branch

to AF2 5.

Since it is a REL file, OR the file type

(in .A) with $80 to set bit 7.

JSR to PUTBYT ($CFF1) to store the file type (in .A) into the buffer.

Pull the file's track link off the

stack, store it in FILTRK ($0280), and JSR to PUTBYT ($CFF1) to store the

track link in the buffer.

Pull the file's sector link off the

stack, store it. in FILSEC ($0285) , and JSR to PUT3YT ($CFF1) to store the sector link in the buffer.

JSR to GETACT ($DF93) to get the active buffer number (in .A) and transfer the

value to .Y

Load .X with the file table pointer from FILTAB ($027A).

Load .A with $10 (#16) and JSR to TRNAME

($C66E) to transfer the file name to

the buffer.

Loop to fill directory entry with $00's from (DIRBUF),16 to (DIRBUF),27.

Check the value in TYPE ($024A) to see if this is a relative file. If not,

branch to AF50.

For REL files only: Load .Y with $10.

Move the side-sector track number from

TRKSS ($0259) to (DIRBUF),Y. Increment Y

Move the side-sector sector number from

SECSS ($025A) to (DIRBUF),Y. Increment Y

Move the record length from REC ($0258)

to (DIRBUF),Y.

JSR to DRTWRT ($D464) to write out the directory sector.

Pull the original value of LINDX off the stack, store it back in LINDX ($82), and

transfer the value into .X.

Pull the original value of SA off the stack, store it back in SA ($83).

309

-----------------------------------------------------Page 309-----------------------------------------------------
﻿
NAME

ADDRESS
 DESCRIPTION OF WHAT ROM ROUTINE DOES

$D79A

$D7A5

$D7AA

$D7AF

$D7B3

Load .A with sector contai

DELSEC ($0291

($D8) and in

Load .A with of the new en and store it Load .A with

entry from TY PATTYP ($E7).

Load .A with

from DRVNUM ( FILDRV ($E2).

Terminate rou

the number of the directory ning the new entry from

) and store it in ENTSEC DSEC,X ($0260,X).

the pointer to the start try from DELIND ($0292) in DIND,X ($0266,X).

the file type of the new PE ($024A) and store it in

the current drive number

$7F) and store it in

tine with an RTS.

OPEN

OP02

$D7B4

$D7B9

$D7BC

$D7C7

$D7CB

$D7CF

$D7D1

$D7D8

$D7DC

$D7E1

$D7E4

Open a channel from serial bus: The open, load, or save command is

parsed. A channel is allocated and the directory is searched for the filename specified in the command.

Move the current secondary address from SA ($83) to TEMPSA ($024C).

JSR to CMDSET ($C2B3) to set the command string pointers. On return, store the .X value in CMDNUM ($022A).

Load .X with the first character in the

command string CMDBUF ($0200). Load .A with the secondary address from TEMPSA ($024C). If the secondary address is not

$00, this is not. a load so branch to

OP021.

Compare the value in .X with $2A ("*")

to check if the command is "load the

last referenced program". If not $2A,

branch to OP021.

Appears to be "load last". Check by

loading .A with the last program's track

link from PRGTRK ($7E). If .A=0, there is no last program so branch to OP0415

to initialize drive 0.

Seems OK, let's load last program.

Store the program's track link (in .A)

into TRACK ($80).

Move the program's drive number from

PRGDRV ($026E) to DRVNUM ($7F).

Store $82 (program) as the file type in

PATTYP ($E7).

Move the program's sector link from PRGSEC ($026F) into SECTOR ($81) . JSR to SETLDS ($C100) to turn on the

drive active LED.

JSR to OPNRCH ($DC46) to open a read

channel.

310

-----------------------------------------------------Page 310-----------------------------------------------------
﻿
NAME

ENDRD

OP021

OP04

OP041

OP0415

OP042

ADDRESS

$D7E7

$D7EB

$D7ED

$D7F0

$D7F3

$D7F7

$D7FC

$D7FF

$D802

$D807 $D80B

$D80E

$D812

$D815

$D819

$D81C

$D821

$D828

$D82B

$D82E $D830

DESCRIPTION OF WHAT ROM ROUTINE DOES

Load .A with $04 (2 * program type), OR

it with the drive number in DRVNUM ($7F)

Load .X with the number of the active

buffer from LINDX ($82).

Store the value in .A as the file type in FILTYP,Y ($00EC,Y).

Terminate routine with a JMP to ENDCMD

($C194) .

Compare the byte in .X (the first in the command string) with $24 ("$") to check if we are to load the directory. If it is NOT "$", branch to OP041.

We want the directory. But, should we load it or just open it as a SEQ file? Check the secondary address in TEMPSA (024C). If it is not $00, branch to

OP04 to open it as a SEQ file. JMP to LOADIR ($DA55) to load the directory.

Open the directory as a SEQ file. JSR to SIMPRS ($C1D1) to parse the command string.

Move the directory's track link from DIRTRK ($FE85) into TRACK ($80) .

Zero the desired sector, SECTOR ($81) JSR to OPNRCH ($DC46) to open the read

channel.

Load .A with the current drive number

from DRVNUM ($7F) and OR it with $02

(2 * the SEQ file type).

Terminate routine with a JMP to ENDRD

($D7EB).

Compare the byte in .X (the first, in the command string) with $23 ("#") to check

if this is to be a direct access channel If it is NOT "#", branch to OP042. Continue routine with a JMP to OPNBLK

($CB84).

Set. the file type flag TYPFLG ($0296) to $02 (prcgram file).

Zero the current drive number DRVNUM

($7F) and the last job drive number

LSTDRV ($028E).

JSR to INITDR ($D042) to initialize

drive #0.

JSR to PRSCLN ($C1E5) to parse the command string to find the colon. If none found, branch to OP049

Zero .X and branch to OP20 (always).

311

-----------------------------------------------------Page 311-----------------------------------------------------
﻿
NAME

OP049

OP0 5

OP10

OP20

OP40

ADDRESS

$D834

$D837

$D83C

$D83F

$D840

$D843

$D848

$D84C

$D84F

$D852

$D857

$D861

$D866

$D869

$D86F

$D873

$D876

$D87B

$D87F

$D882

DESCRIPTION OF WHAT ROM ROUTINE DOES

Transfer the byte in .X to .A. If the byte is $00, branch to OP10.

Oops, trouble! Load .A with $30 to

indicate a BAD SYNTAX error and JMP to

CMDERR ($C1C8).

Decrement .Y so it points to the ":" If .Y=0, first character is a ":" so

branch to OP20.

Decrement .Y so it points to the byte just before the ":".

Store the pointer to the file name

(in .Y) into FILTBL ($027A).

Load .A with $8D (shifted return) and JSR to PARSE ($C268) to parse the rest of the command string.

Increment .X (file count) and store the result into F2CNT ($0278) .

JSR to ONEDRV ($C312) to set up one drive and the necessary pointers.

JSR to OPTSCH ($C3CA) to determine the optimal search pattern.

JSR to FFST ($C49D) to search the disk

directory for the file entry.

Zero the record length, REC ($0258) , MODE ($0297) (read mode), and the file type, TYPE ($024A) (deleted file).

Test the value of F1CNT ($0277). If it is $00, there are NO wild cards in the

filename so branch to OP40.

JSR to CKTM ($DA09) to set the file type and mode.

Test the value of F1CNT ($0277) . If it. is $01, there is only one wild card in

the filename so branch to OP40.

Compare .Y to $04. If .Y=$04, this is a

relative file so branch to OP60 to set the record size.

JSR to CKTM ($DA09) to set. the file type and mode.

Restore the original secondary address into SA ($83) using the value from TEMPSA ($024C).

Test the secondary address, if it. is greater or equal to $02, this is not a

load or save so branch to OP45.

This is a load or save. Set MODE ($0297) (0=read; l=write) using the secondary

address (0=load; l=save).

Set the write BAM flag, WBAM ($02F9) to $40 to flag that BAM is dirty.

312

-----------------------------------------------------Page 312-----------------------------------------------------
﻿
NAME

OP45

OP50

OP60

ADDRESS

$D887

$D88C

$D891

$D896

$D89D

$D8A2

$D8A7

$D8AE

$D8B1

$D8B4

$D8BA

$D8BF

DESCRIPTION OF WHAT ROM ROUTINE DOES

Load .A with the file type, TYPE ($024A) If it is not $00 (deleted file type),

branch to OP50. NOTE: load & save of files have TYPE set to $00 in $D857.

Set file type, TYPE ($024A) to $02

(program file type).

Load .A with the file type, TYPE ($024A) If it. is not. $00 (scratched file type),

branch to OP50.

Load the file type as given in the

directory from PATTYP ($E7), AND it with $07 (file type mask), and store the result, as the file type in TYPE ($024A)

Test the file's first track link in

FILTRK ($0280). If it is not $00, the

file exists so branch to OP50.

The file doesn't exist, set TYPE ($024A) to $01 (the default value; a SEQ file). Check MODE ($0297). If it is $01, it. is

write mode so branch to OP75 to write.

JMP to OP90 ($D940) to open to read or

load.

Handle relative file:

Load .Y with the pointer from FILTBL,X.

Load .A with the file's record size as

given in the directory from CMDBUF,Y and

store it in REC ($0258).

Test if the file's track link in FILTRK

($0280) is $00. If it. is NOT $00, the file is present, so branch to OP40 to

read it.

Set the MODE ($0297) to $01 (write mode) and branch to OP40 (always).

OF75

OP77

$D8C6

$D8CD

$D8D3

$D8D6

Load .A with the file's type the directory from PATTYP ($

with $80 to determine if it file, and transfer the resul it. is not a deleted file, br Open to write. Load .A with if any bits in .A and the fi PATTYP ($E7) match. If not,

OP80.

JSR to DELDIR ($C8B6) to del directory entry and write ou

revised sector.

JMP to OPWRIT ($D9E3) to ope

channel to write.

as given in

E7), AND it

is a deleted t to .X. If anch to OP81

$20 and test le type in

branch to

ete the t the

n the

OP80
 $D8D9
 Load .A with the entry's track link from FILTRK ($0280). If it is not $00, there is an existing file so branch to OP81.

313

-----------------------------------------------------Page 313-----------------------------------------------------
﻿
NAME

OP81

OP815

OP82

ADDRESS

$D8DE

$D8E1

$D8E8

$D8EB

$D8F0

$D8F5

$D8FE

$D902

$D905

$D90A

$D90E

$D911

$D917

$D91F

$D925

$D92A

$D92D

DESCRIPTION OF WHAT ROM ROUTINE DOES

File not found but. that's OK. JMP to

OPWRIT ($D9E3) to open a write channel.

Load .A with CMDBUF ($0200), the first byte of the command string. If it. equals $40 ("(§"), branch to OP82. NCTE: THIS IS

WHERE REPLACE FILE COMMAND IS DETECTED! Transfer .X value into .A. If it is not

$00, branch to OP815.

Load .A with $63 to indicate a FILE EXISTS ERROR and JMP to CMDERR ($C1C8). Load .A with $33 to indicate a bad filename and JMP to CMDERR ($C1C8).

REPLACE FILE ROUTINE * MAY HAVE BUG!

Load the file type of the directory entry from PATTYP ($E7), AND it with the file type mask $07, and compare the result with the command string file type in TYPE ($024A). If the file types do

not match, branch to OP115 to abort.

Compare the file type (in .A) with $04.

If it. is $04, this is a relative file

so branch to OP115 to abort.

JSR to OPNWCH ($DCDA) to open the write

channel.

Move the active buffer number from

LINDX ($82) to WLINDX ($0270).

Set the secondary address, SA ($83) to $11 (#17) the internal read channel. JSR to FNDRCH ($D0EB) to find an unused

read channel.

Load .A with the current value of the

pointer into the directory buffer, INDEX ($0294) and JSR to SETPNT ($D4C8) to set

the buffer pointers to point to the

INDEXth byte. NOTE: at this point INDEX points to the first byte in the entry, the file type.

Zero .Y. Then load .A with the file type from (DIRBUF),Y; ($94),Y, OR the file

type with $20 (set. the replace bit) , and store the result, back in (DIRBUF) ,Y. Load .Y with $1A (#26) and move the new track link from TRACK($80) to (DIRBUF),Y

Increment .Y and move the new sector

link from SECTOR ($81) to (DIRBUF),Y.

Load .X with the active buffer number from WLINDX ($0270).

Load .A with the sector of the directory entry ENTSEC ($D8) and copy it into DSEC,X ($0260,X).

314

-----------------------------------------------------Page 314-----------------------------------------------------
﻿
NAME

OP90

OP95

OP100

OP110

OP115

OP120

ADDRESS

$D932

$D937

$D93A

$D93D

$D940

$D945

$D94A

$D951

$D957

$D95C

$D965

$D96A

$D96F

$D976

$D97A

$D980

$D987

DESCRIPTION OF WHAT ROM ROUTINE DOES

Load .A with the pointer to the start of the directory entry ENTIND ($DD) and copy it into DIND,X ($0266,X).

JSR to CURBLK ($DE3B) to set TRACK ($80) and SECTOR ($81) from header of most.

recently read header.

JSR to DRTWRT ($D464) to do direct block

write of directory block to disk.

JMP to OPFIN ($D9EF) to finish opening

the file.

Test the directory entry's track link in FILTRK ($0280). If it is NOT $00,

the file exists so branch to OP100.

Load .A with $62 to indicate a FILE NOT FOUND error and JMP to CMDERR ($C1C8).

Compare the value in MODE ($0297) to $03 (open to modify). If MODE=$03 branch

to OP110.

Check bit 5 of the directory entry's file type. If this bit is set, it flags a file that is already opened (or not closed properly). If the bit is NOT SET, branch to OP110 and carry on.

Load .A with $60 to indicate a FILE OPEN error and JMP to CMDERR ($C1C8).

Load .A with the directory entry's file type from PATTYP ($E7), AND it with $07 to mask off higher order bits, and

compare it with the file type specified in the command string from TYPE ($024A). If the file types match, branch to OP120

Load .A with $64 to indicate a FILE TYPE MISMATCH error and JMP to CMDERR ($C1C8)

Load .Y with $00 and use it to zero F2PTR ($0279).

Load .X with the mode from MODE ($0297) If MODE is not $02 (open to append),

branch to OP125.

Compare the file type (in .A) with $04. If it is $04, this is a relative file

so branch to OP115.

This applies only to opening to append. Load .A with the file type from

(DIRBUF),Y ;($94),Y, AND it with $4F,

and store it back in (DIRBUF),Y.

Save the secondary address from SA ($83) onto the stack and set SA ($83) to $11

(#17, the internal read channel).

JSR to CURBLK ($DE3B) to set TRACK ($80) and SECTOR ($81) from header of most recently read header.

315

-----------------------------------------------------Page 315-----------------------------------------------------
﻿
NAME

OP125

OPREAD

OP130

ADDRESS

$D98A

$D98D

$D990

$D993

$D99A

$D99D

$D9A0

$D9AE

$D9B3 $D9B6

$D9B9

$D9BE

$D9C3 $D9C6

$D9CB

$D9D0

$D9D3

$D9D5 $D9D8

$D9DF

$D9E2

DESCRIPTION OF WHAT ROM ROUTINE DOES

JSR to DRTWRT ($D464) to do direct block write of directory block to disk.

Pull original secondary address off the

stack and restore it in SA ($83).

JSR to OPREAD ($D9A0) to open the file

for a read.

Check if MODE ($0297) is $02 (append). If it. isn't. $02, branch to OPFIN ($D9EF) JSR to APPEND ($DA2A) to read to the end

of the file.

JMP to ENDCMD ($C194) to terminate.

Open a file to read:

Copy the relative file values from the directory entry (DIRBUF),Y; ($94),Y into

their RAM variable locations:

Track for side sector to TRKSS ($0259) Sector for side sector to SECSS ($025A)

Load .A with the record size from the

directory entry. Load .X with the size from the command string, REC ($0258) . Store the value in .A into REC ($0258). Transfer the value from .X into .A. If

the command string size is $00, branch to OP130 (defaults to entry size) .

Compare the two record lengths. If they are equal, branch to OP130.

Record lengths do not match, load .A with $50 to indicate a READ PAST END OF FILE error and JSR to CMDERR ($C1C8).

Load .X with the pointer F2PTR ($0279). Copy the track link from FILTRK,X

($0280,X) to TRACK ($80).

Copy the sector link from FILSEC,X

($0285,X) to SECTOR ($81).

JSR to OPNRCH ($DC46) to open a read

channel.

Load .Y with the active buffer number from LINDX ($82) .

Load .X with the pointer F2PTR ($0279). Copy the directory sector containing the entry from ENTSEC,X ($D8,X) to DSEC,Y

($0260,Y).

Copy the pointer to the entry in the directory sector from ENTIND,X ($DD,X) to DIND,Y ($0266,Y).

Terminate the routine with an RTS.

316

-----------------------------------------------------Page 316-----------------------------------------------------
﻿
NAME

OPWRIT

OPFIN

OPF1

CKTM

CKM1

ADDRESS

$D9E3

$D9E9

$D9EC

$D9EF

$D9F5

$D9F8

$D9FC

$DA01

$DA06

$DA09

$DA11

DESCRIPTION OF WHAT ROM ROUTINE DOES

Open a file to write:

Load .A with the drive number for the

file from FILDRV ($E2), AND it with $01 to mask off non-drive bits, and store

the result as the current drive in

DRVNUM ($7F).

JSR to OPNWCH ($DCDA) to open a write

channel.

JSR to ADDFIL ($D6E4) to add the entry to the directory.

If the secondary address is greater than $01, it is a not. a program file so

branch to OPF1.

JSR to GETHDR ($DE3E) to set up TRACK

and SECTOR values from the last header read.

Copy the track link from TRACK ($80) to

PRGTRK ($7E).

Copy the file drive from DRVNUM ($7F) to

PRGDRV ($026E).

Copy the sector link from SECTOR ($81)

to PRGSEC ($026F).

Terminate routine with a JMP to ENDSAV

($C199).

Check mode or file type:

Load .Y with the pointer from FILTBL,X. Load .A with the mode or file type from the command string, CMDBUF,Y.

Load .Y with $04, the number of modes. Loop to compare mode requested with the table of modes, MODLST,Y ($FEB2,Y). If no match is found, branch to CKM2. If a match is found, fall through. VALID MODES: 0 = R (READ)

1 = W (WRITE)

A (APPEND)

a =

M (MODIFY)

3 =

$DA19

Store .Y counter

(0-3) in MODE ($0297)

CKM2

$DA1C

Loop to compare type requested with the table of types, TPLST,Y ($FEB6,Y). If no match is found, branch to CKT2. If a match is found, fall through.

VALID TYPES:

0 =

= D

(DELETED)

1 ■■ = S

(SEQUENTIAL)

2 --

= P

(PROGRAM)

3 =

= U

(USER)

4 =

= R

(RELATIVE)

CKT2

$DA26 $DA29

Store .Y counter (0-3) in TYPE ($024A) Terminate the routine with an RTS.

317

-----------------------------------------------------Page 317-----------------------------------------------------
﻿
NAME

ADDRESS
 DESCRIPTION OF WHAT ROM ROUTINE DOES

Append information to the end of a f
 ile

Reads through old file to end.

APPEND

AP3 0

$DA2A

$DA2D

$DA34

$DA37

$DA3D

$DA42

$DA45

$DA4B

$DA54

JSR to GCBYTE ($CA3 9) tc get a byte

the data channel.

Test if we are at the end of file. I

not, loop back to APPEND.

JSR to RDLNK ($DE9 5) to set TRACK ($ and SECTOR ($81) from the track and sector links in the last block. NOTE TRACK will be $00 and SECTOR will be

pointer to the end of the file.

Load .X with the end of file pointer from SECTOR ($81) , increment it by 1

and transfer the result to .A. If th

new value of the pointer is not $00, there is space left at the end of th

sector so branch to AP30.

No space left in this sector so JSR WRTO ($D1A3) to get the next sector. Load .A with $02 so it points to the

start of the data area for this new

sector.

JSR to SETPNT ($D4C8) to set the act buffer pointers.

Load .X with the active buffer numbe

from LINDX ($82) and store $01 (chan ready at the end of file) in the cha status flag CHNRDY,X ($F2,X).

Load .X with the sec. address SA ($8 Load .A with $60, OR it with the act buffer number in LINDX ($82), and st the result in LINTAB,X ($022B,X) to

indicate that this is now a write fi Terminate the routine with an RTS.

Load the directory ($):

from

f

80)

e

is

to

lve

nel

nnel

3) .

ive

ore

le.

LOAD IR

LD01

LD02

$DA5 5

$DA5A $DA5C

$DA62

$DA65

$DA6D

Store $0C (load) as the command code in CMDNUM ($022A).

Load .A with $00 (load only drive #0) Load .X with the command length from

CMDSIZ ($0274) and decrement'the length

in .X by 1. If the result, is $00, branch to LD02 to load complete directory for

drive 0.

Decrement the length in .X by 1. If the result, is still not $00, this must be a selective load by name so branch to LD03

Load .A with the second character in the

command string from CMDBUF+1 ($0201) and JSR to TST0V1 ($C3BD) to test if the character is an ASCII "0" or "1". If

not, branch to LD03 to load by name. Store the drive number desired (in .A) into FILDRV ($E2).

318

-----------------------------------------------------Page 318-----------------------------------------------------
﻿
NAME

LD03

LD0 5

LD10

LD20

CLOSE

ADDRESS

$DA6F

$DA78

$DA7C

$DA84

$DA86

$DA8B

SDA8E

$DA90

$DA95

$DA98

$DA9B

$DA9E

$DAA1

$DAA4

$DAA7

$DAAA

$DAAD

$DAAF

$DAB2

$DAB7

$DABB

$DABF

$DAC0 $DAC5

DESCRIPTION OF WHAT ROM ROUTINE DOES

Increment F1CNT ($0277) , F2CNT ($0278) , and FILTBL ($027A).

Store $80 in PATTYP ($E7) to represent the file type.

Store $2A ("*") as the first two b>tes in the command string CMDBUF ($0200) and CMDBUF+1 ($0201)

Branch always to LD10.

JSR to PRSCLN ($C2DC) to find the colon in the command string. If no colon is found, branch to LD05.

Colon found so JSR to CMDRST ($C2DC) to

zero all command string variables. Lead .Y with $03.

Decrement .Y twice and store the result

in FILTBL ($027A).

JSR to TC35 ($C200) to parse and set up the tables.

JSF to FS1SET ($C398) to set pointers to file name and check type.

JSR to ALLDRS ($C3 20) to set up all drives required.

JSR to OPTSCH ($C3CA) to determine the best drive search pattern.

JSR to NEWDIR ($C7B7) to read in BAM and set up disk name, ID, etc as first line in directory.

JSR to FFST ($C49D) to find file start- entry.

JSR to STDIR ($EC9E) to start the

directory loading function.

JSR to GETBYT ($D137) to read first byte

from the buffer.

Load .X with the active buffer number

from LINDX ($82).

Store the first byte (in .A) into CHNDAT,X ($023E,X).

Load .A with the current drive number from DRVNUM ($7F) and use this value to set the last job drive LSTDRV ($028E).

OR the drive number in .A with $04 and

store the result as the file type in FILTYP,X ($EC,X).

Zero BUFTAB+CBPTR ($A3). Note: CBPTR is the command buffer pointer ($0A).

Terminate the routine with an RTS.

Close the file related to the specified secondary address:

Zero the write BAM flag, WBAM ($02F9). If secondary address, SA ($83) is not zero (directory load), branch to CLS10

319

-----------------------------------------------------Page 319-----------------------------------------------------
﻿
NAME

ADDRESS
 DESCRIPTION OF WHAT ROM ROUTINE DOES

CLS05

CLS10

$DAC9

$DAD1

$DAD4

$DAD8 $DADB

$DAE1

$DAE6

Close directory: Zero t listing flag DIRLST ($0

FRECHN ($D227) to free JMP to FREICH ($D4DA) t

internal channel and te

If secondary address (i

branch to CLSALL to clo

JSR to CLSCHN ($DB02) t If secondary address in (save), branch to CLS05

internal channel and ex Check the error status

If status is not $00, t produced an error so br JMP to ENDCMD ($C194) t

he directory

254) and JSR to

the channel. o free the

rminate routine.

n .A) is $0F(#15)

se all files.

o close channel.

SA ($83) is $01

to close the

it.

in ERWORD ($026C)

he last command anch to CLS15. o end command.

CLS15

CLSALL CLS20

CLS25

CLSCHN

CLSC28

$DAE9

$DAEC $DAF0 $DAF3

$DAF7

$DAFC

$DAFF

$DB02

$DB04

$DB09

$DB0C

$DB10

$DB13

$DB17

$DB1B

$DB20

$DB23

Error so JMP to SCREN1 ($C1AD)

Close all files: (when CMD closed) Set secondary address, SA ($83) to $0E. JSR to CLSCHN ($DB02) to close channel.

Decrement. SA ($83). If more secondary addresses to do (SA>=0) loop to CLS20. Check the error status in ERWORD ($026C) If status is net $00, the last, command produced an error so branch to CLS25. JMP to ENDCMD ($C194) to end command.

Error so JMP to SCRENl ($C1AD)

Close file with specified sec. address Load .X with the secondary address from SA ($83).

Load .A with the channel status from

LINTAB,X ($022B,X). If the status is not $FF (closed), branch to CLSC28. Channel already closed so terminate

routine with an RTS.

AND the channel status (in .A) with $0F to leave only the buffer number and store the result in LINDX ($82).

JSR to TYPFIL ($D125) to determine the

file type (returned in .A).

If file type is $07 (direct channel)

branch to CLSC3 0.

If file type is $04 (relative file)

branch to CLSREL.

JSR to FNDWCH ($D107) to find an unused write channel. If none found, branch to

CLSC31

JSR to CLSWRT ($DB62) to close off sequential write.

JSR to CLSDIR ($DBA5) to close directory

320

-----------------------------------------------------Page 320-----------------------------------------------------
﻿
NAME
 ADDRESS
 DESCRIPTION OF WHAT ROM ROUTINE DOES

CLSC30 CLSC31

$DB26 $DB29

JSR to MAPOUT ($EEF4) JMP to FRECHN ($D227)

to write out BAM. to free channel

and terminate the command.

CLSREL

$DB2C

Sub to close relative

JSR to SCRUB ($DDF1)

file:

to write out BAM

if it. is dirty (RAM version modified) .

$DB2F

JSR to DBLBUF ($CF1E)
 to set up double

buffering and read ahead.

$DB32

$DB35

$DB3B

JSR to SSEND ($E1CB)

sector & buffer table of the last record.

Load .X with the side

SSNUM ($D5), store th and increment- T4 by 1 Zero Tl ($70) and T2

to position side

pointer to the end

sector number from

is byte in T4 ($73) ,

.

($71) .

$DB41

Load .A with the pointer to the side

sector value in the d

from SSIND ($D6), set

irectory buffer the carry flag,

subtract $0E (the side sector offset-2),

$DB48

and store the result

JSR to SSCALC ($DF51)

number of side sector

in T3 ($72).

to calculate the blocks needed.

$DB4B

$DB4D

Load .X with the active buffer number from LINDX ($82) .

Move the lo byte of the number of side

$DB55

sector blocks from Tl

($B5,X) and the hi by

NBKH,X ($BB,X).

Load .A with $40 (the

relative record flag) ($DDA6) to test if re

($70) to NBKL,X

te from T2 ($71) to

dirty flag for a

and JSR to TSTFLG lative record must

be written out. If not, branch to CLSR1.

CLSR1

$DB5C

$DB5F

JSR to CLSDIR ($DBA5) directory file.

JMP to FRECHN ($D2 27)

channel and terminate

Close a sequential fi

to close the

to clear the routine.

le write channel:

CLSWRT

$DB62

$DB64

$DB6A

Lead .X with the active buffer number from LINDX ($82) .

Load .A with the number of bytes written in this sector from NBKL,X ($B5,X) and

OR .A with the number

of data blocks

written from NBKL,X ($B5,X).

If the result is not.
 $00, at least, one

block of the file has

been written so

branch to CLSW10.

No blocks have been written so JSP to

GETPNT ($D4E8) to get

the pointer into

the data buffer (returned in .A). If

this value is greater

than two, at least

one byte has been wri

tten so branch to

CLSW10.

321

-----------------------------------------------------Page 321-----------------------------------------------------
﻿
NAME

CLSW10

CLSW15

CLSW2 0

CLSDIR

ADDRESS

$DB71

$DB76

$DB7D

$DB80

$DB82

$DB86

$DB88

$DB8A $DB8C

$DB90

$DB95

$DB98 $DB99

$DB9C

$DB9F

$DBA2

$DBA5

$DBAA

$DBAD

$DBB2

DESCRIPTION OF WHAT ROM ROUTINE DOES

No bytes have been written so load .A with $0D (carriage return) and JSR to PUTBYT ($CFF1) to write it out to the

data buffer.

JSR to GETPNT ($D4E8) to get the pointer into the data buffer (returned in .A). If the pointer value is not $02, the

buffer is not empty so branch to CLSW20. Since we have an empty buffer, JSR to DBLBUF ($CF1E) to switch buffers.

Load .X with the active buffer number

from LINDX ($82) .

Load .A with the number of bytes written in this sector from NEKL,X ($B5,X). If this value is not equal to $00, branch

to CLSW15.

Decrement the number of data blocks

written in NBKH,X ($BB,X) by 1.

Decrement, the number of bytes written in this sector, NBKL,X ($B5,X) by 1. Load .A with $00.

Set. the carry flag, subtract $01 from the number of bytes written in this

sector (.A), and save the result, on the

stack.

Load .A with $00 and JSR to SETPNT

($D4C8) to set the buffer pointers to the first byte in the data buffer (the

track link).

JSR to PUTBYT ($CFF1) to write $00 out

as the track link.

Pull the bytes written from the stack. JSR to PUTBYT ($CFF1) to write out the bytes in this sector as the sector link. JSR to WRTBUF ($D0C7) to write the data buffer out. to disk.

JSR to WATJOB ($D599) to wait for the

write job to be completed.

JMP to DBLBUF ($CF1E) to make sure that.

both buffers are OK.

Close directory after writing file:

Load .X with the active buffer number from LINDX ($82). Save this value into WLINDX ($0270) .

Save the current secondary address from SA ($83) onto the stack.

Copy the sector of the directory entry for the file from DSEC,X ($0260,X) into SECTOR ($81).

Copy the pointer to the directory entry for the file from DIND,X ($0266,X) into INDEX ($0294) .

322

-----------------------------------------------------Page 322-----------------------------------------------------
﻿
NAME

ADDRESS

$DBB8

$DBBE

$DBC3

$DBC6

$DBC9

$DBCC $DBCE

$DBD3

$DBD8

$DBDE

$DBE1

$DBE5

$DBEB

$DBEC

$DBF0 $DBF2

$DBF4

$DBF7

$DBF8

$DBFC

DESCRIPTION OF WHAT ROM ROUTINE DOES

Load .A with the file type from FILTYP,X ($EC,X) , AND it. with $01 to mask off the non-drive bits, and store the result as the current drive number in DRVNUM ($7F) Ccpy the directory track number (#18) from DIRTRK ($FE85) into TRACK ($80). JSR to GETACT ($DF93) to get the active buffer number (returned in .A).

Save the active buffer number onto the

stack and into JOBNUM ($F9).

JSR to DIRTRD ($D460) to read in the directory sector containing the entry. Load .Y with $00.

Load .A with the hi byte of the pointer to the active buffer from BUFIND,X ($FEF0,X) and store it in R0+1 ($87). Complete the pointer into the directory buffer by copying the lo byte of the pointer from INDEX ($0294) to R0 ($86) . Load .A with the file type from the

directory entry (R0),Y, AND it with $20, and checking if the result is $00. If it is $00, this is NOT a replace so

branch to CLSD5.

NOTE: Here is where we do the directory

entry when a file is replaced.

Possible bugs! - * - * -

_ * _

JSR to TYPFIL ($D125) to determine the file type (returned in .A).

If file type is $04 (a relative file)

branch to CLSD6.

Load .A with the file type from R0,Y, AND it. with $8F to mask off the replace bit, and store the result back in R0,Y. Increment .Y. The pointer at (R0),Y now points to the old track link.

Copy the old track link from (R0),Y to

into TRACK ($80) .

Store the .Y value into TEMP+2 ($71). Load .Y with $1B (#27). The pointer at (R0),Y now points to the replacement.

sector link.

Load .A with the replacement sector link from (R0),Y and save it on the stack. Decrement .Y. The pointer at (R0),Y now points to the replacement track link. Load .A with the replacement track link. If this link is NOT $00, branch to CLSD4

Trouble! Replacement track link should never be $00. So put replacement track link in TRACK ($80) .

323

-----------------------------------------------------Page 323-----------------------------------------------------
﻿
NAME

CLSD4

CLSD5

CLSD6

ADDRESS

$DBFE

$DC01

$DC06

$DC07

$DC0B $DC0C $DC0E

$DC0F

$DC11

$DC13

$DC14

$DC18

$DC1B

$DC1E $DC21

$DC29

$DC2C

$DC2E

$DC32 $DC33

$DC37

$DC39

$DC3D

DESCRIPTION OF WHAT ROM ROUTINE DOES

Pull replacement, sector link off the stack and put it in SECTOR ($81) .

Load .A with $6 7 to indicate a SYSTEM

TRACK OR SECTOR error and JMP to CMDER2

($E645) .

Push the replacement track link onto

the stack.

Load .A with $00. Zero the replacement. track link in the entry (R0),Y.

Increment .Y.

Zero replacement, sector link in (R0),Y. Pull the replacement track link off

the stack.

Load .Y with the original pointer value from TEMP+2 ($71). Note: pointer at (R0),Y now points to the second byte of

the entry, the track link.

Store the replacement, track link as the final track link in (R0),Y.

Increment .Y. Note: the pointer at (R0),Y now points to the third byte of

the entry, the sector link.

Move the old sector link from (R0),Y to SECTOR ($81).

Pull the replacement, sector link off the

stack and store it. as the final sector

link in (R0),Y.

JSR to CEIFIL ($C87D) to delete the old file from the BAM by following the track

and sector links.

JSR to CLSD6 ($DC29) to finish closing. Load .A with the file type from (R0),Y, AND it. with $0F to mask off any high

order bits, OR it with $80 to set the closed bit, and store the result back in (R0),Y.

Load .X with the active buffer number

that was saved into WLINDX ($0270). Load .Y with $1B (#27). The pointer at (R0),Y now points to the low byte of the

number of blocks in the file.

Copy the lo byte of the number of blocks from NBKL,X ($B5,X) to (R0),Y.

Increment .Y.

Copy the hi byte of the number of blocks from NBKH,X ($BB,X) to (R0),Y.

Pull the original buffer number off the

stack and transfer it. into .X.

Load .A with $90 (write job code) and OR it with the drive number in DRVNUM($7F). JSR to DOIT ($D590) to write out the revised directory sector.

324

-----------------------------------------------------Page 324-----------------------------------------------------
﻿
NAME

OPNRCH

OR10

OR20

ADDRESS

$DC40

$DC43

$DC46

$DC4B $DC4E

$DC52

$DC57

$DC5A

$DC5C

$DC60

$DC65

$DC6A

$DC74

$DC79

$DC7E

$DC81

$DC83

$DC85

DESCRIPTION OF WHAT ROM ROUTINE DOES

Pull the original secondary address off

the stack and transfer it into SA ($83). JMP to FNDWCH ($D107) to exit.

Open read channel with two buffers: Sets secondary address in LINTAB and initializes all pointers, including the

ones for a relative file.

Load .A with $01 and JSR to GETRCH

($D1E2) to set. up one read channel

JSF to INITP ($DCB6) to clear pointers. Load .A with the file type and save this

value on the stack.

Multiply the file type in .A by 2 (ASL),

OR it. with the current drive in DRVNUM

($7F) and store it in FILTYP,X to set.

the file type.

JSR to STRRD ($D09B) to read the first

one or two blocks in the file.

Load .X with the active buffer number

from LINDX ($82) .

Load .A with the current track number

from TRACK ($80). If the track number is not $00 (not the last block in the file), branch to CR10.

Load .A with the current sector number

from SECTOR ($81). Since TRACK=$00, this is the pointer to the last character in the file. Store this value in LSTCHR,X

($0244,X).

Pull the original file type off the stack. If this is not a relative file,

branch to OR30.

Load .Y with the secondary address from SA ($83). Load the channel type from LINTAB,Y ($022B,Y), OR it. with $40 to mark it as a READ/WRITE file, and store the channel type back in LINTAB,Y. Copy the record size from REC ($0258) into RS,X ($C7,X).

JSR to GETBUF ($D28E) to set. up a buffer

for the side sectors. If a buffer is

available, branch to OR20.

Since no buffer is available for the side sectors, abort with a JMP to GBERR

($D20F) .

Load .X with the active buffer number

(side sector buffer) from LINDX ($82).

Store the side sector buffer number in SS,X ($CD,X).

Copy the side sector track link from TRKSS ($0259) into TRACK ($80).

325

-----------------------------------------------------Page 325-----------------------------------------------------
﻿
NAME

OROW

OR 3 0

INITP

ADDRESS

$DC8A

$DC8F

$DC92

$DC95

$DC98

$DC9A

$DCA0

$DCA3

$DCA6

$DCA9 $DCAC

$DCAE

$DCB1

$DCB5

$DCB6

$DCB8

$DCBC

$DCC1

$DCC7

$DCC9

$DCCE

$DCD4

$DCD9

DESCRIPTION OF WHAT ROM ROUTINE DOES

Copy the side sector sector link from SECSS ($025A) into SECTOR ($81) .

JSR to SETH ($D6D3) to set up the side sector header image.

JSR to RDSS ($DE73) to read in the side

sector block.

JSR to WATJOB ($D599) to wait for the job to be completed.

Load .X with the active buffer number

(side sector buffer) from LINDX ($82). Set the next record pointer in the side sector buffer NR,X ($C1,X) to $02. Load .A with $00 and JSR to SETPNT

($D4C8) to set the buffer pointers to

the start of the side sector buffer.

JSR to RD4C ($E153) to set up the first

record.

JMP to GETHDR ($DE3E) to restore the

track and sector pointers and exit.

JSR to RDBYT ($D15 6) to read a byte.

Load .X with the active buffer number

(side sector buffer) from LINDX ($82) .

Store the data byte (in .A) into CHNDAT,X ($023E,X).

Store $88 (ready to talk) as the channel status in CHNRDY,X ($F2,X).

Terminate routine with an RTS.

Initialize variables for open channel:

Load .X with the active buffer number from LINDX ($82) .

Load buffer number from BUF0,X ($A7,X), multiply it by two (ASL), and transfer

the result into .Y.

Store $02 into the buffer pointer

BUFTAB,Y ($0099,Y) so it points to the first data byte in the buffer.

Load .A with the alternative-buffer

number from BUF1,X ($AE,X), OR it. with $80 to set the buffer-inactive bit, and store the result back in BUF1,X.

Multiply the buffer number (in .A) by two (ASL) and transfer the result to .Y. Store $02 into the buffer pointer

BUFTAB,Y ($0099,Y) so it. points to the first data byte in the buffer.

Zero the lo and hi bytes of the number of blocks written, NBKL,X ($B5,X) and NBKH,X ($BB,X).

Zero the last data byte LSTCHR,X

($0244),X.

Terminate routine with an RTS.

326

-----------------------------------------------------Page 326-----------------------------------------------------
﻿
NAME

OPNWCH

OW10

OW20

ADDRESS

$DCDA

$DCDD

$DCE2

$DCE5 $DCE8

$DCEA

$DCEE

$DCF3

$DCF8

$DCFC

$DCFD

$DCFF

$DD09

$DD0E

$DD13

$DD16

$DD18

$DD1A

$DD1D

$DD20

$DD25

$DD2A

DESCRIPTION OF WHAT ROM ROUTINE DOES

Open write channel with two buffers: JSR to INTTS ($F1A9) to get the first

track and sector.

Load .A with $01 and JSR to GETWCH

($D1DF) to get. one buffer for writing. JSR to SETHDR ($D6D0) to set. up header image.

JSR to INITP ($DCB6) to set up pointers.

Load .X with the active buffer number from LINDX ($82) .

Load .A with the file type from TYPE ($024A) and save it onto the stack.

Multiply the file type in .A by two (ASL), OR it with the drive number from DRVNUM ($7F), and store the result as

the file type in FILTYP,X ($EC,X). Pull the original file type off the

stack and if this is a relative file

(type = $04), branch to OW10.

Since this is not a relative file, set channel status, CHNRDY,X ($F2,X) to $01

(active listener).

Terminate routine with an RTS.

Load .Y with the secondary address from SA ($83) .

Load .A with the buffer type from

LINTAB,Y ($022B,Y), AND it with $3F to mask off higher order bits, OR it with $40 to flag this as a READ/WRITE file, and store the result, back in LINTAB,Y. Copy record size from REC ($0258) into RS,X ($C7,X).

JSR to GETBUF ($D28E) to get a new buffer for storing the side sectors.

If a buffer is available, branch to OW20

No buffer available so abort with a JMP to GBERR ($D20F).

Load .X with the active buffer number from LINDX ($82) .

Store the new side sector buffer number

into SS,X ($CD,X).

JSR to CLRBUF ($DEC1) to clear the

side sector buffer.

JSR to NXTTS ($F11E) to find the next.

available track and sector.

Copy the new track link from TRACK ($80)

to TRKSS ($0259) .

Copy the new sector link from SECTOR

($81) to SECSS ($025A).

Load .X with the active buffer number

from LINDX ($82) .

327

-----------------------------------------------------Page 327-----------------------------------------------------
﻿
NAME

ADDRESS

$DD2C

$DD2E $DD31

$DD36

$DD3B

$DD40

$DD45

$DD4B

$DD50

$DD55

$DD5A

$DD5D

$DD62

$DD67

$DD6A

$DD6D

$DD72

$DD74

$DD7B

$DD7E

$DD81

DESCRIPTION OF WHAT ROM ROUTINE DOES

Load .A with the side sector buffer

number from SS,X ($CD,X).

JSR to SETH ($D6D3) to set up the header Load .A with $00 and JSR to SETSSP ($DEE9) to set the buffer pointers using the current. SS pointer (in .A)

Load .A with $00 and JSR to PUTSS

($DD8D) to set a null side sector link. Load .A with $11 (the side sector offset. plus 1) and JSR to PUTSS ($DD8D) to set

the last, character.

Load .A with $00 and JSR to PUTSS

($DD8D) to set. this side sector number. Load .A with the record size from REC

($0258) and JSR to PUTSS ($DD8D) to set

the record size.

Load .A with the file track link from

TRACK ($80) and JSR to PUTSS ($DD8D) to

set the track link.

Load .A with the file sector link from

SECTOR ($81) and JSR to PUTSS ($DD8D) to

set. the sector link.

Load .A with the side sector offset.

($10) and JSR to PUTSS ($DD8D) to set

the side sector offset.

JSR to GETHDR ($DE3E) to get. the track

and sector of the first, side sector. Load .A with the SS track link from

TRACK ($80) and JSR to PUTSS ($DD8D) to

set the SS track link.

Load .A with the SS sector link from

SECTOR ($81) and JSR to PUTSS ($DD8D) to

set. the SS sector link.

JSF to WRTSS ($DE6C) to write out the side sector block.

JSR to WATJOB ($D599) to wait for the write job to be completed.

Load .A with $02 and JSR to SETPNT ($D4C8) to set the pointer into the

data buffer to the start of the data. Load .X with the active buffer number from LINDX ($82) .

Set. the carry flag, load .A with $00,

subtract the record size from RS,X ($C7,X), and store the result in NR,X ($C1,X) to set NR for a null buffer. JSR to NULBUF ($E2E2) to set null records in the active buffer.

JSR to NULLNK ($DE19) to set track link to $00 and sector link to last non-zero

character.

JSR to WRTOUT ($DE5E) to write out the

null record block.

328

-----------------------------------------------------Page 328-----------------------------------------------------
﻿
NAME

PUTSS

SCFLG

SETFLG

CLRFLG

CLRF10

TSTFLG

TSTWRT

ADDRESS

$DD84

$DD87

$DD8A

$DD8D $DD8E

$DD90

$DD92

$DD95

$DD97

$DD99

$DD9B

$DD9D

$DD9F

$DDA1

$DDA3

$DDA5

$DDA6

$DDA8

$DDAA

$DDAB

$DDAE $DDAF

DESCRIPTION OF WHAT ROM ROUTINE DOES

JSR to WATJOB ($D599) to wait for the

write job to be completed.

JSR to MAPOUT ($EEF4) to write out. the

BAM.

JMP to OROW ($DC98) finish opening the

channel.

Put byte into the side sector: Push byte in .A cnto the stack.

Load .X with the active buffer number from LINDX ($82).

Load .A with the side sector buffer

number from SS,X ($CD,X). JMP to PUTB1 ($CFFD).

Set/Clear flag:

If carry flag clear, branch to CLRFLG

Set. flag:

Load .X with the active buffer number

from LINDX ($82).

OR the byte in .A with the file type in FILTYP,X ($EC,X).

If result is not $00, branch to CLRF10.

Clear flag:

Load .X with the active buffer number

from LINDX ($82) .

EOR the byte in .A with $FF to flip all

the bits.

AND the byte in .A with the file type in FILTYP,X ($EC,X).

Store the result in .A, as the new file type in FILTYP,X ($EC,X).

Terminate routine with an RTS.

Test flag:

Load .X with the active buffer number from LINDX ($82) .

AND the byte in .A with the file type in FILTYP,X ($EC,X).

Terminate routine with an RTS.

Test if this is a write job:

JSR to GETACT ($DF93) to get the active buffer number (returned in .A).

Transfer the buffer number to .X.

Load .A with the last job code from

LSTJOB,X ($025B), AND the job code with $F0 to mask off the drive bits, and compare the result with $90 (write job code). This sets the Z flag if this is a write job.

-----------------------------------------------------Page 329-----------------------------------------------------
﻿
NAME

TSTCHN TSTC20

TSTC30

TSTRTS

TSTC40

SCRUB

ADDRESS

$DDB6

$DDB7 $DDB9 $DDBB

$DDC2

$DDC9

$DDCA $DDCC

$DDCF

$DDD6

$DDD9

$DDE1

$DDE8

$DDEF

$DDF0

$DDF1

DESCRIPTION OF WHAT ROM ROUTINE DOES

Terminate routine with an RTS.

Test for active files in LINDX tables:

C=0 if file active X=ENTFND; Y=LINDX C=l if file inactive X=18

Load .X with $00 (secondary address)

Save .X value into TEMP+2 ($71).

Load .A with the buffer number for this

secondary address from LINTAB,X (022B,X) If the buffer number is NOT $FF, branch to TSTC40 for further testing.

Restore .X value from TEMP+2 ($71) and increment, it by 1. If the resulting .X value is less than $10 (the maximum sec. address - 2), loop back to TSTC20.

Terminate routine with an RTS.

Save .X value into TEMP+2 ($71).

AND the buffer number in .A with $3F to mask off the higher order bits and

transfer the result into .Y.

Load .A with the file type for this

secondary address from FILTYP,Y ($EC,Y), AND it with $01 to mask off the

non-drive bits, and store the result in TEMP+1 ($70) .

Load .X with the index entry found from ENTFND ($0253).

Load .A with the drive number for this

secondary address from FILDRV,X ($E2,X), AND it with $01 to mask off the

non-drive bits, and compare the result with the drive number in TEMP+1 ($70). If the drives do not match, branch to

TSTC30.

Drive numbers match, now check if the directory entries match by comparing the entry sector in DSEC,Y($026C,Y) with the one in ENTSEC,X ($D8,X). If they do

not match, branch to TSTC30.

Drive numbers are match, now check if the directory entries match by comparing the entry index in DIND,Y ($0266,Y) with the one in ENTIND,X ($DD,X). If they do

not match, branch to TSTC30.

Clear the carry flag to indicate that all tests passed and active file found.

Terminate routine with an RTS.

Write out buffer if dirty:

NOTE: a buffer is dirty if the copy in

RAM has been modified so it does

not match the copy on disk.

JSR to GAFLGS ($DF9E) to get active

buffer number and set in LBUSED.

330

-----------------------------------------------------Page 330-----------------------------------------------------
﻿
NAME

SCR1

SETLNK

GETLNK

NULLNK

SETOO

ADDRESS

$DDF4

$DDF6

$DDF9

$DDFC

$DDFD

$DE02

$DE05

$DE09

$DE0C

$DE0F

$DE14

$DE18

$DE19

$DE1C

$DE21

$DE23

$DE2A

$DE2B

$DE2E

$DE30

$DE34

$DE38

DESCRIPTION OF WHAT ROM ROUTINE DOES

If V flag not set, buffer is not. dirty

so branch to SCR1.

JSR to WRTOUT ($DE5E) to write out the

buffer to disk.

JSR to WATJOB ($D599) to wait for the

job to be completed.

Terminate routine with an RTS.

Put. TRACK and SECTOR into header:

JSR to SETOO ($DE2B) to set up pointer

to header.

Move desired track from TRACK ($80) to

(DIRBUF),Y; ($94),Y. Increment .Y

Move desired sector from SECTOR ($81) to

(DIRBUF),Y; ($94),Y.

Terminate routine with a JMP to SDIRTY

($E105) to flag the buffer as dirty.

Set TRACK & SECTOR from link in buffer:

JSR to SETOO ($DE2B) to set up pointer

to header.

Move track link from (DIRBUF) ,Y; ($94) ,Y to TRACK ($80) . Increment .Y.

Move sector link from (DIRBUF),Y

($94) ,Y to SECTOR ($80) .

Terminate routine with an RTS.

Set. track link to $00 and sector link to

the last non-zero character in buffer.

JSR to SETOO ($DE2B) to set. up pointer

to header.

Store $00 as track link in (DIRBUF),Y

($94),Y. Increment .Y.

Load .X with the active buffer number

from LINDX ($82) .

Load .A with the pointer into the data buffer from NR,X ($C1,X), decrement it. by 1, and store the result, as the sector

link in (DIRBUF),Y; ($94),Y. Terminate routine with an RTS.

Set. up pointer to active buffer:

JSR to GETACT ($DF93) to get the active

buffer number (returned in .A).

Multiply the buffer number (in .A) by

two (ASL) and transfer the result, to .X. Move the hi byte of the buffer pointer from BUFTAB+1,X ($9A,X) to DIRBUF+1($95) Store $00 as the lo byte of the buffer pointer in DIRBUF ($94) .

Zero .Y and exit routine with an RTS.

331

-----------------------------------------------------Page 331-----------------------------------------------------
﻿
NAME

ADDRESS
 DESCRIPTION OF WHAT ROM ROUTINE DOES

Set. TRACK & SECTOR from

header:

CURBLK

$DE3B

JSR to FNDRCH ($D0EB) to

find an unused

read channel.

GETHDR

$DE3E

$DE41 $DE43

$DE45

$DE4A

$DE4F

JSR to GETACT ($DF9 3) to buffer number (returned

Store the buffer number

Multiply the buffer numb

two (ASL) and transfer t

Move the track number fr

table, HDRS,X ($0006,Y)

Move the sector number f

table, HDRS+1,X($0007,Y)

Terminate routine with a

get the active

in .A).

in JOBNUM ($F9) er (in .A) by

he result to .Y. om the header

to TRACK ($80) .

rom the header

to SECTOR($81).

n RTS.

WRTAB

RDAB

WRTOUT

RDIN

WRTSS

RDSS RDS5

$DE50

$DE57

$DE5E

$DE65

$DE6C

$DE73 $DE75 $DE78

Do read and write jobs:

Store $90(write job code) in CMD($024D) and branch to SJ10 (always).

Store $80(read job code) in CMD($024D) and branch to SJ10 (always).

Store $90(write job code) in CMD($024D) and branch to SJ20 (always).

Store $80(read job code) in CMD($024D) and branch to SJ20 (always).

Store $90(write job code) in CMD($024D) and branch to RDS5 (always). Load .A with $80 (read job code)

Store job code (in .A) into CMD($024D).

Load .X with the active buffer number

from LINDX ($82) .

$DE7A

Load .A with the

number from SS,X

to .X. If the SS branch to SJ30.

side sector buffer

($CD,X) and tranfer it buffer number < 127,

SJ10

$DE7F

JSR to SETHDR ($D6D0)
 to set header from

$DE82

TRACK and SECTOR.

JSR to GETACT to get the number (returned in .A).

active buffer

$DE85 $DE86

Transfer the buffer number

Copy the drive number from

to . X. DRVNUM

($7F)

to LSTJOB,X ($025B,X).

SJ20

$DE8B

$DE8E

JSR to CDIRTY ($E115)

dirty buffer flag.

JSR to GETACT ($DF93)

to clear the

to get the active

RDLNK

$DE91 $DE92

$DE95

buffer number (returned in .A).

Transfer the buffer number to .X. Continue routine with JMP to SETLJB

($D506) to set last used buffer.

Set TRACK & SECTOR from link in buffer: Load .A with $00 and JSR to SETPNT

($D4C8) to set the buffer pointer to the first byte in the buffer (track link).

332

-----------------------------------------------------Page 332-----------------------------------------------------
﻿
NAME

ADDRESS

$DE9A

$DE9F

$DEA4

DESCRIPTION OF WHAT ROM ROUTINE DOES

JSR to GETBYT ($D137) to read the track link. Store the link in TRACK ($80) .

JSR to GETBYT ($D137) to read the sector link. Store the link in SECTOR ($81) . Terminate routine with an RTS.

one buffer to another:

Move bytes from

number of bytes to move

On entry: .A = from buffer #

.Y =

to buffer #

.X =

B0TOB0

B02

$DEA5

$DEA6 $DEAC

$DEB1

$DEB6

$DEB9

$DEC0

Save number of onto the stack.

Zero TEMP ($6F) Move the hi byt pointer from BU TEMP+1 ($70).

Move the hi byt pointer from BU TEMP+3 ($72).

Pull the number

the stack, tran decrement .Y by Loop using .Y a transfer bytes

Terminate routi

bytes to move (in .A)

and TEMP+2 ($71).

e of the from buffer

FIND,Y ($FEE0,Y) to

e of the to buffer

FIND,X ($FEE0,X) to

-of-bytes-to-move from sfer it into .Y, and

1 (Oth byte is #1).

s a count-down index to from (TEMP)Y to (TEMP+2)Y

ne with an RTS.

CLRBUF

CB10

SSSET

SSDIR

$DEC1 $DEC2

$DEC7 $DECC $DED1

$DED2

$DED7

$DEDB

$DEDC $DEDE

$DEE0

$DEE2 $DEE3

$DEE8

Clear buffer: (buffer # in .A)

Transfer buffer number from .A to .Y.

Move the hi byte of the from buffer pointer from BUFIND,Y ($FEE0,Y) to

TEMP+1 ($70).

Zero TEMP ($6F) and .Y

Loop to fill buffer with $00's.

Terminate routine with an RTS.

Set side sector pointer to $00:

Zero .A and JSR to SSDIR ($DEDC) to set DIRBUF with current SS pointer.

Load ,Y with $02. Load .A with the side

sector pointer from (DIRBUF),Y; ($94),Y.

Terminate routine with an RTS.

Use SS pointer to set DIRBUF:

On entry: .A = lo byte

Store lo byte (in .A) into DIRBUF ($94)

Load .X with the active buffer number from LINDX ($82) .

Load .A with the side sector buffer

number from SS,X ($CD,X).

Transfer SS buffer number to .X.

Copy hi byte of buffer pointer from

BUFIND ($FEE0) to DIRBUF + 1 ($95) .

Terminate routine with an RTS.

333

-----------------------------------------------------Page 333-----------------------------------------------------
﻿
NAME
 ADDRESS
 DESCRIPTION OF WHAT ROM ROUTINE DOES

Use SS pointe

r to set. DIRBUF & BUFTAB:

= lo byte

On entry: .A

SETSSP

$DEE9 $DEEA

$DEED

$DEEE

$DEF1

$DEF4

$DEF7

Save lo byte

JSR to SSDIR

current. SS po On return, .A

the SS buffer onto the stac Transfer the

to .A, multip

transfer it. b

Pull hi byte

the stack and

($9A,X).

Pull lo byte

the stack and

($99,X).

Terminate rou

(in .A) onto the stack.

($DEDC) to set. DIRBUF from

inter.

contains the hi byte of pointer. Save the hi byte

k.

SS buffer number from .X

ly it. by two (ASL) , and

ack into .X.

of SS buffer pointer off store it. in BUFTAB + 1,X

of SS buffer pointer off

store it in BUFTAB,X

tine with an RTS.

SSPOS

SSP10

SSP20

IBRD

$DEF8

$DEFB

$DEFD

$DEFF

$DF01

$DF03 $DF06 $DF09

$DF0B

$DF0E

$DF12

$DF14

$DF17

$DF1B

Use SSNUM & SSIND to set SS & BUFTAB:

On return V = 0 all OK

V = 1 out of range

JSR to SSTEST ($DF66) to test if SSNUM &

SSIND are resident and within range. If N flag set, out of range so branch

to SSP10.

If V flag clear, it is in residence so

branch to SSP20.

Since V flag set, maybe in range and maybe not. Do another test:

Load .X with the active buffer number from LINDX ($82).

Load .A with the side sector buffer

number from SS,X ($CD,X).

JSR to IBRD ($DF1B) to read in the SS.

JSR to SSTEST ($DF6 6) to test again. If N flag clear, it is in range so

branch to SSP20.

Out of range so JSR to SSEND ($E1CB) to

set. SS & BUFTAB to end of last record.

BIT with ER1 ($FECE) to set flags and

terminate routine with an RTS.

Load .A with the SS pointer from SSIND

($D6) .

JSR to SETSSP ($DEE9) to set. DIRBUF and

BUFTAB.

BIT with ERO ($FECD) to set flags and

terminate routine with an RTS.

Indirect block read/write:

On entry: .A = buffer number for R/W

.X = active buffer (LINDX)

(DIRBUF),Y points to T&S to be R/W

Store buffer number (.A) in JOBNUM ($F9)

334

-----------------------------------------------------Page 334-----------------------------------------------------
﻿
NAME

IBWT

IBOP

GSSPNT

SCAL1

SSCALC

ADDT12

ADDRESS

$DF1D

$DF21 $DF23

$DF25 $DF26

$DF2C

$DF32

$DF37

$DF3B

$DF40

$DF45

$DF47

$DF49

$DF4C

$DF4E

$DF51

$DF54

$DF57 $DF5A

$DF5C $DF5D

DESCRIPTION OF WHAT ROM ROUTINE DOES

Load .A with $80 (read job code) and

branch to IBOP.

Store buffer number (.A) in JOBNUM ($F9)

Load .A with $90 (write job code)

Push the job code onto the stack.

Load .A with the file's drive number

from FILTYP,X ($EC,X), AND it with $01 to mask off the non-drive bits, and use it to set the drive, DRVNUM ($7F)

Pull the job code off the stack, OR it

with the drive number in DRVNUM ($7F), and store the result in CMD ($024D). Move the track number from (DIRBUF),Y ($94) ,Y to TRACK ($80) . Increment. .Y Move the sector number from (DIRBUF),Y

($94) ,Y to SECTOR ($81) .

Load .A with the buffer number from

JOBNUM ($F9) and JSR to SETH ($D6D3) to set up the header.

Load .X with the buffer number from

JOBNUM ($F9) and JMP to DOIT2 ($D593) to do the job.

Get side sector pointers:

Load .X with the active buffer number

from LINDX ($82).

Load .A with the side sector buffer

number from SS,X ($CD,X)

JMP to SETDIR($D4EB) to set. the DIRBUF pointers.

Calculate side sectors:

Load .A with $78, the number of side sector pointers in a buffer.

JSR to ADDT12 ($DF5C) to add the number

of side sectors needed * 120.

Decrement .X. If .X >= $00, branch to

SCAL1.

Load .A with the number of SS indices

needed from T3 ($72) and multiply it. by 2 (ASL) since two bytes (track & sec)

are needed for each index.

JSR to ADDT12 to add .A to Tl & T2. Load .A with the number of SS blocks needed from T4 ($73)

Clear the carry flag.

Add the contents of Tl ($70) to the

contents of the accumulator and store

the result, back in Tl ($70) .

335

-----------------------------------------------------Page 335-----------------------------------------------------
﻿
NAME

ADDRTS

ADDRESS

$DF61 $DF63 $DF65

DESCRIPTION OF WHAT ROM ROUTINE DOES

If carry is clear, branch to ADDRTS. Increment the value in T2 ($71) .

Terminate routine with an RTS.

Test SSNUM & SSIND for range & residence Flag meanings on exit:

N 0 0 1 1
 Range

OK

MAYBE

BAD BAD

V

0 1 0 1

Residence

YES NO

YES NO

ERO ER1 ER2 ER3

SSTEST

ST10

ST20

ST30

ST40

GETACT

$DF66

$DF69

$DF6D

$DF6F

$DF73

$DF77

$DF7B

$DF81

$DF83

$DF87

$DF8B

$DF8F

$DF93

$DF95

JSR to SSSET ($DED2) to set the pointer to $00 and get the SS number (in .A). Compare the SS number in .A with the one in SSNUM ($D5). If they are not equal, branch to ST20.

Load .Y with the pointer into the SS buffer from SSIND ($D6)

Load .A from (DIRBUF) ,Y; ($94) ,Y. If

this value is $00, the proper side

sector is not present so branch to ST10. BIT ERO ($FECD) to clear the N and V flags. All OK so exit, with an RTS.

Definitely out of range so BIT with E2

($FECF) and exit, with an RTS.

Load .A with the SS number from SSNUM

($D5) and compare it with $06, the

number of side sector links. If the

value in SSNUM > $06, branch to ST30. Multiply the SS number in .A by 2 (ASL)

and transfer the result, into .Y.

Load .A with $04, and store this value in DIRBUF ($94), lo byte of the pointer.

Load .A with the value from (DIRBUF),Y

($94),Y. If this value is not $00,

branch to ST40.

Way out. of range so BIT with E3 ($FED0)

and exit with an RTS.

Not in residence and range is unknown so BIT with El ($FECE) and exit, with RTS

Get active buffer number:

On exit: .A = active buffer number

.X = LINDX

Flag N = 1 if no active buffer

Load .X with the current, buffer number

from LINDX ($82) .

Load .A with the buffer number from

BUF0,X ($A7,X). If bit 7 is not. set,

this buffer is active so branch to GA1.

336

-----------------------------------------------------Page 336-----------------------------------------------------
﻿
NAME

ADDRESS
 DESCRIPTION OF WHAT ROM ROUTINE DOES

GA1

$DF99

$DF9B

Load .A with the buffer

BUF1,X ($AE,X).

AND the buffer number wi

number from

th $BF to strip

$DF9D

the dirty bit.

Terminate routine with an RTS.

Get active buffer & set- On exit: .A = active bu

LBUSED:

ffer number

.X = LINDX

Flag N = 1 if no active buffer

GAFLGS

$DF9E

Flag V = 1 if buff

Load .X with the current

er is dirty

buffer number

from LINDX ($82) .

GA2

$DFA0 $DFA3

$DFA7

Save buffer number into Load .A with the buffer

BUF0,X ($A7,X). If bit 7

this buffer is active so Transfer the buffer numb

.A, clear the carry flag

maximum number of channe

LBUSED ($0257).

number from

is not set,

branch to GA3. er from .X to

, add $07 (the Is + 1), and

store the result in LBUSED ($0257).

GA3

$DFAE

$DFB0 $DFB2

Load .A with the buffer

BUF1,X ($AE,X).

Store the buffer number AND the buffer number wi

the result with Tl ($70)

number from

in Tl ($70).

th $1F and BIT

to set the

$DFB6

N and V flags.

Terminate routine with an RTS.

Get a channel's inactive

buffer number:

On entry: LINDX = channel number

GETINA

GI10

$DFB7

$DFB9

$DFBD

$DFBF

On exit: .A = buffer # Load .X with the channel

LINDX ($82).

Load .A with the buffer

BUF0,X ($A7,X) . If bit. 7

buffer is inactive so br Load .A with the buffer

BUF1,X ($AE,X).

Compare the buffer numbe

or $FF if none

number from

number from

is set, this

anch to GI10. number from

r with $FF to

$DFC1

set the Z flag if inactive buffer found.

Terminate routine with an RTS.

PUTINA

$DFC2

$DFC4

$DFC6

Set the inactive buffer'

On entry: .A = buffer

Load .X with the channel

LINDX ($82) .

OR the buffer number in set the inactive buffer Load .Y with the buffer

BUF0,X ($A7,X) . If bit. 7

s buffer number: number

number from

.A with $80 to

bit.

number from

is clear, the

other buffer is the inactive one so

branch to PI1.

337

-----------------------------------------------------Page 337-----------------------------------------------------
﻿
NAME

ADDRESS
 DESCRIPTION OF WHAT ROM ROUTINE DOES

$DFCA

$DFCC

This buffer is inactive .

buffer number in BUF0,X

Exit with an RTS.

so store new

($A7,X).

PI1
 $DFCD

This buffer is inactive s

so store new

NXTREC

$DFCF

$DFD0

$DFD5

buffer number in BUF1,X
 ($AE,X).

Exit with an RTS.

Set up next relative record:

Load .A with $20 (overflow flag) and JSR to CLRFLG ($DD9D) to

clear the

record overflow flag.

Load .A with $80 (last record flag) and

test if we are
 JSR to TSTFLG ($DDA6) to out beyond the last recoi

rd. If not,

branch to NXTR40.

$DFDC

$DFDE

Load .X with the current

from LINDX ($82) .

Increment the lo byte of counter in RECL,X ($B5,X

channel number

the record

. If the result

is not $00, branch to NXTR15.

NXTR15

$DFE2

$DFE4

$DFE6

Increment, the hi byte of counter in RECH,X ($BB,X

Load .X with the current.

from LINDX ($82) .

Load .A with the pointer record from NR,X ($C1,X)

the record

.

channel number

to the next

$DFE8

If the next record pointer is $00, there

is no next record so branch to NXTR45.

$DFEA

$DFED

JSR to GETPNT ($D4E8) to pointer.

Load .X with the current.

from LINDX ($82).

get the buffer

channel number

$DFEF

Compare the buffer pointer in .A with

$DFF3

the pointer in NR,X ($C1

then branch to NXTR20.

Not in this buffer, must

,X). If BT<NR

be in the next.

one so JSR to NRBUF ($E03C) to set up

the next one.

NXTR20

$DFF6

$DFF8

Load .X with the current

from LINDX ($82) .

Load .A with the pointer

channel number

to the next

record from NR,X ($C1,X)

.

$DFFA

JSR to SETPNT ($D4C8) to

next, record.

advance to the

$DFFD
 Load .A with the first byte of the record from (BUFTAB,X) ($99,X).

$DFFF $E001

$E006

Save the first data byte Load .A with $20 (overfl JSR to CLRFLG ($DD9D) to record overflow flag.

JSR to ADDNR ($E304) to pointer.

into DATA ($85)

ow flag) and

clear the

advance the NR

-----------------------------------------------------Page 338-----------------------------------------------------
﻿
NAME

NXOUT

NXTR45

NXTR40

NXTR50

NXTR3 0

NXTR35

NRBUF

ADDRESS

$E009

$E00C

$E013

$E018

$E01D $E020

$E025 $E029

$E02A $E02D

$E033

$E034

$E035

$E039

$E03C

$E03F

$E042

$E047 $E04A

$E04D

$E052

DESCRIPTION OF WHAT ROM ROUTINE DOES

Save the new value of NR (in .A) onto

the stack. If the carry flag is clear, we have NOT crossed a block boundary so

branch to NXTR30.

Load .A with $00 and JSR to DRDBYT ($D4F6) to read the track link of the

data block. If the track link is not.

$00, this is not the last block so

branch to NXTR30.

Pull the new NR value off the stack and

compare it to $02. If it equals $02,

branch to NXTR50.

Load .A with $80 (last record flag) and JSR to SETFLG ($DD97) to set this flag. JSR to GETPRE ($D12F) to get pointers. Move the data byte from BUFTAB,X ($99,X) to LSTCHR ($0244).

Store $0D (carriage return) in DATA($85)

Terminate routine with an RTS.

JSR to NXTR35 ($E035) to store NR value Load .X with the channel number from

LINDX ($82). Store $00 in NR,X ($C1,X).

Terminate routine with an RTS.

Pull the new NR value off the stack.

Load .X with the channel number from

LINDX ($82). Store the byte in .A into

NR,X ($C1,X).

Terminate routine with a JMP to SETLST

($E16E) to set the pointer to the last

character.

Set up next record in buffer:

JSR to SETDRN ($D1D3) to set drive

number to agree with the last job.

JSR to RDLNK ($DE9 5) to set TRACK and SECTOR from the track & sector link. JSR to GAFLGS ($DF9E) to test if the current buffer is dirty (changed). If V flag clear, it is clean; branch to

NRBU50 so we don't write it out.

JSR to WRTOUT ($DE5E) to write it out. JSR to DBLBUF ($CF1E) to toggle the

active and inactive buffers.

Load .A with $02 and JSR to SETPNT

($D4C8) to set the pointer to point to the first data byte in the new sector. JSR to TSTWRT ($DDAB) to test, if the last job was a write. If it was not a write job, branch to NRBU20 ($E07B)

since buffer is OK.

339

-----------------------------------------------------Page 339-----------------------------------------------------
﻿
NAME

NRBU50

NRBU70

NRBU20

RELPUT

RELP0 6 RELP05

ADDRESS

$E057

$E05A

$E05D

$E060

$E065

$E068

$E06B

$E06E

$E072

$E075

$E078

$E07B

$E07C

$E07F

$E082

$E084

$E088

$E08D

$E08F

$E094 $E096 $E097

$E099

DESCRIPTION OF WHAT ROM ROUTINE DOES

JSR to RDAB ($DE57) to read in needed

buffer.

JSR to WATJOB ($D599) to wait, for the

read job to be completed.

JSR to DBLBUF ($CF1E) to toggle the

active and inactive buffers.

JSR to TSTWRT ($DDAB) to test if the last job was a write. If it was not a

write job, branch to NRBU70.

JSR to RDAB ($DE57) to read in needed

buffer.

JSR to WATJOB ($D599) to wait for the

read job to be completed.

JSR to RDLNK ($DE95) to set TRACK and

SECTOR from the track & sector link. Load .A with the track link from TRACK

($80). If track link is $00, this is the

last, block with no double buffering

needed so branch to NRBU20.

JSR to DBLBUF ($CF1E) to toggle the

active and inactive buffers.

JSR to RDAB ($DE5E) to start a read job

for the inactive buffer.

JSR to DBLBUF ($CF1E) to toggle the

active and inactive buffers. Terminate routine with an RTS.

Put relative record into buffer:

JSR to SDIRTY ($E105) to flag buffer as dirty (ram version changed).

JSR to GETACT ($DF93) to get active buffer number (returned in .A).

Multiply the buffer number (in .A) by

two (ASL) and transfer the result to .X. Copy the data byte from DATA ($85) into the buffer at (BUFTAB,X) ($99,X).

Load .Y with the lo byte of the pointer BUFTAB,X and increment, the pointer in .Y by 1. If the new pointer value is NOT

$00, branch to RELP05.

Load .Y with the channel number from LINDX ($82) .

Load .A with the next record pointer from NR,Y. If this value is $00, branch

to RELP07.

Load .Y with $02.

Transfer the contents of .Y to .A. Load .Y with the channel number from LINDX ($82).

Compare the contents of .A to NR,Y

($C1,Y) to test if NR = pointer. If they

are not equal, NR is not a pointer so branch to RELP10 to set. new pointer.

340

-----------------------------------------------------Page 340-----------------------------------------------------
﻿
NAME

RELP0 7

RELP10

RELP20

WRTREL

WR10

WR2 0

WR3 0

WR4 0

WR4 5

WR5 0

WR51

WR60

ADDRESS

$E09E

$E0A3

$E0A7 $E0AA

$E0AB

$E0B0

$E0B2

$E0B7

$E0BB

$E0BC

$E0C1 $E0C3

$E0C8

$E0CB

$E0CE

$E0D3

$E0D6

$E0D9

$E0DD

$E0E1

$E0E2

DESCRIPTION OF WHAT ROM ROUTINE DOES

Load .A with $20 (the overflow flag)

and JMP to SETFLG ($DD97) to set the overflow flag and exit.

Increment the lo byte of the pointer BUFTAB,X ($99,X). If the result is not $00, we don't need the next buffer so

branch to RELP20.

JSR to NRBUF($E03C) to get next buffer.

Terminate routine with an RTS.

Write out relative records:

Load .A with $A0 (last record flag + overflow flag) and JSR to TSTFLG ($DDA6)

to check for last record & overflow.

If Z flag clear, some flag is set so

branch to WR5 0.

Load .A with the byte from DATA ($85) and JSR to RELPUT ($E07C) to put the

data into the buffer.

Load .A with the EOIFLG ($F8). If it equals $00, an EOI was NOT sent so

branch to WR40.

Terminate routine with an RTS.

Load .A with $20 (overflow flag) and JSR to TSTFLG ($DDA6) to test for an

overflow error.

If Z set, no error so branch to WR40. Overflow error so load .A with $51 (recover flag) and store it in ERWORD ($026C) to flag the error.

JSR to CLREC ($E0F3) to clear the rest

of the record.

JSR to RD40 ($E153) to set up for the

next, record.

Load .A from ERWORD ($026C). If it is $00, no errors so branch to WR45. Abort with a JMP to CMDERR ($C1C8)

Terminate with a JMP to OKERR ($E6BC).

AND the error flag in .A with $80 (the last record flag). If the result is not $00, the last record flag was set so

branch to WR60 to add to file.

Load .A with the EOIFLG ($F8). If this is $00, an EOI was not sent, so branch

to WR3 0.

Terminate routine with an RTS.

Load .A with the data byte from DATA

($85) and push it onto the stack.

341

-----------------------------------------------------Page 341-----------------------------------------------------
﻿
NAME

CLREC

CLR10

SDIRTY

CDIRTY

RDREL

RD10

ADDRESS

$E0E5

$E0E9

$E0EB

$E0F0

$E0F3

$E0F8

$E0FA

$E101

$E104

$E105 $E107 $E10A

$E10D

$E10F

$E112

$E114

$E115

$E118

$E11A

$E11D

$E11F

$E120

$E125

$E127

$E12A

DESCRIPTION OF WHAT ROM ROUTINE DOES

JSR to ADDREL ($E31C) to add to the

relative file.

Pull the data byte off the stack and put it back in DATA ($85) .

Load .A with $80 (last, record flag) and JSR to CLRFLG ($DD9D) to clear the flag.

JMP to WR10.

Clear rest of relative record:

Load .A with $20 (overflow flag) and

' "JSR'to'TbTt'LiG ($DUA6") tcrt'es't the flag'. If Z flag not set, overflow has occured

so branch to CLR10 to exit.

Set DATA ($85) to $00 and JSR to RELPUT ($E07C) to put a null byte in the buffer

Loop with a JMP to CLREC ($E0F3).

Terminate routine with an RTS.

Set buffer dirty flag:

Load .A with $40 (dirty flag).

JSR to SETFLG ($DD9 7) to set flag. JSR to GAFLGS ($DF9E) to get active buffer number in .A and set flags. OR the contents of .A with $40 to set the dirty flag.

Load .X with the number of the last

buffer used from LBUSED ($0257).

Store the content of .A as the buffer

number in BUF0,X ($A7,X).

Terminate routine with an RTS.

Clear buffer dirty flag:

JSR to GAFLGS ($DF9E) to get active buffer number and set flags.

AND the contents of .A with $BF to clear the dirty flag.

Load .X with the number of the last

buffer used from LBUSED ($0257).

Store the content of .A as the buffer

number in BUF0,X ($A7,X).

Terminate routine with an RTS.

Read relative record:

Load .A with $80 (last record flag) and JSR to TSTFLG ($DDA6) to test the flag. If Z flag not set, last record error has

occured so branch to RD05.

JSR to GETPRE ($D12F) to set pointers to existing buffer.

Load .A with the lo byte of the buffer pointer from BUFTAB,X ($99,X).

342

-----------------------------------------------------Page 342-----------------------------------------------------
﻿
NAME

RD15

RD20

RD2 5

RD3 0

RD40

RD05

SETLST

ADDRESS

$E12C

$E131

$E135

$E138

$E13B

$E13D $E140

$E145

$E14C

$E14D

$E152

$E153

$E156

$E159 $E15B

$E15E

$E160

$E165

$E169

$E16E

$E170

DESCRIPTION OF WHAT ROM ROUTINE DOES

Compare this value to the contents of LSTCHR,Y ($0244). If they are equal,

branch to RD40 because we want the next record not the last one.

Increment the buffer pointer in BUFTAB,X ($99,X). If the result is not equal to $00, we don't need the next buffer so

branch to RD20.

JSR to NRBUF ($E03C) to read in the

next buffer of relative records.

JSR to GETPRE ($D12F) to set pointers to existing buffer.

Load .A with the data byte from

(BUFTAB,X); ($99,X).

Store the data byte in CHNDAT,Y($023E,Y) Load .A with $89 (random access - ready)

and store this as the channel status in

CHNRDY,Y ($F2,Y).

Load the pointer from BUFTAB,X ($99,Y) and compare it to the pointer to the

last character in the record from

LSTCHR,Y ($0244,Y). If they are equal,

branch to RD30 to send EOI. Terminate routine with an RTS.

Load .A with $81 (random access - EOI)

and store this as the channel status in

CHNRDY,Y ($F2,Y).

Terminate routine with an RTS.

JSR to NXTREC ($DFD0) to get the next

record.

JSR to GETPRE ($D12F) to set pointers to existing buffer.

Load .A with the byte from DATA ($85). JMP to RD25 to carry on.

No record error so load .X with the

channel number from LINDX ($82) .

Store $0D (carriage return) as the data

byte in CHNDAT,X ($023E,X).

Load .A with $81 (random access - EOI) and store this as the channel status in

CHNRDY,Y ($F2,Y).

Load .A with $50 (no record error) and abort with a JMP to CMDERR ($C1C8).

Set pointer to last character in record:

Load .X with the channel number from

LINDX ($82)

Copy the next record pointer from NR,X

($C1,X) into Rl ($87).

343

-----------------------------------------------------Page 343-----------------------------------------------------
﻿
NAME

SETL01

SETL0 5

SETL10

SETL40

FNDLST

FNDL10

ADDRESS

$E174

$E17A

$E17E

$E182

$E18D

$E190

$E195

$E197

$E19A

$E19D

$E1A0

$E1A4

$E1A9

$E1AC

$E1AE

$E1B1

$E1B2

$E1B5

$E1B7

$E1BB

DESCRIPTION OF WHAT ROM ROUTINE DOES

Decrement the pointer in Rl ($8 7) by 1 and compare the result, to $02, the pointer to the first data byte in the sector. If the pointer does not equal

$02, branch to SETL01.

Store $FF into Rl ($87) so it. points to the last byte in a sector.

Copy the record size from RS,X ($C7,X) into R2 ($88) .

JSR to GETPNT ($D4E8) to get. the pointer into the active buffer (returned in .A) Compare this value with the pointer in

Rl "($87). If Rl >= .A branch to SETL10.

JSR to DBLBUF ($CF1E) to toggle the

active and inactive buffers.

JSR to FNDLST ($E1B2) to find the last. character. On return, if carry is clear,

branch to SETL05.

Load .X with the channel number from

LINDX ($82) .

Store the character in .A into LSTCHR,X

($0244,X).

JMP to DBLBUF ($CF1E) to toggle the

active and inactive buffers and exit.

JSR to DBLBUF ($CF1E) to toggle the

active and inactive buffers.

Store $FF into Rl ($87) so it points to the last byte in a sector.

JSR to FNDLST ($E1B2) to find the last

non-zero character in the record. On

return, if carry set, branch to SETL40. JSR to GETPNT ($D4E8) to get the pointer into the active buffer (returned in .A)

Load .X with the channel number from

LINDX ($82) .

Store the character in .A into LSTCHR,X

($0244,X).

Terminate routine with an RTS.

Find last non-zero character in record:

JSR to SETOO ($DE2B) to set up pointer

to start of buffer.

Load .Y with the offset to start at. from Rl ($87) .

Load .A with the data byte from the buffer at (DIRBUF),Y; ($94),Y. If the data byte is not $00, branch to FNDL20. Decrement the pointer in .Y. If the

resulting pointer is less than or equal to $02, branch to FNDL30 since the

start of the record is not in here.

344

-----------------------------------------------------Page 344-----------------------------------------------------
﻿
NAME

FNDL3 0

FNDL20

SSEND

SE10

SE20

SE30

ADDRESS

$E1C0

$E1C4

$E1C8

$E1C9

$E1CE

$E1CE

$E1D0

$E1D4

$E1D8

$E1DC

$E1E0 $E1E1

$E1E6

$E1E8

$E1EA

$E1EF

$E1F3

$E1F7 $E1F8

DESCRIPTION OF WHAT ROM ROUTINE DOES

Decrement the record size in R2 ($88). If R2 has not counted down to $00 yet,

branch FNDL10.

Decrement the record size in R2 ($88).

Clear the carry flag to indicate that

the record was not. found here and exit from the routine with an RTS.

Found the last, non-zero character so

transfer the pointer from .Y to .A. Set the carry flag to indicate it. was

found here and terminate with an RTS.

Set SS & BUFTAB to end of last record:

JSR to SSSET ($DED2) to set the SS

pointer to $00.

Store the side sector number returned

in .A into SSNUM ($D5).

Set the lo byte of the pointer in DIRBUF ($94) to $04.

Load .Y with $A0 (the side sector offset

less 6) and branch to SE20 (always). Decrement pointer in .Y by 2. If the result is less than $00, branch to BREAK Look for the last SS number by loading .A from (DIRBUF),Y; ($94),Y. If the byte is $00, we have not found it. yet

so branch back to SE10.

Transfer the pointer in .Y into .A. Multiply the pointer in .A by 2 (ASL) and compare the result to the side sector number in SSNUM ($D5). If they are equal, this is the last SS number

so branch to SE30.

Store the SS number in .A into SSNUM

($D5).

Load .X with the channel number from LINDX ($82) .

Load .A with the side sector from

SS,X ($CD,X) and JSR to IBRD ($DF1B)

to do an indirect block read of the last side sector.

Zero .Y and set the lo byte of the pointer in DIRBUF ($94) to $00.

Load .A with track link from (DIRBUF),Y ($94),Y. If the link is not $00, branch

to BREAK.

Increment .Y

Load .A with sector link from (DIRBUF),Y ($94),Y. This points to the last good byte in the buffer. Transfer the pointer to .Y, decrement it by 1, store it in SSIND ($D6), and transfer it back to .A.

345

-----------------------------------------------------Page 345-----------------------------------------------------
﻿
NAME

ADDRESS
 DESCRIPTION OF WHAT ROM ROUTINE DOES

$E1FF JMP to SETSSP ($DEE9) to set DIRBUF and

BUFTAB with current SS pointer.

BREAK $E202 Load .A with $67 to indicate a SYSTEM

TRACK OR SECTOR error and JSR to CMDERR2

($E645).

RECORD COMMAND

Position pointer to given record

RECORD

$E207

$E20A

$E20F

$E212

$E214

Note: set to JSR to CMDSET

pointers and

Load .A with command from to set the se JSR to FNDRCH read channel.

If carry flag

branch to R20 Load .A with CHANNEL error

last, record if out of range ($C2B3) to initialize the

tables.

the second character in the

CMDBUF+1 ($0201) and use it condary address in SA ($83) ($D0EB) to find an unused

clear, channel found so

$70 to indicate a NO

and JSR to CMDERR ($C1C8).

R20

R30

$E219

$E21E

$E223

$E228

$E22E

$E233

$E238

$E23A

$E23E

$E243

Load .A with $A0 (last, record flag plus overflow flag) and JSR to CLRFLG ($DD9D) to clear these flags.

JSR to TYPFIL ($D125) to determine the file type. If the Z flag is set, it is

a relative file so branch to R30.

Load .A with $64 to indicate a FILE TYPE MISMATCH error and JSR to CMDERR ($C1C8)

Load .A with the file type from FILTYP,X ($EC,X), AND the type with $01 to mask

off the non-drive bits, and store the result as the drive # in DRVNUM ($7F). Load .A with the third character in the command from CMDBUF+2 ($0202) and use it to set the lo byte of the record number in RECL,X ($B5,X).

Load .A with the fourth character in the

command from CMDBUF+3 ($0203) and use it to set the hi byte of the record number in RECH,X ($BB,X).

Load .X with the channel number from LINDX ($82).

Store $89 (random access - ready) as the channel status in CHNRDY,X ($F2,X).

Load .A with the fifth character in the command from CMDBUF+4 ($0204). This is the byte pointer into the record. If the byte pointer is $00, branch to R40.

Set. the carry flag and subtract $01 from the byte pointer. If the result is $00,

branch to R40.

346

-----------------------------------------------------Page 346-----------------------------------------------------
﻿
NAME

R40

R50

R60

POSITN

P2

P30

ADDRESS

$E248

$E24C

$E253

$E255

$E258

$E25D

$E262

$E265

$E268

$E26F

$E272

$E275

$E278

$E27D

$E27F

$E282

$E286

$E289

$E28E $E291

DESCRIPTION OF WHAT ROM ROUTINE DOES

Compare the adjusted byte pointer to the record size in RS,X ($C7,X). If the byte pointer is within the record, branch to

R40.

Load .A with $51 (record overflow) and store it in ERWORD ($026C). Zero .A. Store the byte pointer (in .A) into RECPTR ($D4).

JSR to FNDREL ($CE0E) to calculate the side sector pointers.

JSR to SSPOS ($DEF8) to set the side sector pointers. If V flag is clear, we have not attempted to go beyond the

last record so branch to R50.

Load .A with $80 (last record flag) and JSR to SETFLG ($DD97) to set the flag. JMP to RD05 ($E15E) to set pointers to

the last record.

JSR to POSITN ($E275) to position to the

desired record.

Load .A with $80 (last, record flag) and JSR to TSTFLG ($DDA6) to test, if this flag has been set. If not, branch to

R60 to exit.

JMP to RD05 ($E15E) to set pointers to

the last, record.

JMP to ENDCMD ($C194) to terminate.

Position to record:

Moves relative record into active buffer and the next block into inactive buffer.

JSR to POSBUF ($E29C) to position data

blocks into buffers.

Load .A with the pointer from RELPNT ($D7) and JSR to SETPNT ($D4C8) to set

up the buffer pointers.

Load .X with the channel number from

LINDX ($82) .

Load .A with the record size from RS,X

(C7,X) and set. the carry flag.

Subtract the pointer in RECPNT ($D4)

from the record size in .A to find the

offset. If offset > $00, branch to P2. Trouble! JMP to BREAK ($E202).

Clear the carry flag and add the pointer in RELPNT ($D7). If there is no carry,

branch to P30.

Add another $01 and set the carry flag. JSR to NXOUT ($E009) to set up the next.

record.

347

-----------------------------------------------------Page 347-----------------------------------------------------
﻿
NAME

POSBUF

P10

P75

P80

BHERE

BHERE2

BH10

ADDRESS

$E294

$E297

$E29C

$E2A0

$E2A4

$E2A9

$E2AA $E2AD

$E2B0

$E2B4

$E2B9

$E2BC

$E2BF

$E2C2 $E2C4

$E2C9

$E2CD

$E2D0

$E2D3 $E2D5

$E2D9

$E2DC $E2DD

$E2E1

DESCRIPTION OF WHAT ROM ROUTINE DOES

JMP to RD15 ($E138) to complete set up.

- * - * - UNUSED CODE - * - * -

Load .A with $51 (record overflow) and JSR to CMDERR ($C1C8).

Position proper data blocks into buffers Save the lo byte of the DIRBUF ($94/5) pointer into R3 ($89) .

Save the hi byte of the DIRBUF ($94/5) pointer into R4 ($8A).

JSR to BHERE ($E2D0) to check if desired block is in the buffer. If not, branch

to P10 to read it in.

Terminate routine with an RTS.

JSR to SCRUB ($DDF1) to clean the buffer JSR to GETLNK ($DE0C) to set TRACK and SECTOR from the link.

If TRACK ($80) is $00, there is no next-

track so branch to P80.

JSR to BHERE ($E2D0) to check if desired block is in the buffer. If not, branch

to P7 5 to read it. in.

JSR to DBLBUF ($CF1E) to toggle the

active and inactive buffers.

JMP to FREIAC ($D2DA) to free the inactive buffer.

JSR to FREIAC ($D2DA) to free the

inactive buffer.

Load .Y with $00.

Move the desired track from (R3),Y ($89),Y into TRACK ($80). Increment .Y Move the desired sector from (R3),Y

($89),Y into SECTOR ($81).

JMP to STRDBL ($D0AF) to read in the desired block and the next, one too.

Check if desired block is in buffer:

JSR to GETHDR ($DE3E) to set TRACK and

SECTOR from the header.

Load .Y with $00

Compare the desired track from (R3),Y ($89),Y with the value in TRACK ($80). If they are equal, branch to BH10 to compare the sectors.

No match (Z=0) so exit with an RTS

Increment. .Y.

Compare the desired sector from (R3),Y ($89),Y with the value in SECTOR ($81).

This sets Z=l if they are equal.

Terminate routine with an RTS.

348

-----------------------------------------------------Page 348-----------------------------------------------------
﻿
NAME

NULBUF

NB20

NB30

ADDRESS

$E2E2

$E2E5

$E2EE

$E2F1

$E2F3 $E2F4

$E2F8

$E2FB

$E2FD $E2FF

$E303

DESCRIPTION OF WHAT ROM ROUTINE DOES

Set null records in active buffer:

JSR to SETOO ($DE2B) to set pointers to

start of data buffer.

Loop to fill data buffer with $00's from $xx02 to $xxFF.

JSR to ADDNR ($E304) to calculate the position of the next record (in .A). Store the new pointer value in NR,X

($C1,X).

Transfer the next, record pointer to .Y. Store $FF as the first, character in the next record at (DIRBUF) ,Y; ($94) ,Y. JSR to ADDNR ($E304) to calculate the position of the next, record (in .A). If carry flag is clear, we haven't, done all the records in this block yet so

branch to NB20.

If the Z flag is not set, branch to NB30 Store $00 into NR,X ($C1,X) to flag the

last record.

Terminate routine with an RTS.

Add record si

ze & next record pointer: if crossed buffer boundary

On exit: C=l

ADDNR

$E304

$E306

$E309 $E30B

$E30E $E310 $E312 $E314 $E317

Load .X with

LINDX ($82) .

Load .A with

from NR,X ($C If NR pointer

Clear the car

size from RS, If carry clea

If result is Load .A with BIT with ER00 Terminate rou

the channel number from

the next record pointer

1,X) and set. the carry flag

is $00 branch to AN05.

ry flag and add the record

X~ ($C7,X).

r, branch to AN10.

not. $00, branch to AN05. $02 (bypass link)

($FECC) to set. flags.

tine with an RTS

AN0 5

AN10

ADDREL

$E318

$E31B

$E31C

SE31F

$E322

$E325

$E328

$E32C

Add $01 to the contents of .A to adjust for the link and set the carry flag.

Terminate routine with an RTS

Add blocks to a relative file:

JSR to SETDRN ($D1D3) to set drive #. JSR to SSEND ($E1CB) to set up end of

file.

JSR to POSBUF ($E29C) to position the proper data blocks into the buffers. JSR to DBSET ($CF7C) to set. up double buffering.

Copy side sector index from SSIND ($D6)

into Rl ($87).

Copy side sector number from SSNUM ($D5)

into R0 ($86) .

349

-----------------------------------------------------Page 349-----------------------------------------------------
﻿
NAME

ADDRESS

$E330

$E334

DESCRIPTION OF WHAT ROM ROUTINE DOES

Set R2 ($88) to $00 to clear the flag

fcr one block.

Set RECPTR ($D4) to $00 to clear this

for calculations.

ADDR1

$E338

$E33B

JSR to FNDREL ($CE0E) side sector pointers. JSR to NUMFRE ($EF4D)

to calculate the

to calculate the

AR10

AR20

AR25

AR30

$E33E

$E340

$E344

$E347

$E349

$E34F

$E355

$E35D

$E363

$E368

$E36B

$E36F

$E372

$E374

$E37A

number of blocks free.

Load .Y with the channel number from LINDX ($82).

Load .X with the record size from RS,Y ($C7,Y), decrement, the size by 1, and

transfer the result, into .A.

Clear the carry flag and add the record pointer, RELPTR ($D7) to the record size

in .A.

If no carry results, there is no span

to the next block so branch to AR10.

Increment the SS pointer, SSIND ($D6) twice. If the result is not. zero, branch

to AR10.

Increment the side sector number, SSNUM (D5) by 1 and store $10 (the side sector offset) into SSIND ($D6) since we are starting a new block.

Load .A with the SS index from Rl, clear

the carry flag, add $02, and JSR to

SETSSP ($DEE9) to set DIRBUF & BUFTAB.

Load the side sector number from SSNUM

($D5) and compare it with $06, the

number of side sector links. If SSNUM

is less than or equal to $06, the range

is valid so branch to AR25.

Load .A with $52 to indicate a TOO BIG

RELATIVE FILE error and JSR to CMDERR

($C1C8) .

Load .A with the side sector index from

SSIND ($D6) and set the carry flag.

Subtract, the SS index from Rl ($87) . If

the result is positive, branch to AR30. Subtract. $0F (the side sector index

offset less 1) and clear the carry flag.

Store the number of side sector indicies

(in .A) into T3 ($72).

Load .A with the SS number from SSNUM

($D5). Subtract the SS number from R0 ($86) to find the number of side sectors

needed. Store the number needed into T4 ($73) .

Zero Tl ($70) and T2 ($71) to serve as

a results accumulator.

350

-----------------------------------------------------Page 350-----------------------------------------------------
﻿
NAME

AR35

AR40

ADDRESS

$E380

$E384

$E388

$E38D $E38F

$E396

$E39D

$E3A2

$E3A5

$E3A7

$E1-A9

$E3AC

$E3AF

DESCRIPTION OF WHAT ROM ROUTINE DOES

Transfer the number of side sectors needed from .A to .X and JSR to SSCALC

($DF51) to calculate the number of

blocks needed.

Load .A with the hi byte of the number needed from T2 ($71). If the hi byte is

not $00, branch to AR35.

Load .X with the lo byte of the number needed from Tl ($70) . Decrement .X by 1. If the result is not. $00, branch to AR35 Increment R2 ($88) by 1.

Check if there are enough blocks left: Compare the hi byte of the number of blocks needed (in .A) with the hi byte

of the number of blocks free in NBTEMP+1

($0273) . If there are more than enough, branch to AR40. If there are NOT enough, branch to AR20. If we have just enough, we had better check the lo byte.

Load .A with the lo byte of the number free from NBTEMP ($0272) and compare it. with the lo byte of the number needed in Tl ($70) . If there are not. enough,

branch to AR20 to abort.

Load .A with $01 and JSR to DRDBYT ($D4F6) to read the sector link.

Clear the carry flag and add $01 to .A to give the NR.

Load .X with the channel number from

LINDX ($82) .

Store the NR value (in .A) into NR,X

($C1,X).

JSR to NXTTS ($F11E) to get the next

available track and sector.

JSR to SETLNK ($DDFD) to set. the track and sector link in the current block.

Load .A with the add-1-block flag from R2 ($88). If the flag is set, branch

to AR5 0.

AR45

$E3B3

$E3B6 $E3B9

JSR to WRTOUT ($DE5E)

current block to disk

JSR to DBLBUF ($CF1E) JSR to SETHDR ($D6D0)

to write the

to switch buffers. to set header from

AR50

$E3BC

$E3BF

$E3C2

$E3C5

$E3C8

TRACK and SECTOR.

JSR to NXTTS ($F11E) to get the next

available track and sector.

JSR to SETLNK ($DDFD) to set the track and sector link in the current, block. JSR to NULBUF ($E2E2) to clean out the

buffer

JMP to AR55 ($E3D4).

JSR to DBLBUF ($CF1E) to switch buffers.

351

-----------------------------------------------------Page 351-----------------------------------------------------
﻿
NAME

AR5 5

AR6 0

ADDRESS

$E3CB

$E3CE

$E3D1

$E3D4

$E3D7

$E3DA

$E3E0

$E3E3

$E3E9

$E3EC

$E3EF

$E3F2

$E3F7

$E3F9

$E3FD

$E401

$E404

$E407

$E409

$E40F

$E412

DESCRIPTION OF WHAT ROM ROUTINE DOES

JSR to SETHDR ($D6D0) to set header from

TRACK and SECTOR.

JSR to NULBUF ($E2E2) to clean out the

buffer

JSR to NULLNK ($DE19) to set link for

the last block.

JSR to WRTOUT ($DE5E) to write the

current block to disk.

JSR to GETLNK ($DE0C) to set TRACK and

SECTOR from the track & sector link.

Save the value of TRACK ($80) and SECTOR

($81) onto the stack.

JSR to GETHDR ($DE3E) to set TRACK and

SECTOR from the last, sector read.

Save the value of TRACK ($80) and SECTOR

($81) onto the stack.

JSR to GSSPNT ($DF45) to calculate the side sector pointer (returned in .A)

Transfer the pointer in .A to .X. If the pointer value is not $00, we don't need

another side sector so branch to AR60.

JSR to NEWSS ($E44E) to get another side

sector.

Load .A with $10, side sector offset, and JSR to SETSSP ($DEE9) to set the side sector pointer.

Increment the side sector count in R0

($86) by 1.

Pull this sector's track off the stack and JSR to PUTSS ($DD8D) to write it

into the side sector buffer.

Pull this sector's sector off the stack and JSR to PUTSS ($DD8D) to write it

into the side sector buffer.

Pull this sector's sector link off the

stack and store it in SECTOR ($81).

Pull this sector's track link off the stack and store it. in TRACK ($80) .

If track link is $00, there are no more

blocks in this file so branch to AR65

Compare the side sector counter in R0 ($86) with the end count, in SSNUM ($D5). If they are not equal, we haven't done enough new blocks yet so branch to AR45. Almost, done so JSR to GSSPNT ($DF45) to get the side sector pointer.

Compare the pointer in .A with the end pointer in SSIND($D6). If SSIND>.A, we

are almost, done so branch to AR45. If SSIND=.A there is one more block left, so branch to AR50.

352

-----------------------------------------------------Page 352-----------------------------------------------------
﻿
NAME

AR6 5

AR70

NEWSS

ADDRESS

$E418

$E41C

$E421

$E427

$E42D

$E430

$E433 $E436

$E439

$E43C

$E43F

$E441

$E444

$E44E

$E451

$E454

$E457

$E45B $E45E

DESCRIPTION OF WHAT ROM ROUTINE DOES

All done. JSR to GSSPNT ($DF45) to get the side sector pointer. Save it onto

the stack.

Load .A with a $00 and JSR to SSDIR ($DEDC) to set DIRBUF with the current

SS pointer.

Zero .A and .Y. Zero the track link of

the side-sector sector in (DIRBUF),Y

($94),Y. Increment .Y.

Pull the pointer into this sector off the stack, subtract $01, and store the

result as the sector link of the side- sector sector in (DIRBUF),Y; ($94),Y. JSR to WRTSS ($DE6C) to write out. the

current block of side sectors to disk.

JSR to WATJOB ($D599) to wait for the write job to be completed.

JSR to MAPOUT ($EEF4) to write the BAM. JSR to FNDREL ($CE0E) to find the

relative file and calculate SSNUM and SSIND for the desired record.

JSR to DBLBUF ($CF1E) to get. back to the leading buffer.

JSR to SSPOS ($DEF8) to position SS and

BUFTAB to SSNUM and SSIND.

On return, if V flag is set, the record is still beyond the end of the relative

file so branch to AR70.

All OK so exit, from routine with a JMP

to POSITN ($E275) to position to the

record.

Still beyond end of file so: load .A with $80 (the last record flag), JSR to SETFLG ($DD97) to set the flag, load .A with $50 (no record error) and exit, with a JSR to CMDERR ($C1C8).

Create a new side sector and change the

old side sectors to reflect, it.

JSR to NXTTS ($F11E) to find the next

available track and sector.

JSR to DBLBUF ($CF1E) to toggle to the

inactive buffer.

JSR to SCRUB ($DDF1) to write out the

buffer if it. is dirty (doesn't match copy on disk).

JSR to GETACT ($DF93) to determine the active buffer number (returned in .A).

Save the buffer number onto the stack.

JSR to CLRBUF ($DEC1) to zero the buffer

Load .X with the channel number from

LINDX ($82) .

353

-----------------------------------------------------Page 353-----------------------------------------------------
﻿
NAME

ADDRESS

$E460

$E463

$E465 $E467

$E46A

$E46F

$E474

$E479

DESCRIPTION OF WHAT ROM ROUTINE DOES

Load .A with the number of the buffer

containing the side sectors from SS,X ($CD,X) and transfer this value into .Y. Pull the active buffer number off the stack and transfer it into .X.

Load .A with $10, the side sector offset JSR to B0TOB0 ($DEA5) to move $10 (.A)

bytes from buffer #(.X) to buffer #(.Y).

Load .A with $00 and JSR to SSDIR($DEDC) to set the pointer at DIRBUF ($94) to point to the start of the old SS buffer.

Load .Y with $02, and load .A with the side sector number from (DIRBUF),Y and save it. onto the stack.

Zero .A and JSR to SETPNT ($D4C8) to set the pointer at. DIRBUF ($94) to point, to

the start of the new SS buffer.

Pull the SS number off the stack, add 1,

and store the result, in the new side

sector table at. (DIRBUF) ,Y.

$E47F

$E485

Multiply the add 4, store

new SS value and transfer

Subtract $02 this pointer

SS number in .A by 2 (ASL), the result, (points to the in the buffer) in R3 ($89),

this value into .Y.

from the result, and store

in R2 ($88) .

$E48A

$E490 $E491

$E497

$E49C

$E4A1

$E4A6

$E4A9

Copy the current value of TRACK ($80) into Rl ($87) for use in SS update and into the new SS buffer at. (DIRBUF) ,Y

Increment. .Y

Copy the current, value of SECTOR ($81) into R2 ($88) for use in SS update and into the new SS buffer at (DIRBUF),Y

Set the track link at the start of the

new SS block to $00.

Set. the sector link at. the start, of the

new SS block to $11 to indicate that the last non-zero character in the buffer is

the one following the SS offset.

Load .A with $10 (the SS offset.) and JSR to SETPNT ($D4C8) to set. the pointer

to the new SS block.

JSR to WRTAB ($DE50) to write out. the new side sector block to disk.

JSR to WATJOB ($D59 9) to wait for the

write job to be completed.

Note: Finished creating new block. Now,

revise old SS to reflect the new.

354

-----------------------------------------------------Page 354-----------------------------------------------------
﻿
NAME

NS20

NS40

NS50

ADDRESS

$E4AC

$E4AE

$E4B1

$E4B4

$E4B6

$E4B8

$E4BE

$E4C3

$E4CA

$E4CE

$E4D1

$E4D4

$E4D6

$E4DB

$E4DE $E4E2

$E4E4

$E4E8 $E4E9

$E4ED

$E4F0

DESCRIPTION OF WHAT ROM ROUTINE DOES

Load .X with the channel number from

LINDX ($82) .

Load .A with the side sector buffer

number from SS,X ($CD,X) and save this

number onto the stack.

JSR to GAFLGS ($DF9E) to get active buffer number and set flags.

Load .X with the new channel number from

LINDX ($82) .

Store the side sector buffer number from

.A into SS,X ($CD,X). Note: this swaps

the active buffer and the SS buffer. Pull the old side sector buffer number

off the stack, load .X with the last buffer used from LBUSED ($0257) , and store the old SS buffer # (in .A) into BUF0,X ($A7,X).

Zero .A and JSR to SETPNT ($D4C8) to set. the buffer pointer to the start of the

buffer.

Zero .Y and set the track link to point. to the new SS block using the value from TRACK ($80). Increment .Y.

Set the sector link to point to the new SS block using the value from SECTOR

($81).

JMP to NS50 ($E4DE).

JSR to GETACT ($DF93) to get the active buffer number (returned in .A).

Load .X with the channel number from

LINDX ($82).

JSR to IBRD ($DF1B) to read the next. SS. buffer number (returned in .A).

Zero .A and JSR to SETPNT ($D4C8) to set

the buffer pointer to the start of the

buffer.

Decrement the pointer in R4 ($8A) twice. Load .Y with the pointer into the buffer from R3 ($89) .

Load .A with the new SS track pointer

from Rl ($87) and store this value into the data buffer at (DIRBUF),Y.

Increment. .Y.

Load .A with the new SS sector pointer from R2 ($88) and store this value into the data buffer at (DIRBUF),Y.

JSR to WRTOUT ($DE5E) to write out the revised side sector block.

JSR to WATJOB ($D599) to wait for the

write job to be completed.

355

-----------------------------------------------------Page 355-----------------------------------------------------
﻿
NAME

ADDRESS
 DESCRIPTION OF WHAT ROM ROUTINE DOES

$E4F3 Load .Y with the pointer from $R4 ($8A)

and compare it to $03. If .Y>$03, there are more side sectors to update so

branch back to NS40.

$E4F9 Terminate routine with a JMP to DBLBUF

($CF1E) to reset the active buffer.

ERROR MESSAGE TABLE $E4FC - $E5D4

Each entry consists of the applicable error numbers followed by the message test with the first and last characters OR'ed with $80. The key words in the text are tokenized (values $80 - $8F). The tokenized word

list follows the main error message table.

Address

$E4FC $E500 $E50B $E517 $E522

Error numbers

$00

$20,$21,$22,$23,$24,$27 $52 $50 $51

Error Message

OK

READ ERROR

FILE TOO LARGE

RECORD NOT PRESENT OVERFLOW IN RECORD

$E52F
 $25
 ,$28

WRITE ERROR

$E533 $E540 $E546 $E552 $E556 $E55F $E567 $E570 $E589 $E58D $E592 $E59F $E5AA $E5AF $E5B6 $E5C8
 $26 $29

$30, ,$31,$32,$33,$34

i

$63 $64 $65

$66, ,$67 $61 $39 $01 $70 $71 $72 $73 $74

WRITE PROTECT ON DISK ID MISMATCH SYNTAX ERROR

WRITE FILE OPEN FILE EXISTS

FILE TYPE MISMATCH NO BLOCK

ILLEGAL TRACK OR SECTOR FILE NOT OPEN FILE NOT FOUND FILES SCRATCHED NO CHANNEL DIR ERROR DISK FULL

CBM DOS V2.6 4030 DRIVE NOT READY

TABLE OF TOKENIZED WORDS $E5D5 - $E609

$E5D5 $E5DB $E5E1 $E5E6
 $09 $0A $03 $04

ERROR WRITE FILE OPEN

$E5F4 $E5F8 $E5FE $E603

$06 $07 $08 $0B

NOT

FOUND DISK

RECORD

$E5EB
 $05

MISMATCH

356

$60

-----------------------------------------------------Page 356-----------------------------------------------------
﻿
NAME

ERROR

ERR1 ERR2

ERR3

ERR4

CMDER2

CMDER3

ADDRESS

$E60A $E60B $E60D

$E610

$E618

$E619

$E61D

$E621

$E625 $E627

$E62D $E62E

$E635 $E63A

$E63E

$E641

$E644 $E645

$E648

$E64B

$E650

$E653

$E656

$E65A

DESCRIPTION OF WHAT ROM ROUTINE DOES

Handle errors reported by controller: On entry: .A = error code number

.X = job number

Save the error code onto the stack.

Store the job number into JOBNUM ($F9). Transfer job number (from .X) to .A,

multiply it by 2 (ASL), and transfer the

result back into .X.

Set TRACK ($80) and SECTOR ($81) using

the values from the last header read in

HDRS,X ($06,X) and HDRS + 1,X ($07,X).

Pull the disk controller error code off the stack and convert it into a DOS

error code by:

AND the error code in .A with $0F. If the result is $00, branch to ERR1 to handle error codes $10 - $14.

Compare the result to $0F (no drive). If the code is NOT $0F, branch to ERR2. Load .A with $74 (DOS no drive code)

and branch to ERR3 (always).

Load .A with $06.

OR the code in .A with $20 and subtract

2 from the result.

Save the DOS error code onto the stack.

Compare the command number from CMDNUM ($022A) with $00 to see if this was a VALIDATE command. If not, branch to ERR4 Set. CMDNUM ($022A) to $FF.

Pull the DOS error code off the stack

and JSR to ERRMSG ($E6C7) to transfer the error message to the error buffer. JSR to INITDR ($D042) to initialize the drive and eliminate the bad BAM in RAM.

JMP to CMDER3 ($E648) to complete the error handling.

Pull the DOS error code off the stack. "

JSR to ERRMSG ($E6C7) to transfer the the error message to the error buffer. JSR to CLRCB ($C1BD) to clear out the

command buffer.

Clear the write-BAM flag, WBAM ($02F9) so a bad copy of the BAM will not be

written to disk.

JSR to ERRON ($C12C) to start the error LED flashing.

JSR to FREICH ($D4DA) to free the

internal read or write channel.

Zero BUFTAB+CBPTR ($A3) to clear the pointers.

Load .X with $45 (#TOPWRT) and transfer this value to the STACK POINTER to purge

the stack

357

-----------------------------------------------------Page 357-----------------------------------------------------
﻿
NAME

TLKERR

LSNERR

TLERR

ERR10

HEXDEC

HEXO

HEX5

ADDRESS

$E65D

$E663

$E667

$E668

$E66C

$E670

$E672

$E679

$E680

$E683

$E688

$E68B

$E68E

$E698

$E69B $E69C $E69F

$E6A3

$E6AA

DESCRIPTION OF WHAT ROM ROUTINE DOES

Load .A with the original secondary address from ORGSA ($84), AND it with $0F, and store the result as the current. secondary address in SA ($83).

Compare the secondary address (in .A) with $0F. If it. is $0F (the command channel), branch to ERR10.

Set the interrupt flag to prevent any interrupts!

If the listener active flag in LSNACT ($79) is not $00, we are an active

listener so branch to LSNERR.

If the talker active flag in TLKACT ($7A) is not. $00, we are an active

talker so branch to TLKERR.

Load .X with the current secondary address from SA ($83) .

Load .A with the active channel number

from LINTAB,X ($022B,X). If this channel number is $FF, the channel is inactive

so branch to ERR10.

AND the channel number (in .A) with $0F,

store it as the current channel number

in LINDX ($82) and JMP to TLERR ($E68E).

Talker error recovery:

Release all bus lines and go idle.

JSR to FNDRCH ($D0EB) to find an unused

read channel.

JSR to ITERR ($EA4E) to release all bus lines and JMP to IDLE ($EBE7).

Listener error recovery:

Release all bus lines and go idle.

JSR to FNDRCH ($D0EB) to find an unused

read channel.

JSR to ITERR ($EA4E) to release all bus lines and JMP to IDLE ($EBE7).

Unused on the 1541

Terminate routine with a JMP to IDLE

($EBE7).

Convert hex to BCD:

On entry: .A contains hex number

On exit: .A contains BCD number Transfer hex from .A to .X.

Zero .A and set decimal mode (SED). Compare .X value to $00. If egual,

branch to HEX5 to exit.

Clear carry flag, add 1 to value in .A, decrement .X, and JMP back to HEXO. Clear decimal mode (CLD).

358

-----------------------------------------------------Page 358-----------------------------------------------------
﻿
NAME

BCDDEC

BCD2

OKERR

ERRTSO ERRMSG

ADDRESS

$E6AB $E6AC $E6B0

$E6B3 $E6B4

$E6BA $E6BB

$E6BC

$E6BF $E6C1 $E6C7 $E6C9

$E6D1

$E6D4

$E6D8 $E6D9

$E6DF

DESCRIPTION OF WHAT ROM ROUTINE DOES

Convert BCD to ASCII decimal digit.

On exit: .X contains BCD number

(CB+2)Y contains ASCII

Transfer BCD from .A to .X.

Divide BCD value in .X by 16 (4 x LSR) JSR to BCD2 ($E6B4) to convert the most significant digit to ASCII.

Transfer original BCD byte from .X to .A AND the BCD value in .A with $0F to mask off the higher order nybble, OR the

result with $30 (convert to ASCII), and store the ASCII value in (CB+2)Y; ($A5)Y

Increment .Y

Terminate routine with an RTS.

Transfer error message to error buffer: JSR to ERROFF ($C123) to turn off error

LED.

Load .A with $00 (no error).

Set TRACK ($80) and SECTOR ($81) to $00. Load .Y with $00.

Set. pointer at CB+2/3 ($A5/6) to point

to the error buffer ($02D5).

JSR to BCDDEC ($E6AB) to convert the BCD number in .A to ASCII and store it at the start, of the error buffer.

Store $2C "," after the error code in the error buffer (CB+2),Y; ($A5),Y.

Increment .Y (points into error buffer). Copy the first, character of the error buffer from ERRBUF ($02D5) into the

channel data area CHNDAT+ERRCHN ($0243). Transfer the error number from .X to .A and JSR to ERMOVE ($E706) to move the error message into the error buffer.

$E6E3

Store $2C "," after the error message the error buffer (CB+2),Y; ($A5),Y.

in

$E6E7 $E6E8

Increment .Y (points into error buffer)

Load .A with the track number from

TRACK

580) .

$E6EA

$E6ED

$E6F1 $E6F2

$E6F4

JSR to BCDDEC ($E6AB) to convert the

track number in .A to ASCII and store it in the error buffer.

Store $2C "," after the track number in

the error buffer (CB+2),Y; ($A5),Y.

Increment .Y (points into error buffer).

Load .A with the sector number from SECTOR ($81) .

JSR to BCDDEC ($E6AB) to convert the sector number in .A to ASCII and store it in the error buffer.

359

-----------------------------------------------------Page 359-----------------------------------------------------
﻿
NAME

ERMOVE

E10

E20

E30

E40

ADDRESS

$E6F7

$E6FF

$E701

$E705

$E706

$E707

$E70D

$E715 $E716 $E718

$E71C $E71D

$E720

$E722

$E725

$E727

$E72F

$E735

DESCRIPTION OF WHAT ROM ROUTINE DOES

Decrement, the .Y pointer by 1, transfer the result to .A, clear the carry flag, add $D5 (the start of the error buffer), and store the final result (points to the last, character) into LSTCHR+ERRCHN

($0249).

Increment- the lo byte of the pointer in CB+2 ($A5) by 1 so it points to the second character of the message (we put.

the first character into the channel

data area already.

Set error channel status CHNRDY+ERRCHN

($F7) to $88 to indicate that it. is

ready-to-talk.

Terminate routine with an RTS.

Move the error message from the error

table to the error buffer. The tokens in the table are converted to words.

Transfer the error message number from

.A to .X.

Save the current, values of R0 ($86) and R0+1 ($87) onto the stack so we can use this as a temporary pointer.

Set up a pointer in R0/R0+1 to point to the error message table in ROM ($E4FC).

Transfer the error number back into .A.

Zero .X to use as an indirect pointer. Compare the error number (in .A) with the error number in the table (R0,X) ($86,X). If a match is found, branch

to E5 0.

Save error number onto the stack.

JSR to EADV2 ($E775) to advance the pointer to the error table.

If carry flag is clear, there are more messages to check so branch to E30

No more messages so JSR to EADV2 ($E775) to advance the pointer.

If carry flag is clear, we are not done with the message yet so branch to E20. Compare the hi byte of the pointer in R0+1 ($87) to $E6. If the pointer is less than $E6, there is more table left so branch to E40. If the pointer is

greater than $E6, we are past the end of

the table so branch to E45.

The hi bytes match so compare the lo bytes of the pointer in R0 ($86) with $0A (the end of the table). If we are past the end, branch to E4 5.

Pull the error number off the stack and

JMP to E10 to continue checking.

360

-----------------------------------------------------Page 360-----------------------------------------------------
﻿
NAME

E45

E50

E55

E90

E60

E70

EADV1

EA10

ADDRESS

$E739

$E73D

$E740

$E742

$E745 $E748

$E74A

$E74D

$E753

$E754

$E758 $E759

$E75D $E75E $E75F

$E762

$E763

$E765 $E766

$E767

$E76B

$E76D

$E76F

$E770

DESCRIPTION OF WHAT ROM ROUTINE DOES

Can't find error number in table so

pop the error number off the stack and JMP to E90 ($E74D) to quit.

The error number has been located so

JSR to EADV1 ($E76 7) to advance past.

the other error numbers.

If carry flag is clear, we have not advanced far enough so branch to E50. JSR to E60 ($E754) to check for token and put character(s) into buffer.

JSR to EADV1 ($E767) to advance pointer. If carry flag is clear, there is more to

do so branch back to E5 5.

JSR to E60 ($E754) to check for token

or last word.

All done! Pull original RO and RO+1 values off the stack and replace them.

Terminate routine with an RTS.

Sub to check for token or word and put

it into the buffer.

Compare the character in .A with $20 (the maximum token number +1). If .A is greater, this is not a token so branch

to E70.

Save token (in .A) into .X.

Store $20 (implied leading space) into the buffer at (CB+2),Y; ($A5),Y.

Increment. .Y.

Move the token from .X back into .A.

JSR to ERMOVE ($E70 6) to add the token word to the message.

Terminate routine with an RTS.

Store character (in .A) into the buffer at (CB+2),Y; ($A5),Y.

Increment .Y pointer into error buffer.

Terminate routine with an RTS.

Sub: Advance error pointer before move: Increment the lo byte of the pointer in RO ($86). If the new value is not $00,

branch to EA10.

Increment the hi byte of the pointer in RO+1 ($87).

Load .A with the next character from

the error message table (R0,X); ($A1,X). Shift the byte in .A left to set the carry flag if this is the first or last character in the message.

Load .A with the next character from

the error message table (R0,X); ($A1,X)

361

-----------------------------------------------------Page 361-----------------------------------------------------
﻿
NAME

EADV2

EA20

ADDRESS

$E772

$E774

$E775

$E778

$E77C

$E77E

DESCRIPTION OF WHAT ROM ROUTINE DOES

AND the character in .A with $7F to mask off bit 7.

Terminate routine with an RTS.

Sub: Advance error pointer after move: JSR to EA10 ($E76D) to get the next byte from the error message table.

Increment, the lo byte of the pointer in RO ($86). If the new value is not $00,

branch to EA20.

Increment the hi byte of the pointer in RO+1 ($87).

Terminate routine with an RTS.

UTILITY LOADER PROGRAM

This utility is used to load and execute user programs or system utilities from disk.

This utility may be used in two ways: a) On power-up:

If the data and clock lines are grounded at power up, the routine is entered. It waits until the ground clip

is removed and then loads the first file found in the

directory into disk RAM using the first two bytes of the file as the load address. Once the file is loaded, it is executed starting at the first byte.

b) Normal entry:

The disk command "&:filename" will load and execute

the file whose filename is specified. For example:

PRINT#15,"&0:DISK TASK"

File structure:

The utility or program must be of the following form. File type: USR

Bytes 1/2: Load address in disk RAM (lo/hi). Byte 3: Lo byte of the length of the routine Bytes 4/N: Disk routine machine code.

Byte N+l: Checksum. Note that the checksum includes

all bytes including the load address.

formula: CHECKSUM = CHECKSUM + BYTE + CARRY

NOTE: Routines may be longer than 256 bytes. However,

there MUST be a valid checksum byte after the number of bytes specified in byte #3 and after each subsequent 256 bytes!

B00T2 | $E77F | Exit routine with an RTS.

BOOT

$E780

$E784

Load .A with input port data from PB ($1800). Transfer data from .A to .X. AND the data byte (in .A) with $04 to see if clock is grounded. If not, branch

to EOOT2 to exit.

362

-----------------------------------------------------Page 362-----------------------------------------------------
﻿
NAME

BOOT3

ADDRESS

$E788 $E789

$E78D

$E78F

$E791

$E795

$E798

$E79B

$E7A0

DESCRIPTION OF WHAT ROM ROUTINE DOES

Transfer data byte from .X to .A.

AND the data byte (in .A) with $01 to see if data line is grounded. If not,

branch to BOOT2 to exit.

Clear interrupt flag so that background

routines will run.

BOOT CLIP MUST BE ON!

Load .A with input port data from PB

($1800) .

AND the data byte (in .A) with $05 to see if clip has been removed. If not,

branch to BOOT3 to wait until it is.

Set. the number of files to $01 by incrementing F2CNT ($0278) .

Set. the command string length to $01 by incrementing CMDSIZ ($0274).

Set. the first character in the command

buffer, CMDBUF ($0200), to $2A ("*") to match any file name.

JMP to BOOT4 ($E7A8) to continue.

POINT

NORMAL ENTRY

UTLODR

BOOT4

$E7A3

$E7A8

$E7AB

$E7AF $E7B4 $E7B8

$E7BB

$E7C0

Load .A with

($C268) to pa

JSR to KILLP

Does nothing

Load .A with

($0278) and s

Set. file coun

Set first-byt

JSR to LOOKUP name on the d Check the tra in FILTRK ($0

file was not. Load .A with

FOUND error a

$8D and JSR to PARSE

rse the command string. ($F258) to kill protect.

on the 15 41!

the file count, from F2CNT ave it on the stack.

t in F2CNT ($0278) to $01.

e flag in R0 ($86) to $FF. ($C44F) to locate the file

isk.

ck link for the file found

280). If it is $00, the

found so branch to UTLDOO.

$39 to indicate a FILE NOT nd JSR to CMDERR ($C1C8) to

exit.

UTLDOO

UTLD10

$E7C5

$E7C9

$E7CE

$E7D3

$E7D8

$E7DC

$E7DF

Pull original

and restore i Set. TRACK ($8 for the file Set SECTOR ($ for the file Load .A with

JSR to OPNTYP Load .A with to initialize JSR to GTABYT

byte from the

Store the lo

file count off the stack

t into F2CNT ($0278) . 0) from the track link from FILTRK ($0280) .

81) from the sector link from FILSEC ($0285) .

$03 (USER FILE TYPE) and ($D477) to open the file. $00 and store it in Rl($87;

the checksum.

($E839) to get the first file (lo of load address). byte of the load address

in R2 ($88).

363

-----------------------------------------------------Page 363-----------------------------------------------------
﻿
NAME

ADDRESS
 DESCRIPTION OF WHAT ROM ROUTINE DOES

$E7E1

$E7E4

$E7E7

$E7E9

$E7EC

$E7F0

$E7F3

$E7F6

JSR to ADDSUM ($E84B)

into the checksum.

JSR to GTABYT ($E839) byte from the file (h Store the hi byte of in R3 ($89) .

JSR to ADDSUM ($E84B)

into the checksum.

Load .A with the flag the flag is $00, this

address so branch to

Load lo byte of load ($88) and save it ont Load hi byte of load ($89) and save it. ont

Set first-byte flag i

to add the byte

to get. the second i of load address).

the load address

to add the byte

from RO ($86). If

is not the load

UTLD20.

address from R2 o the stack.

address from R3 o the stack.

n RO ($86) to $00.

UTLD20

$E7FA

$E7FD $E7FF

JSR to GTABYT ($E839) to get the data byte count from the file.

Store the data byte count, in R4 ($8A) . JSR to ADDSUM ($E84B) to add the byte

into the checksum.

UTLD30

UTLD35

$E802

$E805

$E809

$E80C

$E813

$E817

JSR to GTABYT from the file. Zero .Y and st at desired add JSR to ADDSUM into the check

Increment the

R2 ($88) by $0 $00, branch to

Increment the

R3 ($89) by $0

Decrement- the If the result

bytes to get s

($E839) to get a data byte

ore the data byte (in .A) ress, (R2),Y; ($88),Y. ($E84B) to add the byte

sum.

lo byte of the pointer in

1. If the result is not

UTLD3 5.

hi byte of the pointer in

1.

byte counter in R4 ($8A).

is not $00, there are more

o branch back to UTLD3 0.

UTLD50

$E81B

$E81E

$E824

$E827

$E82C

JSR to GIBYTE

from the file Load .A with

and compare i sum in Rl ($8

OK so branch Bad checksum set TRACK and Load .A with error and JSR Load .A with ($F8). If the not done yet

($CA3 5) to get a

without an EOI c the checksum from

t with the comput 7) . If they match

to UTLD50.

so JSR to GETHDR SECTOR from the

$50 to indicate a to CMDER2 ($E645 the EOI flag from flag is NOT $00,

so branch back to

data byte

heck.

DATA($85)

ed check-

, all is

($DE3E) to

header.

NO RECORD

) •

EIOFLG

we are

UTLD10

to do another

364

256 bytes.

-----------------------------------------------------Page 364-----------------------------------------------------
﻿
NAME

GTABYT

GTABYE

ADDSUM

ADDRESS

$E830

$E839

$E83C

$E840

$E843

$E848 $E84A

$E84B $E84C

$E850 $E852

DESCRIPTION OF WHAT ROM ROUTINE DOES

Routine all loaded so pull load address off the stack (lo/hi), set. up a jump vector in R2/3 ($88/9), and do an indirect. JMP to the routine via (R2).

Subroutines for UTLODR

Get a byte from the file opened using

the internal read channel. There is an

end-of-file check done. If EOI occurs,

a #51 DOS error is reported.

JSR to GIBYTE ($CA3 5) to fetch a byte and store it in DATA ($85) .

Test the end of information flag, EOIFLG ($F8). If NOT $00, we have not. come to

the end so branch to GTABYE.

We have an EOI condition. JSR to GETHDR

($DE3E) to set. TRACK and SECTOR from

the header.

Load .A with $51 to indicate a RECORD SIZE error and JSR to CMDER2 ($E645).

Load .A with the byte from DATA ($85)

Terminate routine with an RTS.

Compute the running checksum in Rl: On entry: .A = new byte to add Clear the carry flag.

Add the byte in Rl ($87) to the byte in

• A and then add $00 to the result, to

add in the carry bit.

Store the new checksum into Rl. Terminate routine with an RTS.

SERIAL BUS COMMUNICATION ROUTINES

ENTRY POINT FOR IRQ ROUTINE TO SERVICE ATTENTION (ATN) SIGNALS FROM THE C-64.

ATNIRQ

ATNSRV

$E853

$E856

$E85A

$E85B

$E85C

$E860

Load .A with the contents of PA1 ($1801; to clear the interrupt (IRQ) flag (CA1). Store $01 in ATNPND ($7C) to indicate that an ATN request, is pending.

Terminate routine with an RTS.

Service the attention request from the

C-64.

Set the interrupt, flag (SEI) to prevent any interrupts.

Store $00 in ATNPND ($7C) to indicate

that no ATN request, is pending.

Zero the listener and talker active

flags LSNACT ($79) and TLKACT ($7A).

365

-----------------------------------------------------Page 365-----------------------------------------------------
﻿
NAME

ATNS15

ATN3 5

ATN40

ADDRESS

$E864

$E867

$E86B

$E86D

$E870

$E873

$E87B

$E880

$E884

$E887

$E88B

$E891

$E895

$E89B

DESCRIPTION OF WHAT ROM ROUTINE DOES

Load .X with $45 and transfer this value

to the stack pointer to reset the stack. Store $80 in the EOI flag, EOIFLG ($F8)

to indicate a non-EOI state.

Store $80 in the ATN mode flag, ATNMOD ($7D) to set ATN mode for ACPT routine JSR to CLKHI ($E9B7) to wait for the clock line go high.

JSR to DATLOW ($E9A5) to set the data line low as a response.

To get hardware control of the data line acknowledge the attention signal by: loading .A with the contents of port B, PB ($1800), OR the byte with $10 to set

the ACK ATN bit, and store the result. back into port B, PB ($1800).

Check to see if the ATN signal is still present by: loading .A with the contents of port B, PB ($1800) . If bit 7 is not. set, the ATN signal is gone so branch to ATNS20 ($E8D7).

AND the contents of .A with $04 to see

if the clock line is still low. If bit

2 is set (result of AND is not. $00) , the

clock line is still low so branch back to ATNS15 to wait.

Clock line went high so there is a command byte waiting for us.

JSR to ACPTR ($E9C9) to get the command byte.

Compare the command byte (in .A) with $3F (unlisten). If this is not an unlisten command, branch to ATN35.

General unlisten command received.

Zero the listener active flag, LSNACT ($7A) and branch to ATN122 ($E902).

Compare the command byte (in .A) with $5F (untalk). If this is not an untalk command, branch to ATN40.

General untalk command received.

Zero the talker active flag, TLKACT ($7A) and branch to ATN122 ($E902).

Compare the command byte (in .A) with our talk address in TLKADR ($78) . If this is not our talk address, branch to

ATN4 5.

366

-----------------------------------------------------Page 366-----------------------------------------------------
﻿
NAME

ATN 4 5

ATN50

ATN95

ADDRESS

$E89F

$E8A9

$E8AD

$E8B7

$E8B8

$E8BE

$E8BF

$E8C1

$E8C5

$E8CD

$E8CE

$E8D1

$E8D2

DESCRIPTION OF WHAT ROM ROUTINE DOES

Talk command for us.

Set. the talker active flag, TLKACT ($7A) to $01, the listener active flag, LSNACT

($79) to $00, and branch to ATN95.

Compare the command byte (in .A) with

our listen address in LSNADR ($77). If this is not. our listen address, branch

to ATN50.

Listen command for us.

Set the listener active flag, LSNACT ($79) to $01, the talker active flag, TLKACT ($7A) to $00, and branch to ATN95

Save the command byte by transferring it

from .A to .X.

Test if the command byte is a secondary address by AND' ing it. with $60. If the result is not $60, this is not a

secondary address so branch to ATN120.

NCTE: SA = $60 + N

A secondary address for the drive.

Transfer the original command byte from

.X back into .A.

Store the original secondary address byte into ORGSA ($84) .

ANC the secondary address (in .A) with $0F to strip off any junk and store the result as the current secondary address in SA ($83) .

Test if this is a CLOSE command for this

secondary address.

Load .A with the original secondary

address from ORGSA ($84). AND this value with $F0 to mask off the low nybble. If the result, is not. $E0, this is not a

CLOSE command so branch to ATN122.

CLOSE the file with this SA.

Clear the interrupt flag (CLI) to enable interrupts.

JSR to CLOSE ($DAC0) to close the file.

WARNING: CLOSE routine does not. return

in time to be handled by ATN122

Set the interrupt flag (SEI) to prevent any interrupts.

Test, if the ATN signal is still present. If it is, branch back to ATN3 0.

367

-----------------------------------------------------Page 367-----------------------------------------------------
﻿
NAME

ADDRESS

DESCRIPTION OF WHAT ROM ROUTINE DOES

SIGNAL GONE - CARRY OUT COMMAND
 ATN

ATSN20

$E8D7

$E8DB

$E8E3

Store atten

Re lea

byte

it wi resul

Test.

($79)

liste ATN10

$00 in ATNMOD ($7D) to clear the

tion mode.

se the ATN ACK line by loading the from port. B, PB ($1800), AND'ing th $EF ($FF-ATNA), and storing the t back into port B ($1800) .

the listener active flag, LSNACT to se if we are supposed to be a ner. If flag is $00, branch to

0.

BE AN ACTIVE

TALKER.

$E8E7

$E8EA

JSR t seria JMP t

o

1

o

DATHI ($E99C)

bus .

IDLE ($EBE7).

to free data

line.

ATN100

ATN110

ATN120

ATN12 2

TALK

TALK1

NOTLK

TLK05

$E8ED

$E8F1 $E8F4 $E8F7 $E8FA

$E8FD

$E902

$E909

$E90A

$E90F

$E911

$E905

$E906

Test the talker active flag, TLKACT($7A) to see if we are supposed to talk. If flag is $00, branch to ATN110.

BE AN ACTIVE TALKER.

JSR to DATHI ($E99C) to free data line. JSR to CLKLOW ($E9AE) to pull clock low. JSR to TALK ($E909) to talk on the bus. JMP to ILERR ($EA4E) to release all the

lines and shift to idle mode.

FIX SO DEVICE NOT PRESENT IS REPORTED

Store $10 in PB ($1800) to kill all the

lines except. ATN ACK (ATN ACKnowledge) . Test if ATN signal is still present (bit. 7 of PB set). If gone, branch to ATNS20. If still present, loop to ATN122.

SERIAL BUS TALK ROUTINES

Set. the interrupt flag (SEI) to prevent. any interrupts.

JSR to FNDRCH ($D0EB) to find an unused

read channel. If no channel is available branch to NOTLK to exit.

Load .X with the current, channel number

from LINDX ($82) .

Load .A with the channel status from

CHNRDY,X ($F2,X). If bit 7 is set, the

status is OK so branch to TLK05.

Terminate routine with an RTS.

NOTE: CODE ADDED TO FIX VERIFY ERROR

JSR to TSTATN ($EA59) to test for an ATN signal.

368

-----------------------------------------------------Page 368-----------------------------------------------------
﻿
NAME

TALK2

TLK02

TLK03

NOEOI

ADDRESS

$E909

$E91C

$E91F

$E922

$E925

$E928

$E92B

$E92F

$E931

$E937

$E93A

$E93D

$E941

$E944

$E947

$E94B

$E94E

$E951

$E954

DESCRIPTION OF WHAT ROM ROUTINE DOES

JSR to DEBNC ($E9C0) to test if the

clock signal is gone. NOTE: this must be

80 microseconds or more from JMP TALK1.

AND the data byte in .A with $01 and

save it on the stack.

JSR to CLKHI ($E9B7) to set the clock line high.

Pull the test byte off the stack. If it- is $00, this is a VERIFY ERROR so branch

to TLK02 to send an EOI.

JSR to TSTATN ($EA59) to test for an ATN signal.

JSR to DEBNC ($E9C0) to test if the

data line has been set. low.

AND the test byte (in .A) with $01. If the result is not $00, the line has not been set hi (no response) so branch back to TALK2 to wait for response.

Load .X with the current channel number

from LINDX ($82) .

Load .A with the channel status from

CHNRDY,X ($F2,X), and AND it. with $08 to

test if we have an EOI condition. If the result is not $00, we do not have an EOI so branch to NOEOI ($E94B). Send an EOI signal to the C-64 by:

JSR to TSTATN ($EA59) to test for an

ATN signal.

JSR to DEBNC ($E9C0) to send an EOI and

test if the data line has been set.

AND the test byte (in .A) with $01. If the result is not $00, the line has not. been set hi (no response) so branch back to TLK02 to wait, for hi response. JSR to TSTATN ($EA59) to test, for an ATN signal.

JSR to DEBNC ($E9C0) to test if the

data line has been set.

AND the test byte (in .A) with $01. If the result equals $00, the line has not. been set lo (no response) so branch back to TLK02 to wait, for lo response.

JSR to CLKLOW ($E9AE) to set the clock

line low.

JSR to TSTATN ($EA59) to test, for an ATN signal.

JSR to DEBNC ($E9C0) to test, if the

data line has been set.

AND the test byte (in .A) with $01. If the result is not $00, the line has not been set. hi (no response) so branch back to NOEOI to wait for hi response.

369

-----------------------------------------------------Page 369-----------------------------------------------------
﻿
NAME

ISR01

ISR02

ISRHI

ISRCLK

ISR03

ISR04

ADDRESS

$E958

$E95C

$E95F

$E963

$E965

$E96C

$E96E $E971

$E973

$E976

$E979

$E97B

$E980

$E983

$E987

$E98A

$E991

$E992

$E995

$E996

DESCRIPTION OF WHAT ROM ROUTINE DOES

Store $08 in CONT ($98) to set up the

bit counter.

JSR to DEBNC ($E9C0) to let. the port

settle.

AND the test byte (in .A) with $01 to

be sure the line is hi before we send.

If the result is not $00, the line has not been set hi (no response) so branch to FRMFRX ($E999) to wait, for hi response

Load .X with the current channel number

from LINDX ($82).

Load .A with the channel data byte from CHNDAT,X ($F2,X). Rotate the status byte one bit. right (ROR) and store the result. back into CHNDAT,X ($F2,X).

If the carry bit. is set, branch to ISRHI

to send a 1.

JSR to DATLOW ($E9A5) to send a 0. Branch to ISRCLK to clock it.

JSR to DATHI ($E99C) to send a 1.

JSR to CLKHI ($E9B7) to set. the clock

line hi. (rising edge).

Load .A with the speed flag from

DRVTRK+1 ($23). If the flag is not $00, no slow down is required so branch to

ISR03.

JSR to SLOWD ($FEF3) to slow down the data transmission.

JSR to CLKDAT ($FEFB) to pull the clock

low and release the data.

Decrement the bit count in CONT ($98). If the count is not $00, there are more bits to send from this byte so branch

back to ISR01.

JSR to DEBNC ($E9C0) to test if the

data line has been set.

AND the test byte (in .A) with $01. If the result equals $00, the line has not been set. lo (no response) so branch back to ISR04 to wait, for lo response. Clear the interrupt flag (CLI) to allow interrupts in preparation for sending the next byte.

JSR to GET ($D3AA) to get the next data byte to send.

Set. the interrupt flag (SEI) to prevent. any interrupts.

JMP to TALK1 to keep on talking.

370

-----------------------------------------------------Page 370-----------------------------------------------------
﻿
NAME

ADDRESS
 DESCRIPTION OF WHAT ROM ROUTINE DOES

TALK SUBROUTINES

:

FRMERX

$E999

JMP to FRMERR ($EA4E) to

lines and

go to idle mode

Set data

out line high.

release all

•

DATHI

$E99C

Load .A with the byte from port B, PB

$E9A4

($1800) ,

and store Terminate

Set data

AND it with $FD

the result back routine with an

out line lo.

($FF-DATOUT), in PB ($1800) .

RTS.

DATLOW

$E9A5

Load .A with the byte from port B, PB

($1800) ,

OR it with $0 2 (DATOUT), and

$E9AD

store the Terminate

Set clock

result, back in routine with an

line lo.

PB ($1800).

RTS.

CLKLOW

$E9AE

Load .A with the byte from port B, PB

($1800),

OR it with $08 (CLKOUT), and

$E9B6

store the Terminate

Set clock

result back in routine with an

line hi.

PB ($1800).

RTS.

CLKHI

$E9B7

Load .A with the byte from port B, PB

$E9BF

($1800),

and store Terminate

Wait for

AND it with $F7

the result back routine with an

response on bus.

($FF-CLKOUT), in PB ($1800).

RTS.

DEBNC

$E9C0

Load .A with the byte from port B, PB

($1800) .

with the

Compare the old

current value of

port value (.A)

PB ($1800). If

there is

no change, branch to DEBNC.

$E9C8

Terminate
 routine with an

RTS.

ACPTR

ACP00A

ACP00

$E9C9

$E9CD

$E9D0

$E9D3

$E9D7

$E9DA

$E9DF

SERIAL BUS LISTEN ROUTINES

Store $08 in CONT ($98) to set. up the

bit counter.

JSR to TSTATN ($EA59) to test for an ATN signal.

JSR to DEBNC ($E9C0) to test if the

clock line has been set.

AND the test byte (in .A) with $04.

If the result is not $00, the line has not been set. hi (no response) so branch back to ACP00A to wait for hi response. JSR to DATHI ($E99C) to make data line high.

Store $01 in T1HC1 ($1805) to set up for a 255 microsecond delay.

JSR to TSTATN ($EA59) to test for an ATN signal.

371

-----------------------------------------------------Page 371-----------------------------------------------------
﻿
NAME

ADDRESS
 DESCRIPTION OF WHAT ROM ROUTINE DOES

$E9E2

$E9E9

$E9EC

Load .A with the int

from IFR1 ($180D) an with $40. If the res

time has run out so

Since it is an EOI, JSR to DEBNC ($E9C0) clock line has been

AND the test, byte (i If the result is $00 not been set lo (no back to ACP0 0 to wai If the result is not been set. lo so branc

errupt flag register d AND the test byte ult is NOT $00, the

it. MUST be an EOI. branch to ACPOOB.

to test if the

set.

n .A) with $04.

, the clock line has response) so branch t for lo response. $00, the line has

h to ACP01 to go on.

ACPOOB

ACP02A

$E9F2

$E9F5

$E9FA

$E9FD

$EA00

$EA03

$EA07

JSR to DATLOW ($E9A5)

low as a response.

Load .X with $0A, and down to $00 to delay

around time.

JSR to DATHI ($E99C) high.

JSR to TSTATN ($EA59) ATN signal.

JSR to DEBNC ($E9C0)

clock line has been s

AND the test byte (in If the result is $00, not been set lo (no r

back to ACP02A to wai

Store $00 in EOIFLG (

that an EOI has been

to set. data line

loop to count .X

for talker turn

to make data 1ine

to test for an

to test if the et.

.A) with $04.

the clock line has

esponse) so branch t for lo response.

$F8) to indicate received.

ACP01 ACP03

ACP03A

$EA0B

$EA15

$EA18

$EA1A

$EA1D

Load .A with the data byte from port B, PB ($1800) , EOR it. with $01 to find the complement of the data bit, shift, the data bit into the carry flag (LSR). AND

the result, in .A with $02 to test if the clock line has been set high to indicate valid data. If the result is NOT $00, the clock line has not been set. hi yet so branch back to ACP03 and try again. Three $EA (NOP) bytes to fill space left by speed-up to fix VC20 901229-02

ROM's.

We have valid data bit in the carry so do a rotate right (ROR) on DATA ($85) to

store the bit. into the data byte.

JSR to TSTATN ($EA59) to test for an

ATN signal.

JSR to DEBNC ($E9C0) to test if the clock line has been set.

372

-----------------------------------------------------Page 372-----------------------------------------------------
﻿
NAME

LISTEN

LSN15

LSN30

FRMERR ITERR ILERR

ATNLOW

TSTATN

ADDRESS

$EA20

$EA24

$EA28

$EA2B

$EA2D

$EA2E

$EA2F

$EA34

$EA36

$EA39

$EA41

$EA44 $EA47

$EA48

$EA4B

$EA4E

$EA56

$EA59

DESCRIPTION OF WHAT ROM ROUTINE DOES

AND the test byte (in .A) with $04.

If the result is $00, the clock line has not. been set lo (no response) so branch back to ACP03A to wait for lo response. Decrement the bit counter in CONT ($98). If the count is not $00, there are more bits to get so branch back to ACP03. JSR to DATLOW ($E9A5) to set. data line low as a response.

Load .A with the data byte from DATA

($85) .

Terminate routine with an RTS.

MAIN LISTEN ROUTINE

Set interrupt mask (SEI) to prevent any interrupts.

JSR to FNDWCH ($D107) to find an unused write channel. If none available, branch

to LSN15.

Load .A with the write channel status

from CHNRDY,X ($F2,X).

Rotate the status byte right (ROR). If the carry bit is set, the write channel

is inactive so branch to LSN30.

Test if this is an OPEN command by: loading .A with the original secondary address from ORGSA ($84) and AND'ing it with $F0. If the result, is $F0, it is

an OPEN command so branch to LSN3 0. Not an active channel so JMP to ILERR

($EA4E) to abort.

JSR to ACPTR ($E9C9) to get a data byte. Clear interrupt mask (CLI) to allow interrupts.

JSR to PUT ($CFB7) to put the data byte into its proper place (DATA, EOI, SA). JMP to LISTEN ($EA2E) to keep on

listening.

Release all bus lines and go idle: Store $00 into port. B, PB ($1800) and JMP to IDLE ($EBE7).

LISTEN SUBROUTINES

JMP to ATNSRV ($E85B) to service ATN request.

Test if in ATN mode:

Load .A with the attention mode flag from ATNMOD ($7D). If $00, we are not

in attention mode so branch to TSTA5 0.

373

-----------------------------------------------------Page 373-----------------------------------------------------
﻿
NAME

TSTRTN

TSTA50

TATN20

PEZRO

PERR

PE20

PE30

REA7D PD10 PD20

ADDRESS

$EA5D

$EA62

$EA63

$EA6B

$EA6E $EA70

$EA71

$EA73

$EA74

$EA75

$EA7D $EA7E $EA7F

$EA83

$EA86

DESCRIPTION OF WHAT ROM ROUTINE DOES

We are in attention mode. Load .A with

the byte from port B, PB ($1800) . If bit 7 of this byte is clear, the ATN signal is gone so branch to TATN20 to

do what we were told.

The ATN signal hasn't gone away yet so

exit with an RTS.

We are not in attention mode now. Load

.A with the byte from port B, PB ($1800) If bit 7 of this byte is clear, there is no ATN signal present, so branch to

TSTRTN to exit.

If bit. 7 of this byte is set, there is an ATN signal present, so JMP to ATNSRV

($E85B) to service the ATN request.

JMP to ATNS20 ($E8D7) to carry out the

attention command.

FLASH LED TO SIGNAL ERROR

No-error status:

Load .X with $00.

.BYTE $2C skips next two bytes.

Error status:

Load .X with the error number from TEMP

($6F).

Transfer the error number from .X into

the stack pointer to use the stack as a storage register.

Transfer the value of the stack pointer

(the error number) into .X

Load .A with $08 (the LED mask), OR it with the data port controlling the LED's LEDPRT ($1C00). and JMP to PEA7A ($FEEA) to turn on LED. NOTE: this is a patch to be sure the data direction register for the LED line is set. to output. Transfer the byte in .Y to .A Clear the carry flag.

Add $01 to the contents of .A. If the result is not $00, branch to PD20.

Decrement .Y (the hi byte of the timer). If value of .Y is not $00, branch to

PD10.

Turn off LED(s).

Load .A with the byte from the data port controlling the LED, LEDPRT ($1C00). AND the byte with $F7 ($FF - LED mask) and store the result, back into LEDPRT ($1C00)

to turn OFF the LED.

374

-----------------------------------------------------Page 374-----------------------------------------------------
﻿
NAME

PE40 PD11 PD21

ADDRESS

$EA8E $EA8F $EA90

$EA94

$EA97

$EA9A

DESCRIPTION OF WHAT ROM ROUTINE DOES

Transfer the byte in .Y to .A Clear the carry flag.

Add $01 to the contents of .A.'if the

result is not $00, branch to PD21.

Decrement .Y (the hi byte of the timer).

If value of .Y is not $00, branch to

PD11.

Decrement the count in .X. If the result

is greater than or equal to $00, branch to PE30 to flash again.

Compare .X to $FC to see if we have

DSKINT

PV10

$EAA0

$EAA1 $EAA2

$EAA7

$EAAC $EAAD $EAAF

waited long enough between groups of flashes. If .X <> $FC branch to PE40 to wait some more. If .X = $FC, branch to PE20 to repeat the sequence.

INITIALIZATION OF DISK

Set. the interrupt flag (SEI) to prevent interrupts.

Clear the decimal mode flag (CLD).

Store $FF into the data direction

register DDRA1 ($1803) .

Load .X and .Y with $00.

Fill zero page with ascending pattern Transfer the byte from .X into .A. Store the byte from .A into $00,X.

Increment .X. If .X is not $00, branch

back to PV10.

Check zero page bits.

PV2 0

$EAB2

Transfer the byte from .X into

■ A.

$EAB3

Compare the byte in .A

with $00,X.

PV3 0

RM10

$EAB7 $EAB9

$EABC

$EAC0 $EAC2

$EAC6

$EAC9

If no match, branch to PEZRO ($EA6E). Increment the contents of $00,X by 1. Increment .Y. If .Y is not $00, branch

back to PV30.

Check if $00,X equals byte in .A. If no match, something is wrong so branch to PEZRO ($EA6E).

Store the $00 byte from .Y into $00,X. Check if $00,X equals $00. If it. does not, something is wrong so branch to PEZRO ($EA6E).

Increment the counter in .X. If the

result is not $00, we have more of zero page to check so branch back to PV2 0.

Test the two 64K bit ROM's.

Increment TEMP ($6F) to set the next error number ($01=$E/F;$02=$C/D ROM).

375

-----------------------------------------------------Page 375-----------------------------------------------------
﻿
NAME

RT10

RT20

CR20 CR30

RAMTST RA10

RA3 0

RA40

ADDRESS

$EACB

$EACF $EAD1 $EAD4 $EAD5

$EAD7

$EADC

$EADF $EAE1 $EAE2

$EAE6

$EAEA $EAEC

$EAEE

$EAF0 $EAF2 $EAF4

$EAF8

$EAFB

$EB00 $EB02

$EB04

$EB07

$EB0D

DESCRIPTION OF WHAT ROM ROUTINE DOES

Store .X value (page number) into IP+1 ($76) as the hi byte of the pointer.

Set lo byte of pointer, IP ($75) to $00. Set ,Y to $00 and .X to $20 (32 pages). Clear the carry flag.

Decrement, the hi byte of the pointer in IP+1 ($76) and we'll do it backwards. Add the ROM value from (IP),Y to the contents of .A, increment the Y pointer, and if .Y is not $00, branch back to RT20 to do another byte from this page. Decrement .X (page count). If the page count, is not. zero, branch to RT10 to do the next page of the ROM.

Add $00 to .A to add in the last, carry.

Transfer the checksum from .A to .X.

Compare the checksum in .A with the hi byte of the count in IP+1 ($76). If the bytes do not match, branch to PERR2 ($EB1F). $E/F ROM: checksum = $E0

$C/D ROM: checksum = $C0

Compare checksum in .X with $C0 to check if we are done. If not, branch to RM10.

Test the disk RAM.

Load .A with $01 (start of first block). Save contents of .A (page number) into IP+1 ($76) as hi byte of pointer.

Increment TEMP ($6F) to bump the error number ($03=RAM problem)

Load .X with $07 (number of RAM pages). Transfer .Y value to .A and clear carry. Add the hi byte of the pointer, IP+1 ($76) to the accumulator and store the

result in (IP,Y).

Increment .Y and if .Y is not $00, branch to RA10 to fill RAM page.

Increment, the hi byte of the pointer in IP+1 ($76) and decrement the page count in .X. If .X is not $00, we have more pages to do so branch back to RA10.

Load .X with $07 (number of RAM pages). Decrement, the hi byte of the pointer in IP+1 ($76). We'll check backwards.

Decrement .Y, transfer the .Y value into

.A and clear the carry.

Add the hi byte of the pointer, IP+1 ($76) to the accumulator and compare the result with (IP,Y). If they don't match, branch to PERR2 to report the error. EOR the contents of .A with $FF to flip

the bits and store the result into the RAM at (IP),Y.

376

-----------------------------------------------------Page 376-----------------------------------------------------
﻿
NAME

PERR2

DIAGOK

INTTAB INTT1

ADDRESS

$EB11

$EB17

$EB1A

$EB1D

$EB1F

$EB22

$EB25

$EB2D

$EB32

$EB3A

$EB43

$EB43

$EB4B $EB4F

$EB53

$EB59

$EB5F

DESCRIPTION OF WHAT ROM ROUTINE DOES

EOR the contents of .A with (IP),Y and store the result (should be $00) back into (IP),Y. If the result, is not $00, branch to PERR2 to report, the error.

Transfer the contents of .Y into .A. If

.Y is not $00, we have more to do on this page so branch back to RA40.

Decrement the page count, in .X. If there are more pages to do, branch to RA3 0.

Branch to DIAGOK.

JMP to PERR ($EA71) to report error.

Load .X with $45 and transfer this value to the stack pointer to reset the stack. Load .A with the byte from the LED control port, LEDPRT ($1C00), AND it with $F7 ($FF-LED mask) and store the

result back in LEDPRT to turn off LED.

Store $01 in PCR1 ($180C) to cause interrupt on the negative edge of ATN. Store $82 (10000010) in IFR1 ($180D) and IER1 ($180E).

COMPUTE DEVICE # FROM BITS 5/6 OF PORT B

Load .A with the data byte from Port B, PB ($1800). AND the byte with $6 0

(%01100000). Do one ASL and three ROL's to convert from bits 6/5 to bits 1/0. NOTE: 0XX00000 becomes 000000XX

OR .A with $48 (the talk address) and store the result in TLKADR ($78) .

EOR .A with $60 (the listen address) and store the result in LSNADR ($77).

Initialize buffer pointer table

Zero .X and .Y

Zero .A and store the $00 byte in .A in the buffer table at. BUFTAB,X ($99,X).

Increment .X and load .A with the hi

byte of the pointer to the buffer from BUFIND,Y ($FEE0) and store it into the buffer table at BUFTAB,X ($99,X).

Increment .X and .Y and compare the new value of .Y with $05 (the number of buffers). If there are more buffers to do, branch to INTT1.

Store the lo byte of the pointer to the command buffer ($00) into the buffer table at BUFTAB,X ($99,X). Increment .X.

377

-----------------------------------------------------Page 377-----------------------------------------------------
﻿
NAME

DSKIN1

DSKIN2

ADDRESS

$EB64

$EB69

$EB6E

$EB72

$EB76

$EB7C

$EB7E

$EB87

$EB8B

$EB8F $EB93 $EB95

$EB9A

$EB9F

$EBA4

$EBA8

$EBAC

$EBB6

$EBBC

$EBBF

$EBC2

$EBC5

$EBCD

$EBD1

DESCRIPTION OF WHAT ROM ROUTINE DOES

Store the hi byte of the pointer to the

command buffer ($02) into the buffer table at BUFTAB,X ($99,X). Increment .X. Store the lo byte of the pointer to the error buffer ($D5) into the buffer table table at BUFTAB,X ($99,X). Increment .X. Store the hi byte of the pointer to the error buffer ($02) into the buffer table table at BUFTAB,X ($99,X). Increment. .X.

Load .A with $FF (inactive SA) and .X with $12 (the maximum secondary address) Loop to set. all LINTAB,X ($022B,X) values to $FF to indicate inactive.

Load .X with $05 (the maximum number of channels - 1) .

Loop to set all BUF0,X ($A7,X), BUF1,X ($AE,X) and SS,X (CD,X) values to $FF to

indicate that, these buffers are unused.

Store $05 (the buffer count) into BUFO+CMDCHN ($AB)

Store $05 (the buffer count. + 1) into BUF0+ERRCHN ($AC)

Store $FF into BUF0+BLINDX ($AD) Store $FF into BUF1+BLINDX ($B4)

Store $05 (the error channel #) into LINTAB+ERRSA ($023B).

Store $84 ($80 + the command channel #) into LINTAB+CMDSA ($023A).

Store $0F (LINDX 0 to 5 free) into LINUSE ($0256) .

Store $01 (ready to listen) into CHNRDY+CMDCHN ($F6).

Store $01 (ready to talk) into CHNRDY+ERRCHN ($F7).

Store $E0 into BUFUSE ($024F) and $FF into BUFUSE+1 ($0250).

Store $01 into WPSW ($1C) and WPSW+1 ($1D) to set. up the write protect status JSR to USRINT ($CB63) to initialize the

user jump table.

JSR to LRUINT ($CEFA) to initialize the

least, recently used table.

JSR to CNTINT ($F259) to initialize the

disk controller.

Set up the indirect NMI vector at VNMI

($65/6) to point to the diagnostic

routine, DIAGOK ($EB22).

Store $0A into SECINC ($69) as the

normal next sector increment.

Store $05 into REVCNT ($6A) as the normal recovery counter.

378

-----------------------------------------------------Page 378-----------------------------------------------------
﻿
NAME

ADDRESS
 DESCRIPTION OF WHAT ROM ROUTINE DOES

SETERR

$EBD5

Load

.A with $73 and JSR to ERRTSO

($E6 3C1) to set up power-on error message

73 CBM DOS V2.6 1541 0 0

$EBDA

Load

.A with $1A (%00011010) and store

$EBDF

it i .n the data direction register DDRB1 ($18 i02). ATNA,CLKOUT,DATOUT are outputs. Stor :e $00 in data port B, PB ($1800) to

$EBE4

set JSR

DATA, CLOCK, & ATNA lines high. to BOOT ($E780) to see if we need

IDLE

IDL1

IDL01

IDL02

$EBE7

$EBE8

$EBF0

$EBF5

$EBFA

$EBFC

$EBFF

$EC00

$EC04

$EC07

$EC08

$EC0C $EC12

$EC14

to b >oot a systems routine.

IDLE LOOP. WAIT FOR SOMETHING TO DO.

Clear interrupt mask (CLI) to allow interrupts.

Release all the bus lines:

Load .A with the byte from port B, PB ($1800) , AND it. with $E5 to set CLOCK, DATA, and ATNA lines high, and store the result back in PB ($1800).

Check the value of CMDWAT ($0255) to see

if there is a command waiting. If it. is $00, there is none waiting so branch to

I DLL

Store $00 in CMDWAT ($0255) to clear the command waiting flag.

Store $00 in NMIFLG ($67) to clear the

debounce.

JSR to PARSXQ ($C146) to parse and then

execute the command.

Clear interrupt mask (CLI) to allow

interrupts.

Check the value of ATNPND ($0255) to see

if there is an attention pending. If it is $00, there is nothing pending (such as the drive running or an open file)

so branch to IDL01.

JMP to ATNSRV ($E85B) to service the attention request.

Clear interrupt mask (CLI) to allow interrupts.

Store $0E (#14), the maximum secondary address for files in TEMP+3 ($72) . Zero TEMP ($6F) and TEMP+1 ($70). Load .X with the secondary address counter from TEMP+3 ($72).

Load .A with the channel number for this

secondary address from LINTAB,X($022B,X) If it is $FF, there is no active file

for this SA so branch to IDL3.

379

-----------------------------------------------------Page 379-----------------------------------------------------
﻿
NAME

IDL3

IDL4

IDL5

IDL6

IDL7

ADDRESS

$EC1B

$EC1F

$EC22 $EC23

$EC29

$EC2B

$EC2F

$EC31

$EC36

$EC39

$EC3B

$EC3E

$EC3F

$EC45

$EC49 $EC4D

$EC51

$EC55 $EC58

$EC5C $EC5E

$EC62

DESCRIPTION OF WHAT ROM ROUTINE DOES

We've found an active file so AND the

channel number with $3F and store the

result as the current channel number in

LINDX ($82) .

JSR to GETACT ($DF93) to get the active buffer number (returned in .A).

Transfer the buffer number from .A to .X

Determine which drive is to be used by loading the old job number from LSTJOB,X

($025B,X) , AND'ing it with $01, and transferring the result into .X.

Increment the count, of the number of

active files on drive X in TEMP,X($6F,X) Decrement the SA count, in TEMP + 3 ($72) . If there are more secondary addresses left to check, branch back to IDL2.

Load .Y with $04 (the number of buffers less 1).

Load .A with the current job code for this buffer from the job queue, JOBS,Y ($00,Y). If bit 7 is not set, no job is

in progress so branch to IDL5.

There is a job in progress so AND the job code in .A with $01 to mask off the

non-drive bits and transfer the result. to .X.

Increment the count, of the number of

active files on drive X in TEMP,X($6F,X)

Decrement the buffer counter in .Y. If there are more buffers to check, branch

to IDL4.

Set the interrupt mask (SEI) to prevent interrupts while reading LEDPRT ($1C00). Load .A with the data byte from the port controlling the LED, AND the byte with $F7 ($FF - LED mask), and save the

result onto the stack.

Load .A with the current drive number

from DRVNUM ($7F) and save it. in R0($86) Zero DRVNUM ($7F).

Test, the active file count for drive 0 in TEMP ($6F). If $00, branch to IDL7. Load the write protect switch byte from WPSW ($1C). If it is $00 branch to IDL6. JSR to CLDCHN ($D313) to close all files Pull the LED data byte off the stack, OR it with $08 (LED mask) to turn on the LED since drive 0 is active, and save the byte back onto the stack.

Increment, the DRVNUM ($7F) . (to $01)

Test, the active file count, for drive 1

in TEMP+1 ($70). If $00, branch to IDL9. Load the write protect switch byte from

WPSW ($1C). If it is $00 branch to IDL8.

380

-----------------------------------------------------Page 380-----------------------------------------------------
﻿
NAME

IDL8

IDL9

IDL10

IDL11

IDL12

STDIR

ADDRESS

$EC66 $EC69

$EC6D

$EC71 $EC72

$EC77

$EC7A

$EC7E

$EC81

$EC86

$EC8B

$EC90

$EC93

$EC98

$EC9B

$EC9E

$ECA2

$ECA7

$ECAC

$ECAE

$ECB3

DESCRIPTION OF WHAT ROM ROUTINE DOES

JSR to CLDCHN ($D313) to close all files Pull the LED data byte off the stack,

OR it with $00 (LED mask) to turn on the LED since drive 1 is active, and save the byte back onto the stack.

Copy the original drive number from RO ($86) back into DRVNUM ($7F).

Pull the LED data byte off the stack.

Load .X with the error status from

ERWORD ($026C). If it is $00, the LED is not. flashing so branch to IDL12.

Error light is flashing:

Load .A with the LED data byte from LEDPRT ($1C00)

Compare the error status in .X with $80. If it is not $80, this is not the first

time we have seen this error so branch to IDL 10.

We have just encountered a new error

status so JMP to IDLll.

Load .X with the value of TIMER1 ($1805) If bit. 7 is set, we are still timing so

branch to IDL12.

Store $A0 into TIMER1 ($1805) to set the

timer to a new 8 millisecond cycle.

Decrement the count, of 8 millisecond

cycles in ERWORD ($026C). If the count is not $00 yet, branch to IDL12

Time is up. EOR the LED status in .A with the LED mask in ERLED ($026D) to toggle the LED.

Store $10 in ERWORD ($026C) to start a new timing cycle.

Store the current LED status (in .A) into the LED port, LEDPRT ($1C00).

JMP to IDL1 ($EBFF) the top of the loop.

Start loading the directory:

Set current secondary address, SA ($83) to $00.

Load .A with $01 and JSR to GETRCH ($D1E2) to allocate a channel and one

buffer.

Zero .A and JSR to SETPNT ($D4C8) to set. the buffer pointer to the start of

the buffer.

Load .X with the channel number from

LINDX ($82).

Store $00 as the last character for this channel in LSTCHR,X ($0244).

JSR to GETACT ($DF93) to get the active buffer number (returned in .A).

381

-----------------------------------------------------Page 381-----------------------------------------------------
﻿
NAME

DIR1

ADDRESS

$ECB6 $ECB7

$ECBC

$ECC1

$ECC6

$ECCE

$ECD4

$ECD9

$ECDC

$ECDF

$ECE1

$ECE5

$ECEA

$ECF2

$ECF7

$ECFD

$ED03

$ED06

DESCRIPTION OF WHAT ROM ROUTINE DOES

Transfer the buffer number into .X Load .A with the current drive number

from DRVNUM ($7F) and store this number

as the last job number for this buffer in LSTJOB,X ($025B).

Load .A with $01 and JSR to PUTBYT

($CFF1) to put. the lo byte of the load

address ($0401) into the buffer. Load .A with $04 and JSR to PUTBYT ($CFF1) to put the hi byte of the load

address ($0401) into the buffer. Load .A with $01 and JSR to PUTBYT

($CFF1) twice to put a phony program line link ($0101) into the buffer.

Load .A with the drive number for the

directory from NBTEMP ($0272) and JSR to PUTBYT ($CFF1) to put this to the buffer as the lo byte of the first line number. Load .A with $00 and JSR to PUTBYT

($CFF1) to store this as the hi byte of

the line number.

JSR to MOVBUF ($ED59) to move the disk

name into the buffer.

JSR to GETACT ($DF93) to get the active buffer number (returned in .A).

Multiply the buffer number by 2 (ASL)

and transfer it into .X.

Decrement the lo byte of the pointer in BUFTAB,X ($$99,X) twice.

Load .A with $00 and JSR to PUTBYT ($CFF1) to store this as the end of

program line null byte.

Load .A with $01 and JSR to PUTBYT

($CFF1) twice to put a phony program line link ($0101) into the buffer.

JSR to GETNAM ($C6CE) to get the buffer number and file name. If the carry flag is clear on return, this is the last entry so branch to DIR3.

Load .A with the lo byte of the block count, from NBTEMP ($0272) and JSR to PUTBYT ($CFF1) to put this to the buffer as the lo byte of the line number. Load .A with the hi byte of the block count from NBTEMP+1 ($0273) and JSR to PUTBYT ($CFF1) to put. this to the buffer as the hi byte of the line number.

JSR to MOVBUF ($ED59) to move the file

name and file type into the buffer.

Load .A with $00 and JSR to PUTBYT ($CFF1) to store this as the end of

program line null byte.

382

-----------------------------------------------------Page 382-----------------------------------------------------
﻿
NAME

DIR10

DIR3

ADDRESS

$ED0B

$ED0D

$ED10

$ED12

$ED16 $ED18

$ED1A

$ED1D

$ED20 $ED22

$ED23

$ED29

$ED2F

$ED32

$ED35

$ED37

$ED3B

$ED46

$ED49

$ED4B

$ED4E

$ED50

DESCRIPTION OF WHAT ROM ROUTINE DOES

If the Z flag is not set on return, the

buffer is not full so branch to DIR1 to

do the next, file entry.

JSR to GETACT ($DF93) to get. the active buffer number (returned in .A).

Multiply the buffer number by 2 (ASL)

and transfer it. into .X.

Store $00 as the lo byte of the pointer in BUFTAB,X ($$99,X).

Load .A with $88 (ready-to-talk).

Load .Y with the channel number from

LINDX ($82) .

Store $88 (in .A) into the directory list flag DIRLST ($0254) to indicate that the directory list is full.

Store $88 (in .A) as the channel status in CHNRDY,Y ($00F2,Y).

Load .A with the byte from DATA ($85).

Terminate routine with an RTS.

End directory loading:

Load .A with the lo byte of the block count from NBTEMP ($0272) and JSR to

PUTBYT ($CFF1) to put this to the buffer as the lo byte of the line number. Load .A with the hi byte of the block count from NBTEMP+1 ($0273) and JSR to

PUTBYT ($CFF1) to put this to the buffer as the hi byte of the line number.

JSR to MOVBUF ($ED59) to move the file

name and file type into the buffer.

JSR to GETACT ($DF93) to get the active buffer number (returned in .A).

Multiply the buffer number by 2 (ASL)

and transfer it into .X.

Decrement, the lo byte of the pointer in BUFTAB,X ($$99,X) twice.

Load .A with $00 and JSR to PUTBYT ($CFF1) three times to store the three null bytes at the end of a program.

JSR to GETACT ($DF93) to get the active buffer number (returned in .A).

Multiply the buffer number by 2 (ASL)

and transfer it. into .Y.

Load .A with the lo byte of the pointer into the buffer from BUFTAB,Y ($0099,Y).

Load .Y with the channel number from

LINDX ($82) .

Store the lo byte of the pointer (in .A) into the lo byte of the pointer to the

last non-zero character in the buffer

LSTCHR,X ($0244,X).

-----------------------------------------------------Page 383-----------------------------------------------------
﻿
NAME

MOVBUF MOVB1

GETDIR

GETD3

GDI

ADDRESS

$ED53

$ED56

$ED59 $ED5B

$ED61

$ED66

$ED67

$ED6A

$ED6C

$ED6D $ED6F

$ED71

$ED74

$ED76

$ED7B $ED7D

$ED7E $ED7F

$ED82 $ED83

DESCRIPTION OF WHAT ROM ROUTINE DOES

Decrement the pointer in LSTCHR,X

($0244,X) by 1 so it does actually point

to the last character in the buffer.

JMP to DIR10 ($ED0D) to set the channel status and flags and exit.

Transfer file name to listing buffer

Zero .Y

Load .A with the character from NAMBUF,Y ($02B1,Y) and JSR to PUTBYT ($CFF1) to

store it in the listing buffer.

Increment. .Y. If .Y is not $1B (#27) yet, branch to MOVB1.

Terminate routine with an RTS.

Get character for directory load

JSR to GETBYT ($D137) to get a byte from

the data buffer (loads next block if

necessary).

On return, if the Z flag is set, we are

at. the end-of-file so branch to GETD3. Terminate routine with an RTS.

Store the byte (in .A) into DATA ($85) .

Load .Y with the channel number from LINDX ($82) .

Load .A with the lo byte of the pointer into the directory buffer from LSTCHR,Y

($0244,Y)

If the lo byte of the pointer is $00, we

have exhausted the current buffer so branch to GDI.

We must, be at the end-of-file so load

.A with $80 (EOI) and store it as the channel status in CHNRDY,Y ($00F2,Y). Load .A with the byte from DATA ($85).

Terminate routine with an RTS.

Save the null byte in .A onto the stack. JSR to DIR1 ($ECEA) to create pseudo program listing in the listing buffer. Pull the null data byte off the stack.

Terminate routine with an RTS.

VALDAT

VALIDATE (COLLECT) DISK COMMAND

Create a new BAM to match the sectors

used by the current directory entries.

VERDIR

$ED84

$ED87

$ED8A

JSR to SIMPRS ($C1D1) to parse the

command string and extract the drive #. JSR to INITDR ($D042) to initialize the drive specified.

Store $40 in WBAM ($02F9) to mark BAM as dirty (needs to be written out).

384

-----------------------------------------------------Page 384-----------------------------------------------------
﻿
NAME

VD10

ADDRESS

$ED8F

$ED92

$ED9A

$ED9C $EDA0

$EDA5

$EDA8

$EDAD

$EDB0

DESCRIPTION OF WHAT ROM ROUTINE DOES

JSR to NEWMAP ($EEB7) to build a new blank BAM in RAM.

Store $00 in DELIND ($0292) to force

a search for a valid directory entry

and JSR to SRCHST ($C5AC) to search the

directory for the first valid entry. If an entry is found (Z flag not set), branch to VD25 to process it.

No more entries so finish up. Set SECTOR ($81) to $00.

Set. TRACK ($80) with the value $12 (#18) from DIRTRK ($FE85) .

JSR to VMKBAM ($EDE5) to trace through the directory sectors and mark those in

use in the BAM.

Store $00 in WBAM ($02F9) to mark BAM as clean (BAM in RAM matches BAM on disk). JSR to SCRBAM ($EEFF) to write BAM out.

to disk.

Terminate command with a JMP to ENDCMD

($C194) .

Process directory entry

for BAM

VD15

$EDB3 $EDB4

$EDB7

Increment .Y (points to

Load the track link for

(DIRBUF),Y; ($94),Y and

the stack.

Increment .Y (points to

entry in buffer) the entry from

save it onto

entrv in buffer)

VD17

$EDB8

$EDBB

$EDBD

$EDC1 $EDC3 $EDC4

$EDC8

$EDCB

$EDCE

$EDD1

Load the sector link for the entry from (DIRBUF),Y; ($94),Y and save it onto

the stack.

Load .Y with $13 so it. points to the side sector track link of the entry. Load the SS track link for the entry from (DIRBUF),Y; ($94),Y. If the SS

track link is $00, this isn't a relative

file so branch to VD17.

Store the SS track link in TRACK ($80) . Increment .Y (points to entry in buffer) Load the SS sector link for the entry from (DIRBUF) ,Y; ($94) ,Y. Store the SS sector link in SECTOR ($81).

JSR to VMKBAM ($EDE5) to trace through

the SS file and mark the sectors used in the BAM.

Pull the main file's sector link off the

stack and store it in SECTOR ($81) .

Pull the main file's track link off the stack and store it in TRACK ($80) .

JSR to VMKBAM ($EDE5) to trace through

the main file and mark the sectors used in the BAM.

385

-----------------------------------------------------Page 385-----------------------------------------------------
﻿
NAME

VD20

VD25

VMKBAM

MRK2

MRK1

ADDRESS

$EDD4

$EDD7

$EDD9

$EDDB

$EDDF

$EDE2

$EDE5

$EDE8

$EDEB

$EDEE

$EDF3

$EDF8

$EDFD

$EE01

$EE04

$EE07

$EE0A

DESCRIPTION OF WHAT ROM ROUTINE DOES

JSR to SRRE ($C604) to search for the

next valid directory entry.

If another entry is not. found (Z flag is set) branch to VD10 to finish up.

Check if entry found is properly closed Zero .Y so it points to the first.

character in the entry, the file type. Load .A with the file type byte from (DIRBUF),Y; ($99),Y. If bit 7 is set, the file has been properly closed so branch to VD15 to process it.

File was not properly closed so JSR to DELDIR ($C8B6) to delete it from the directory.

JMP to VD20 ($EDD4) to find next entry.

Trace file by links and mark BAM

JSR to TSCHK ($D55F) to check that the TRACK and SECTOR values are legal.

JSR to WUSED ($EF90) to mark the sector pointed to by TRACK and SECTOR as IN USE

in the BAM.

JSR to OPNIRD ($D475) to open the

internal read channel and read in the first one or two file blocks.

Load .A with $00 and JSR to SETPNT

($D4C8) to set. the pointers to the first.

byte in the buffer (the track link). JSR to GETBYT ($D137) to read the track link (in .A) . Store it into TRACK ($80) . JSR to GETBYT ($D137) to read the sector link (in .A). Store it into SECTOR ($81)

Load .A with the track link from TRACK

($80). If it is not $00, branch to MRK1. Track link is $00. This must, be the last

block in the file so JMP to FRECHN

($D227) to free the channel and return. JSR to WUSED ($EF90) to mark the sector pointed to by TRACK and SECTOR as IN USE

in the BAM.

JSR to NXTBUF ($D44D) to read in the

next block of the file.

JMP to MRK2 ($EDEE) to do next block.

NEW (FORMAT) DISK COMMAND

A full, or long NEW marks off the tracks and sectors on a diskette, writes null data blocks in all sectors, and creates a new BAM and directory on track 18.

A short NEW merely creates a new BAM and directory on track 18.

386

-----------------------------------------------------Page 386-----------------------------------------------------
﻿
NAME

NEW

N101

N108

ADDRESS

$EE0D

$EE10

$EE14

$EE19

$EE1D

$EE20

$EE24

$EE27

$EE2C

$EE36

$EE39

$EE3D

$EE40 $EE43

$EE46 $EE49

$EE4B

DESCRIPTION OF WHAT ROM ROUTINE DOES

JSR to ONEDRV ($C312) to set up drive and table pointers.

Load the number of the drive that was

set up from FILDRV ($E2). If bit 7 is not set, a legal drive number was

specified so branch to N101 to continue.

Load .A with $33 to indicate a BAD DRIVE NUMBER and JMP to CMDERR ($C1C8).

AND the drive number (in .A) with $01 to

mask off the non drive bits and store the result as the current drive in

DRVNUM ($7F).

JSR to SETLDS ($C100) to turn on the

drive active LED.

Load .A with the drive number from

DRVNUM ($7F), multiply it by 2 (ASL),

and transfer it into .X.

Load .Y with the pointer to the start

of the new disk ID in the command buffer

from FILTBL+1 ($027B).

Compare the ID pointer in .Y with the length of the command string in CMDSIZ ($0274). If these values are equal,

there is no new disk ID. Therefore this must be a short new so branch to N108.

Transfer new disk ID from the command

buffer CMDBUF,Y ($0200,Y) and CMDBUF+1,Y

($0201,Y) to the master disk ID area DSKID,X ($12,X) and DSKID+1,X ($13,X).

JSR to CLRCHN ($D307) to clear all channels while formatting.

Store $01 into TRACK ($80) as first

track to do.

JSR to FORMAT ($C8C6) to set up JMP command in buffer that points to the formatting routine to be used by the

disk controller.

JSR to CLRBAM ($F005) to clear the BAM. JMP to N110 ($EE56) to continue.

Clear directory only.

JSR to INITDR ($D042) to init. the drive

Load .X with the drive number from

DRVNUM ($7F).

Load .A with the DOS version number

as given in the BAM, DSKVER,X ($0101,X) and compare it. with the 1541 DOS version number ($41) from VERNUM ($FED5). If the version numbers match, branch to N110.

387

-----------------------------------------------------Page 387-----------------------------------------------------
﻿
NAME

N110

ADDRESS

$EE53

$EE56

$EE59

$EE5C

$EE5E

$EE63

$EE6B $EE6D

$EE75

$EE78

$EE7D

$EE83

$EE87 $EE88

$EE8D

$EE91

$EE96

$EE99 $EE9D

$EEA0

$EEA3

DESCRIPTION OF WHAT ROM ROUTINE DOES

DOS versions do not match so JMP to

VNERR ($D572) to abort.

JSR to NEWMAP ($EEB7) to create a new

BAM.

Load .A with the current job code from JOBNUM ($F9) and transfer it to .Y.

Multiply the job code in .A by 2 (ASL)

and transfer the result, to .X.

Load .A with $90, the offset of the disk name in the BAM from DSKNAM ($FE88) and

store this pointer in BUFTAB,X ($99,X).

Load .X with the buffer number from

FILTBL ($027A), load .Y with $27 (the name length) and JSR to TRNAME ($C66E)

to transfer the new disk name from the command buffer into the BAM area.

Load .Y with $12 (position of disk ID).

Load .X with the drive number from

DRVNUM ($7F) and copy the DOS version number ($41) from VERNUM ($FED5) into DSKVER,X ($0101,X).

Transfer the drive number from .X to .A, multiply it by 2 (ASL), and transfer the

result back into .X.

Transfer the first disk ID character

from DSKID,X ($12,X) into (DIRBUF),Y

($94) ,Y. Increment. .Y.

Transfer the second disk ID character

from DSKID+1,X ($13,X) into (DIRBUF),Y

($94) ,Y. Increment. .Y twice.

Store the directory DOS version ($32;

ASCII 2) into (DIRBUF),Y; ($94),Y.

Increment .Y.

Transfer the format type ($41; ASCII A) from VERNUM ($FED5) into (DIRBUF),Y

($94),Y.

Load .Y with $02 so it. points to the third byte in the BAM and store the format type ($41; in .A) into the BAM at (BMPNT),Y; ($6D),Y.

Transfer the directory track number, $12 from DIRTRK ($FE85) into TRACK ($80) . JSR to USEDTS ($EF93) to mark track 18

sector 0 as used in the BAM.

Set SECTOR ($81) to $01.

JSR to USEDTS ($EF93) to mark track 18 sector 1 as used in the BAM.

JSR to SCRBAM ($EEFF) to write out the

new BAM to disk.

JSR to CLRBAM ($F005) to set all of BAM area to $0 0.

388

-----------------------------------------------------Page 388-----------------------------------------------------
﻿
NAME

NEWMPV NEWMAP

NM10

NM20

NM3 0

ADDRESS

$EEA6

$EEAC

$EEAF

$EEB4

$EEB7

$EEBA

$EEC4 $EEC7

$EECF

$EED2

$EED7

$EED9

$EEE0

$EEE3

$EEED

DESCRIPTION OF WHAT ROM ROUTINE DOES

Load .Y with $01 and store $FF as the first directory block's sector link in

(BMPNT),Y; ($6D),Y.

JSR to DRTWRT ($D464) to write out the new directory block to disk.

Decrement, the sector number (from $01 to $00) in SECTOR ($81) and JSR to DRTRD ($D460) to read the BAM back into RAM. Terminate command with a JMP to ENDCMD

($C194).

Create a new BAM map:

JSR to CLNBAM ($F0D1) to set. entire BAM area to $00's.

Using .Y as a pointer, store $12 (#18)

and $01 as the track and sector link in (BMPNT),Y; ($6D),Y; as the first two

bytes of the new BAM.

Increment. .Y until it is $04.

Zero the area to be used to manipulate the BAM map bits, TO ($6F), Tl ($70),

and T2 ($71) .

Transfer the byte from .Y into .A and divide it. by 4 (2 * LSR) to find the

track number.

JSR to MAXSEC ($F24B) to calculate the

maximum sector number for this track and store this value as the number of

sectors free on this track in (BMPNT),Y

($6D),Y.

Increment .Y. Transfer the maximum sector number from .A into .X.

Set the carry flag (this 1 bit will indicate that this sector is free) and rotate this bit from the carry into the bit map area (TO/1/2) using ROL TO,

ROL Tl, and ROL T2.

T2 ($71) Tl ($70) TO ($6F) C

before 00000000 11111111 11111111 1 after 0000000K-1111111K-1111111K-0 Decrement the sector count in .X. If the

resulting .X value is not $00, there are

more to do so branch back to NM20.

Transfer the bit map for this track from T0,X ($6F,X) to the BAM area (BMPNT),Y; ($6D,Y). Increment .Y and .X. If the new .X value is not. $03, we have more

to transfer so branch back to NM30.

Compare the .Y value to $90. If it is less than $90, we have more tracks to

do so branch back to NM10.

-----------------------------------------------------Page 389-----------------------------------------------------
﻿
NAME

MAPOUT

SCRBAM

SB10

SB20

ADDRESS

$EEF1

$EEF4

$EEF7 $EEF8

$EEFF

$EF01

$EF06

$EF07

$EF0C

$EF0F

$EF13

$EF16

$EF1D

$EF20 $EF24

$EF28

DESCRIPTION OF WHAT ROM ROUTINE DOES

JMP to NFCALC ($D075) to calculate the

number of blocks free.

Write out. BAM to the drive specified in

LSTJOB.

JSR to GETACT ($DF93) to find the active buffer number (returned in .A).

Transfer the buffer number to .X.

Load .A with the job code for the last. job from LSTJOB,X ($025B,X), AND it with $01 to mask off the non-drive bits, and store the result, in DRVNUM ($7F) .

Write out BAM to the drive specified in

DRVNUM.

Load .Y with the drive number from

DRVNUM ($7F).

Load .A with the BAM-dirty flag from MDIRTY,Y ($0251,Y). If the flag is not $00, the BAM is dirty (the copy in RAM does NOT match the copy on disk) so

branch to SB10 to write it out to disk. BAM is clean so there is no reason to write it out. Terminate routine with

an RTS.

Zero the BAM-dirty flag in MDIRTY,Y

($0251,Y).

JSR to SETBPT ($EF3A) to set up the pointer to the BAM.

Load .A with the drive number from

DRVNUM ($7F), multiply it by 2 (ASL),

and save the result, onto the stack.

JSR to PUTBAM ($F0A5) to put the memory images to the BAM.

Pull the (drive number x 2) off the

stack, clear the carry flag, add $01, and JSR to PUTBAM ($F0A5) to put. the memory images to the BAM.

Verify that the block count for the

track matches the bit map for the track. Load .A from TRACK ($80) and push the

track number onto the stack.

Load .A with $01 and store it. in TRACK.

Multiply the track number in .A by 4 (2 x ASL) and store the result as the lo byte of the buffer pointer in BMPNT

($6D).

JSR to AVCK ($F220) to check that the blocks free for the track agrees with the bit. map.

390

-----------------------------------------------------Page 390-----------------------------------------------------
﻿
NAME

ADDRESS

$EF2B

$EF34

$EF37

DESCRIPTION OF WHAT ROM ROUTINE DOES

Increment the track count, in TRACK ($80;

If the new count is less than the

the maximum track number (#36), branch

back to SB20 to check the next track.

Pull the original track number off the stack and restore it. into TRACK ($80) . JMP to DOWRIT ($D58A) to write out the

BAM to disk.

Read in the BAM, if not a

lready in RAM,

and set the pointers to t

he BAM

SETBPT

$EF3A

$EF3E

$EF41

$EF43

$EF48

$EF4C

JSR to BAM2A ($F10F) to g channel number in .A (drO the channel number into .

JSR to REDBAM ($F0DF) to if not already in memory.

Load .X with the buffer n

the read from JOBNUM ($F9 Set the hi byte of the po BAM in BMPNT+1 ($6E) usin pointer value for the buf BUFIND,X ($FEE0,X).

Set the lo byte of the po BAM in BMPNT ($6D) to $00

Terminate routine with an

et the BAM

= 6). Transfer

X.

read in the BAM

umber used for ) .

inter to the

g the hi byte

fer from

inter to the

RTS.

NUMFRE

WFREE

FRETS

FRETS2

$EF4D

$EF4F

$EF55

$EF5B

$EF5C

$EF5F

$EF62

$EF63

Get the number of blocks free on the

drive specified in DRVNUM:

Load .X with the drive number from

DRVNUM ($7F).

Transfer the lo byte of the number of blocks free from NDBL,X ($02FA,X) into NBTEMP ($0272).

Transfer the hi byte of the number of blocks free from NDBH,X ($02FC,X) into NBTEMP+1 ($0273) .

Terminate routine with an RTS.

Free the block specified in TRACK and

SECTOR as free in the BAM:

JSR to FIXBAM ($EFF1) to write out the

BAM the value in WBAM indicates that it is needed.

JSR to FREUSE ($EFCF) to calculate the index to the BAM entry that, contains

the desired TRACK and SECTOR. On return

.Y points to the entry and .X points to

the bit within the entry.

Set the carry flag (the flag for no action required).

If Z flag is NOT set, the desired TRACK and SECTOR is already free in the BAM

so branch to FRERTS to exit.

391

-----------------------------------------------------Page 391-----------------------------------------------------
﻿
NAME

FRERTS

DTYBAM

ADDRESS

$EF65

$ED6C

$ED6F

$EF72

$EF78

$EF7F

$EF84

$EF87

$EF88

$EF8A

$EF8F

DESCRIPTION OF WHAT ROM ROUTINE DOES

Load .A with BAM entry from (BMPNT),Y ($6D),Y, OR it with the bit map mask

from BMASK,X ($EFE9,X) to turn on (free) the bit that corresponds to the desired block, and store the result back into

(BMPNT),Y; ($6D),Y.

JSR to DTYBAM ($EF88) to set the dirty BAM flag (BAM in RAM and BAM on disk

do not. match) .

Load .Y with the pointer to the number

of blocks free for the track from TEMP

($6F) and clear the carry flag.

Load .A with the blocks free for the

track from (BMPNT),Y; ($6D),Y, add 1, and store the result back into (BMPNT),Y Load .A with the TRACK ($80) number of the block we just freed. If it. is on the directory track (#18) , branch to USE10

($EFBA).

Increment the lo byte of the count of

the total number of blocks free on the

disk, NDBL,X ($02FA,X) by 1. If the result, is NOT $00, branch to FRERTS Increment the hi byte of the count of

the total number of blocks free on the

disk, NDBH,X ($02FC,X) by 1.

Terminate routine with an RTS.

Set dirty-BAM flag:

Indicates that the copy of the BAM in disk RAM does not. match the disk copy.

Load .X with the current, drive number

from DRVNUM ($7F).

Store a $01 into the dirty BAM flag in

MDIRTY,X ($0251) .

Terminate routine with an RTS.

Mark the block specifi
 ed in TRACK and

SECTOR as USED in the

BAM:

WUSED

$EF90

JSR to FIXBAM ($EFF1)

BAM the value in WBAM

to write out the indicates that it

is needed.

USEDTS

$EF93

$EF96

JSR to FREUSE ($EFCF) index to the BAM entry

the desired TRACK and

•Y points to the entry

the bit. within the ent

If Z flag is set, the SECTOR is already mark

BAM so branch to USERT

to calculate the

that contains

SECTOR. On return

and .X points to

ry.

desired TRACK and ed as USED in the S to exit.

392

-----------------------------------------------------Page 392-----------------------------------------------------
﻿
NAME

USE10

USE20

USERTS

FREUSE

FREUS2

ADDRESS

$EF98

$ED9F

$EDA2

$EFA4

$EFAB

$EFB2

$EFB7

$EFBA

$EFBD

$EFC2

$EFC9

$EFCE

$EFCF

$EFD2 $EFD3

DESCRIPTION OF WHAT ROM ROUTINE DOES

Load .A with BAM entry from (BMPNT),Y ($6D),Y, EOR it with the bit map mask from BMASK,X ($EFE9,X) to zero (in use) the bit that corresponds to the desired block, and store the result back into

(BMPNT),Y; ($6D),Y.

JSR to DTYBAM ($EF88) to set the dirty BAM flag (BAM in RAM and BAM on disk do not match).

Load .Y with the pointer to the number

of blocks free for the track from TEMP

($6F).

Load .A with the blocks free for the

track from (BMPNT),Y; ($6D),Y, set the carry flag, subtract $01, and store the result, back into (BMPNT) ,Y.

Load .A with the TRACK ($80) number of the block we just freed. If it is on the directory track (#18) , branch to USE20

($EFBD).

Load .A with the lo byte of the count of

the total number of blocks free on the

disk, NDBL,X ($02FA,X). If the lo byte is NOT $00, branch to USE10.

Decrement the hi byte of the count of

the total number of blocks free on the

disk, NDBH,X ($02FC,X) by 1.

Decrement the lo byte of the count of

the total number of blocks free on the

disk, NDBL,X ($02FA,X) by 1.

Load .A with the hi byte of the count of

the total number of blocks free on the

disk, NDBH,X ($02FC,X). If the hi byte is NOT $00, branch to USERTS.

Load .A with the lo byte of the count of

the total number of blocks free on the

disk, NDBL,X ($02FA,X). If the lo byte is greater than 2, branch to USERTS.

Load .A with $72 to indicate a DISK FULL error and JSR to ERRMSG ($E6C7).

Terminate routine with an RTS.

Calculate index into the BAM for FRETS and USEDTS.

On exit: Z flag = 1 if used in BAM

Z flag = 0 if free in BAM

JSR to SETBAM ($F011) to set BAM image in memory. On return .Y contains a

pointer to the start of the bit map for

the desired track.

Transfer the pointer from .Y to .A. Store the pointer from .A into TEMP

($6F).

393

-----------------------------------------------------Page 393-----------------------------------------------------
﻿
NAME

FREUS3

BMASK

FIXBAM

FBAM10

CLRBAM

CLB1

ADDRESS

$EFD5

$EFDA

$EFDE

$EFE3

$EFE8

$EFE9 $EFEA $EFEB $EFEC $EFED $EFEE $EFEF $EFF0

$EFF1

$EFF6

$EFF8

$EFFA

$EFFC

$FC04

$F005

$F008 $F00B

$F010

DESCRIPTION OF WHAT ROM ROUTINE DOES

Load .A with the desired sector number

from SECTOR ($81) and do three LSR's to divide the sector number by 8 to find out which of the three bytes for this

track the sector is in.

Set the carry flag, add the pointer to the start of the track from TEMP ($6F) to the sector index (0/1/2) in .A, and

transfer the result, to .Y.

Load .A with the desired sector number

from SECTOR ($81), AND the sector number with $07 to find the bit. position that corresponds to that sector, and transfer

the result into .X.

Load .A with the BAM byte that contains

the bit for the desired block from

(BMPNT),Y; ($6D),Y, and AND it with the bit map for the appropriate bit from BMASK,X ($EFE9,X) to set the Z flag.

Terminate routine with an RTS.

$EFE9-EFF0

Bit mask table .BYTE $01 1 .BYTE $02 2 .BYTE $04 4 .BYTE $08 8 .BYTE $10 16 .BYTE $20 32 •BYTE $40 64 .BYTE $80 128

Write out BAM to disk if value in WBAM

indicates that it is necessary.

Load .A with $FF and BIT this value with the value in WBAM ($02F9).

If Z flag set (WBAM was $00) branch to

FBAM10 to exit.

If N flag clear (bit 7 of WBAM was 0)

branch to FBAM10 to exit.

If V flag set. (bit 6 of WBAM was 0)

branch to FBAM10 to exit.

Set WBAM ($02F9) to $00 and JSR to DOWRIT ($D58A) to write BAM to disk.

Terminate routine with an RTS.

Zero the BAM area:

JSR to SETBPT ($EF3A) to set. the pointers to the BAM.

Zero .Y and .A.

Loop, using .Y as an index, to store $00's in all 256 locations in the BAM

buffer.

Terminate routine with an RTS.

394

-----------------------------------------------------Page 394-----------------------------------------------------
﻿
NAME

SETBAM

SBM10

SBM30

ADDRESS

$F011

$F017

$F019

$F022

$F025

$F027

$F02E

$F033

$F036

$F03B

$F03E

$F040

$F042

$F045

DESCRIPTION OF WHAT ROM ROUTINE DOES

Set BAM image in memory:

Save the values of TO ($6F) and Tl ($70)

onto the stack so we can use this as a work area.

Load .X with the current drive number

from DRVNUM ($7F). Load .A with the

drive status for this drive from NODRV,X ($FF,X). If the drive status is $00, we have a functioning drive so branch to

SBM10 to continue.

Load .A with $74 to indicate a DRIVE NOT READY error and JSR to CMDER3 ($E648).

JSR to BAM2A ($F10F) to load .A with the channel number and .X with the drive #. Transfer the channel number (in .A) into TO ($6F).

Transfer the drive number from .X into

.A, multiply it by 2 (ASL), store the

result, in Tl ($70) and in .X.

Load .A with the current track number

from TRACK ($80) and compare it with the track value given in the BAM track table, TBAM,X ($029D,X). If the values match, the BAM is in the correct, area of memory so branch to SBM30.

Increment .X by 1 and store the result in Tl ($70). Note that .X now points to

the alternate BAM channel.

Compare the current- track value (in .A)

with the contents of the BAM track table

TBAM,X ($029D,X) for the alternate BAM location. If the value match, the BAM is in an appropriate location so branch

to SBM3 0.

JSR to SWAP ($F05B) to read in the BAM if necessary and move it. to the correct

area of the disk RAM.

Load .A with the BAM channel number from

Tl ($70).

Load .X with the current, drive number

from DRVNUM ($7F).

Store the channel number (in .A) into UBAM,X ($029B,X) to set the last channel used pointer.

Multiply the channel number (in .A) by four (2 x ASL), clear the carry, and add $A1, the lo byte of the pointer, to

the start of the BAM ($02A1). Store the result into the lo byte of the BAM pointer, BMPNT ($6D).

395

-----------------------------------------------------Page 395-----------------------------------------------------
﻿
NAME

SWAP

SWAP 3

ADDRESS

$F04C

$F052 $F054

$F05A

$F05B

$F060

$F063

$F070

$F074

$F07A

$F07F

$F084

$F088

$F08A

$F090

DESCRIPTION OF WHAT ROM ROUTINE DOES

Load .A with $02, the hi byte of the pointer to the start of the BAM, add $00 to add in the carry (if any) from the previous addition, and store the result. as the hi byte of the BAM pointer, BMPNT+1 ($6E).

Zero .Y.

Pull the original values of Tl ($70) and TO ($6F) off the stack and store them back in their original locations.

Terminate routine with an RTS.

Swap images of the BAM:

Load .X with the index into the buffer

from TO ($6F) and JSR to REDBAM ($F0DF) to read the BAM if not already in RAM.

Load .A with the current drive number

from DRVNUM ($7F) and transfer the drive

number into .X.

Multiply the drive number in .A by two

(ASL), OR it with the least used BAM

pointer in UBAM,X ($029B,X), EOR it with $01, and AND it with $03. Store the result into Tl ($70) and JSR to PUTBAM ($F0A5) to put. the memory image into the

BAM.

Load .A with the buffer number from

JOBNUM ($F9), multiply it by two (ASL),

and transfer the result into .X.

Load .A with the track number from TRACK

($80), multiply it by four (2 x ASL), and store the result as the lo byte of the pointer in BUFTAB,X ($99,X).

Load .A with the value from Tl ($70), multiply it by four (2 x ASL), and

transfer the result into .Y.

Transfer one byte of the BAM from its position in RAM, (BUFTAB,X) ($99,X), to its proper position BAM,Y ($02A1,Y). Zero the memory location that held the BAM byte (BUFTAB,X); ($99,X).

Increment, the lo byte of the pointer to the original BAM image BUFTAB,X ($99,X). Increment .Y, the pointer to the new BAM image. Transfer this value into .A, AND it with $03 to mask off the high order bits, and if the result is not $00,

branch back to SWAP3 to move the next

byte.

Load .X with the drive number from Tl

($70). Load .A with the current track number from TRACK ($80) and store the track number into TBAM,X ($029D,X) to set the track number for the image.

-----------------------------------------------------Page 396-----------------------------------------------------
﻿
NAME

SWAP 4

PUTBAM

SWAP1

SWAP2

CLNBAM

ADDRESS

$F097

$F09C

$F09F

$F0A4

$F0A5 $F0A6

$F0AB $F0AC $F0B1

$F0B5

$F0BA

$F0BE

$F0C3

$F0C8

$F0CA

$F0D0

$F0D1

$F0D5

$F0DA

DESCRIPTION OF WHAT ROM ROUTINE DOES

Load .A with the write-BAM flag from WBAM ($02F9). If the flag is non-zero,

branch to SWAP4 so we don't write out the BAM now.

JMP to DOWRIT ($D58A) to write out. the BAM to disk and terminate the routine.

OR the write-BAM flag (in .A) with $80

to indicate that, a write of the BAM is

pending and store the result back into

WBAM ($02F9).

Terminate routine with an RTS.

Transfer memory image of BAM into the correct, position in disk RAM:

Transfer the pointer in .A into .Y.

Load .A with the track number of the BAM

from TBAM,Y ($029D,Y). If the track number is $00, there is no BAM image

in RAM so branch to SWAP2.

Save the track number onto the stack.

Zero the track flag in TBAM,Y ($029D,Y).

Load .A with the buffer number from

JOBNUM ($F9), multiply it by two (ASL),

and transfer the result, into .X.

Pull the track number off the stack,

multiply it by four (2 x ASL), and store the result, as the lo byte of the pointer in BUFTAB,X ($99,X).

Transfer the pointer in .Y into .A, multiply it by four (2 x ASL), and

transfer the result, back into .Y.

Transfer one byte of the BAM image from BAM,Y ($02A1) to (BUFTAB,X); ($99,X). Zero the memory location that, held the BAM byte BAM,X ($02A1,X).

Increment the lo byte of the pointer to the original BAM image BUFTAB,X ($99,X). Increment .Y, the pointer to the new BAM image. Transfer this value into .A, AND it. with $03 to mask off the high order bits, and if the result is not $00,

branch back to SWAP1 to move the next

byte.

Terminate the routine with an RTS.

Zero the track number for BAM images:

Load .A with the drive number from TRACK

($80), multiply it by two (ASL), and

transfer the result into .X.

Zero .A and store $00 as the track # for the BAM image in TBAM,X ($029D,X).

Increment .X and store $00 as the track

# for the BAM image in TBAM,X ($029D,X).

397

-----------------------------------------------------Page 397-----------------------------------------------------
﻿
NAME

ADDRESS

$F0DE

DESCRIPTION OF WHAT ROM ROUTINE DOES

Terminate the routine with an RTS.

Read BAM from disk if not

already in RAM

REDBAM

$F0DF

$F0E5

$F0E7

$F0EB

$F0ED

Load .A with the value fr

compare it. with $FF. If i the BAM is in memory so b

Transfer the channel numb .A and save it onto the s JSR to GETBUF ($D28E) to

buffer. On return transfe number from .A into .X.

If a buffer was found (bi number not. set) , branch t Load .A with $70 to indie

CHANNEL ERROR and JSR to

om BUF0,X and t is not. $FF,

ranch to RBM2 0. er from .X into tack.

find a free r the buffer

t 7 of buffer o RBM10. ate a NO

CMDERR ($C1C8).

RBM10

RBM20

BAM2A

B2X10

BAAM2X

$F0F2

$F0F4

$F0F6

$F0FC

$F0FE

$F103

$F107

$F10A

$F10E

$F10F $F111

$F115

$F118

$F119

$F11C

Store the buffer number assigned (in .X) into JOBNUM ($F9).

Pull the channel number off the stack and transfer it into .Y.

Transfer the buffer number from .X to

• A, OR it. with $80 to set. it as inactive for stealing, and store the result into BUF0,Y ($00A7,Y).

Multiply the buffer number (in .A) by

two (ASL) and transfer the result, into

.X.

Load .A with the directory track number (#18) from DIRTRK ($FE85) and store it. in the header table at HDRS,X ($06,X). Store $00 as the BAM sector number in the header table at. HDRS + 1,X ($07,X). JMP to DOREAD ($D586) to read in the

BAM and terminate routine.

AND the channel number (in .A) with $0F and store the result, in JOBNUM ($F9) to

set. the BAM's job number.

Terminate routine with an RTS.

Load .A with the channel # for the BAM

Load .A with $0 6, the BAM's channel #

Load .X with the current drive number

from DRVNUM ($7F). If the drive number is not. $00, branch to B2X10.

Clear the carry flag and add $07 to find

the BAM channel number for drive #1. Terminate routine with an RTS.

Load .X with the channel # for the BAM JSR TO BAM2A ($F10F) to load .A with the

BAM's channel number.

Transfer the channel # from .A to .X.

398

-----------------------------------------------------Page 398-----------------------------------------------------
﻿
NAME

NXTTS

NXTDS NXT1

NXTERR

NXT2

ADDRESS

$F11D

$F11E

$F121 $F125

$F12D

$F130

$F133

$F136

$F13A

$F141

$F143 $F145

$F14C

$F14F $F150

$F152

$F156 $F158

$F15A

$F15F $F161

$F163

$F166

DESCRIPTION OF WHAT ROM ROUTINE DOES

Terminate routine with an RTS.

Next available track and sector:

Given current track and sector, this

routine returns the next available track and sector.

JSR to GETHDR ($DE3E) to set TRACK and

SECTOR from the most recent header. Store $03 into TEMP ($6F).

Load .A with $01, OR it with the value of the write-BAM flag, WBAM ($02F9), and

store the result back into WBAM to

prevent a write of the BAM.

Load .A with the value from TEMP ($6F) and save it. onto the stack.

JSR to SETBAM ($F011) to set the BAM image into memory.

Pull the original value of TEMP off the stack and store it back in TEMP ($6F).

Load .A with the BAM value from

(BMPNT),Y; ($6D,Y). If the value is not $00 (no sectors free), branch to FNDNXT

($F173) .

Load .A with the current track number

from TRACK ($80). If the track number is #18 (directory track), branch to

NXTERR to abort.

If the current, track is less than #18,

branch to NXT2.

Increment, the track number in TRACK ($80)

Compare the value of TRACK to $24 (#36) , the maximum track value. If they are not. equal, branch to NXT1 to check out. this

track.

Load .X with $12 (#18) , the directory

track number from DIRTRK ($FE85). Decrement, the track number in .X. Store the track number (in .X) into TRACK ($80).

Store $00 as the sector number into SECTOR ($81) .

Decrement the counter in TEMP ($6F). If the count is not $00 yet, branch to

NXT1.

Load .A with $72 to indicate a DISK FULL error and JSR to CMDERR ($C1C8).

Decrement the track number in TRACK($80) If the value in TRACK is not. $00, branch

to NXT1 to check out this track.

Load .X with $12 (#18), the directory track number from DIRTRK ($FE85). Increment the track number in .X.

399

-----------------------------------------------------Page 399-----------------------------------------------------
﻿
NAME

FNDNXT

FNDNO

FNDN1

FNDN2

ADDRESS

$F167

$F169

$F16D $F16F

$F171

$F173

$F175

$F178 $F17A

$F17F

$F185

$F189 $F18A

$F18C

$F191

$F193

$F195

$F198

$F19A

$F19D

DESCRIPTION OF WHAT ROM ROUTINE DOES

Store the track number (in .X) into TRACK ($80).

Store $00 as the sector number into SECTOR ($81).

Decrement the counter in TEMP ($6F).

If the count is not. $00 yet, branch to

NXT1.

If the count is $00, branch to NXTERR.

Find the optimum next sector on this track. Next sector=Current+change (#10)

Load .A with the sector number from

SECTOR ($81).

Clear the carry flag and add the sector increment from SECINC ($69). The normal increment is $0A (#10). It is $03 for the directory track.

Store the new sector number into SECTOR. Load .A with the current track number

from TRACK ($80) and JSR to MAXSEC ($F24B) to find the maximum sector

number on this track (returned in .A).

Store the maximum sector number into

LSTSEC ($024E) and CMD ($024D).

Compare the maximum sector number (in .A) with the new sector value in SECTOR ($81). If the new sector value is less

than the maximum, branch to FNDNO.

New sector number too big so subtract away the maximum sector number on track. Set the carry flag.

Load .A with the new sector number from SECTOR ($80) .

Subtract the maximum sector number on

this track from LSTSEC ($024E) and store the result into SECTOR ($81).

If the revised sector number is $00,

branch to FNDNO.

Decrement the revised sector number in

SECTOR ($81) by 1.

JSR to GETSEC ($F1FA) to set the BAM into memory and find the first available sector following the revised sector #.

If no sector is available on this track

(Z flag = 1), branch to FNDN2.

Exit with a JMP to WUSED ($EF90) to set

this new sector as in use.

Set the sector number in SECTOR ($81) to $00.

400

-----------------------------------------------------Page 400-----------------------------------------------------
﻿
NAME

INTTS

ITS2

ITS3

ADDRESS

$F1A1

$F198

$F1A6

$F1A9

$F1B1

$F1B4

$F1B8

$F1BB

$F1C0

$F1C4

$F1C7

$F1C9

$F1CB

$F1CE

$F1D3 $F1D5

$F1DA

$F1DF

$F1E2

DESCRIPTION OF WHAT ROM ROUTINE DOES

JSR to GETSEC ($F1FA) to set the BAM into memory and find the first available sector following the revised sector #.

If a sector is available on this track

(Z flag = 0), branch to FNDN1. JMP to DERR ($F1F5) to abort.

Find optimum initial track and sector:

Load .A with $01, OR it with the write- BAM flag, WBAM ($02F9), and store the

result, back in WBAM to indicate a write

of BAM is pending.

Load .A with the value from RO ($86) and

save it. onto the stack.

Store $01 into RO ($86).

NOTE: TRACK = DIRECTORY TRACK - RO

Load .A with the directory track number

($12) from DIRTRK ($FE85).

Set. the carry flag, subtract the counter

in RO and store the result into TRACK

($80) .

If the value in TRACK is less than or

equal to 0, branch to ITS2.

Do tracks 17 -> 1

JSR to SETBAM ($F011) to set. the pointer

to the BAM.

Load .A with the number of blocks free

on this track from (BMPNT),Y; ($6D,Y).

If some sectors are free on this track

(Z flag not. set) , branch to FNDSEC ($F1E6) .

None free on lower track so try a higher

one:

Load .A with the directory track number

($12) from DIRTRK ($FE85).

Clear the carry flag, add the counter in R0 and store the result into TRACK ($80) Increment, the track counter in R0 ($86). If the value in TRACK is greater than or equal to the maximum track number (#36),

branch to ITS3.

Load .A with $67 to indicate a SYSTEM

TRACK & SECTOR error and JSR to CMDER2

($E645) .

Do tracks 19 -> 35

JSR to SETBAM ($F011) to set. the pointer

to the BAM.

Load .A with the number of blocks free

on this track from (BMPNT),Y; ($6D,Y).

401

-----------------------------------------------------Page 401-----------------------------------------------------
﻿
NAME

FNDSEC

DERR

GETSEC

GS10

GS20

GS30

AVCK

ADDRESS

$F1E4

$F1E6

$F1E9

$F1ED

$F1F0 $F1F2

$F1F5

$F1FA

$F1FD

$F1FF

$F202

$F20A

$F20D

$F214

$F219

$F21D

$F21F

$F220

DESCRIPTION OF WHAT ROM ROUTINE DOES

If no sectors are free on this track

(Z flag is set), branch to ITS1 to try

a lower numbered track.

Pull the original value of RO off the stack and store it. back in RO ($86) . Store $00 as the sector number in SECTOR ($81) .

JSR to GETSEC ($F1FA) to set the BAM and

find first available sector.

If no sector available, branch to DERR. Terminate routine with a JMP to WUSED ($EF90) to mark sector as used in BAM.

Error in BAM:

Load .A with $71 to indicate an error in the BAM and JSR to CMDER2 ($E645) .

Set. the BAM and find the first, available

sector starting at SECTOR:

JSR to SETBAM ($F011) to set the pointer

to the BAM.

Transfer the .Y value into .A and save it onto the stack.

JSR to AVCK ($F2 20) to check the bit map validity.

Load .A with the current track number from TRACK ($80) and JSR to MAXSEC ($F24B) to find the maximum sector

number allowed on this track. On return, store the maximum sector number (in .A) into LSTSEC ($024E).

Pull the original .Y value off the stack and store it. in TEMP ($6F) .

Compare the current sector number from SECTOR ($81) with the maximum sector count in LSTSEC ($024E). If the current sector number is too large, branch to

GS20.

JSR to FREUS3 ($EFD5) to calculate index into the BAM. On return, if the Z flag is not set, the sector is free so branch

to GS30.

Sector was not free:

Increment, the sector number in SECTOR

($81) and branch (always) to GS10. Load .A with $00. Note that, this sets the Z flag to indicate that a free

sector was not found.

Terminate routine with an RTS.

Check the validity of the bit map:

Load .A with the value of TEMP ($6F) and save it. onto the stack.

402

-----------------------------------------------------Page 402-----------------------------------------------------
﻿
NAME

AC10 AC20

AC30

AC40

MAXSEC

MAX1

KILLP

ADDRESS

$F223 $F227

$F22A

$F22B $F22D

$F234

$F236

$F239

$F23C

$F242

$F245

$F246

$F24B

$F24E

$F251 $F252

$F254

$F257

$F258

DESCRIPTION OF WHAT ROM ROUTINE DOES

Store $00 into TEMP ($6F).

Load .Y with $04, the number of bytes per track in the BAM from BAMSIZ ($FE86) Decrement. .Y by 1 (now $03).

Load .X with $07 (bit counter).

Load .A with the BAM byte for this track from (BMPNT),Y; ($6D,Y), and AND the BAM byte with the bit mask from BMASK,X ($EFE9,X) to isolate the bit for this sector. If the result is $00, the sector

is allocated so branch to AC30.

Since the sector is free, increment, the count of free sectors in TEMP ($6F).

Decrement the bit. counter (1 bit/sector) in .X. If the count, is greater than or equal to $00, branch to AC20.

Decrement the byte counter (8 sectors/ byte) in .Y. If the count is not. $00,

branch to AC10.

Compare the number of bytes free on the track as given in the BAM at (BMPNT),Y ($6D,Y) with the count, we did in TEMP ($6F). If the counts DO NOT MATCH,

branch to AC40 to abort.

Pull the original value of TEMP off the stack and restore it. into TEMP ($6F) . Terminate routine with an RTS.

Error in BAM:

Load .A with $71 to indicate an error in the BAM and JSR to CMDER2 ($E645).

Returns the number of sectors allowed on this track. Track number in .A.

Load .X with the number of zones ($04) from NZONES ($FED6).

Compare the track number (in .A) with the zone boundary value from TRKNUM-1,X

($FED6,X).

Decrement the zone count in .X.

If the track number in .A is less than

the boundary value, branch to MAX1.

Load .A with the number of sectors/track for this zone from NUMSEC,X ($FED1,X).

Terminate routine with an RTS.

Kill protection: Does NOTHING on 1541!

Terminate routine with an RTS.

403

-----------------------------------------------------Page 403-----------------------------------------------------
﻿
NAME

CNTINT

ADDRESS

$F259

DESCRIPTION OF WHAT ROM ROUTINE DOES

DISK CONTOLLER ROUTINES

Controller initialization

$F25B

Store %01101111 in DDRB2 ($1C02)

the data direction
 for Port B.

to set

$F25E

$F26C

Store %01100000 in turn off the motor

Set the peripheral

DSKCNT ($1C00) to

& LED and set phase A control register

LCC

TOP

CONT10

CONT3 0

$F27B

$F281

$F286

$F28E

$F294 $F298 $F29C

$F2A4

$F2A8

$F2AC

$F2B0 $F2B3 $F2B6

$F2BE

$F2C3

$F2C5

$F2CA

$F2CD

$F2D1

($1C0C) for neg edge latch mode, CA2 hi to disable the SO line to the 6502, CB1 is input, and CB2 is R/W mode control. set T1HL2($1C07) to $3A and T1LL2($1C06) to $00 so there is 20ms between IRQ's store $7F in IER2 ($1C0E) to clear all IRQ sources.

store $C0 in IFR2 ($1C0D) to clear the bit and then into IER2 ($1C0E) to enable the timer IRQ.

store $FF as the current, drive, CDRIVE ($3E) and as init flag, FTNUM ($51).

set. header block ID, HBID ($39) to $08 set. data block ID, DBID ($47) to $07 set NXTST ($62/3) to point, to INACT

($FA05).

set MINSTP ($64) to 200 to indicate the

minimum number of steps required to invoke the fast, stepping mode.

store 4 into AS ($5E) to indicate the number of steps needed to accelerate

and decelerate the head.

store 4 into AF ($5F) as the

acceleration/deceleration factor.

Main controller loop:

Scans the job queue for job requests Finds job on current track if it exists

Save stack pointer in SAVSP ($49) . reset IRQ flag

set bits 3,2,& 1 of PCR2 ($1C0C) to enable S.O. to 6502, hi output.

top of loop to scan job queue. Load .Y with #$05 as pointer to top of queue. Load .A with byte from queue, JOBS,Y ($0000,Y). Test if bit. 7 is set. If not,

branch to CONT20 since no job here. Check if job is a jump code ($D0).

If not, branch to CONT30.

Transfer queue position from .Y to .A and JMP to EX2 ($F370) to do jump job. AND job code with $01. If result is 0,

the drive # is valid so branch to CONT35 Load .A with $0F to indicate a bad drive number and JMP to ERRR ($F969)

404

-----------------------------------------------------Page 404-----------------------------------------------------
﻿
NAME

CONT3 5

CONT40

CONT20

QUE

QUE05

QUE20

GOTU

EXE

EX

ADDRESS

$F2D8 $F2DB

$F2DF $F2E2

$F2E9

$F2ED

$F2F3

$F2F9

$F2FD

$F306

$F315

$F320

$F32A $F32D

$F32F

$F339

$F33C

$F34D

$F35F

$F363

$F367

$F36B

$F367 $F379

DESCRIPTION OF WHAT ROM ROUTINE DOES

Store job drive # in DRIVE ($3D).

Compare job drive # with current, drive number in CDRIVE ($3E). (CDRIVE is $FF if the drive is not. turned on.) If they are equal, branch to CONT40

JSR to TURNON ($F97E) to turn on drive. Set. CDRIVE to job drive # and exit for

now with a JMP to END ($F99C).

Check the value in DRVST ($20) to see if the drive is up to speed. If bit 7 is

set, it isn't so JMP to END ($F99C).

Check if the head is stepping. If it. is, exit with a JMP to END ($F99C) . If it. is not stepping, branch to QUE.

Decrement .Y pointer into queue. If more

locations in queue, branch back to

CONT10. If none left. JMP to END ($F99C). Store $20 in DRVST ($20) to set drive status to running.

Check if head needs to be stepped for this job. If not, branch to QUE20.

Check other jobs to see if one for this track. If not, calculate steps needed. Store $60 in DRVST ($20) to set drive status to stepping, store destination track in DRVTRK ($22) and exit for now with a JMP to END ($F99C).

check if job is on current drive. If

not, branch back to QUE05.

calculate distance to track

are we on track already? if so, branch

to GOTU.

store number of steps to the desired

track in NXTRK ($42)

JMP back to QUE0 5 to check if another job is closer.

Calculate zone (1-4) of the desired

track and store the number of sectors

on the track in SECTR ($43) .

Calculate recording density and set the divide by N counter by storing a value

in DSKCNT ($1C00).

Load .x with drive number and .A with

the job code.

Compare job code with $40. If equal, branch to BMP to do bump job.

Compare job code with $60. If equal, branch to EX to do execute job.

Not Bump or Execute, JMP to SEAK ($F3B1)

Do an execute job

set. pointer to buffer in BUFPNT ($30/1)

do indirect JMP via BUFPNT to the code that starts at the start of the buffer.

405

-----------------------------------------------------Page 405-----------------------------------------------------
﻿
NAME

BMP

SETJB

SEAK

SEAK

SEEK15

SEEK30

ADDRESS

$F37C

$F380 $F388

$F38C $F390 $F393

$F3B1

$F3B1

$F3B7

$F3BB $F3BE $F3C4 $F3C6

$F3C8

$F3D5

$F3D8

$F3E2

$F3E6 $F3EC

DESCRIPTION OF WHAT ROM ROUTINE DOES

Do a bump to track #1

Store $60 as the drive status, DRVST (20) to indicate head is stepping.

Set track phase to phase A

Store -45 ($A4) as the number of tracks to move head in STEPS ($4A).

Set DRVTRK ($22) to 1 as new track* Job done so JMP to ERRR ($F969).

Sub to set. pointer to buffer, BUFPNT ($30/31) and into header table, HDRPNT ($32) for this position in job queue.

Search for a valid header block on this

track. Up to 90 header and data blocks are scanned while looking for a valid header block before this routine gives up. A valid header block must, have:

1) a SYNC mark

2) a header block ID ($08)

3) a valid checksum (EOR of sector,

track, ID1, and ID2) 4) the sector number 5) the track number

6) the second disk ID character given

when the disk was formatted

7) the first, disk ID character given

when the disk was formatted

NOTE: The actual order of these bytes

is as given above. Not as listed

in the 1541 manual!

Store $5A (90) in TMP ($4B) as the sync mark counter (quit if counts down to 0) Store $52 into STAB ($24) as the header block ID code to wait for (GCR for $08) . JSR to SYNC ($F556) to wait, for sync Read first character after sync

Compare it to character in STAB ($24) If no match, this is not a header block

so branch to SEEK20.

Loop to read in the next 7 characters and store in STAB+1,X ($25,X).

JSR to CNVBIN ($F497) to convert the header bytes from GCR form to normal. Loop to compute checksum of header read EOR checksum, sector, track, ID1 & ID2. If computed checksum is not. 0, branch to CSERR ($F41E) to report error.

Update current, track from header data Compare job code in JOB ($45) with $30 to see if it is a seek job. If it is, branch to ESEEK ($F410) to do it.

406

-----------------------------------------------------Page 406-----------------------------------------------------
﻿
NAME

SEEK20

ESEEK

DONE

BAD ID

CSERR

WSECT

L460

L480

L465

ADDRESS

$F3F2

$F404

$F407

$F410

$F418

$F41B

$F41E

$F423 $F427

$F429 $F42C

$F432

$F43A $F443

$F447

$F44F

$F455

$F45E $F461

$F465

DESCRIPTION OF WHAT ROM ROUTINE DOES

Compare master disk ID in $12/13 to the disk ID from the header in $16/17. If

they don't, match, branch to BADID($F41B) to report a disk ID mismatch error. JMP to WSWCT ($F423) to find the best

sector on this track to service (usually

the current sector + 2)

Decrement. SYNC counter in TMP($4B) by 1 to see if we should check more syncs. If not 0 yet, branch back to SEEK10. If 0,

load .A with a $02 (to indicate header block not. found) and JMP to ERRR ($F969) Change master disk ID in $12/$13 to match the ID read in from $16/17 Load .A with a $01 (to indicate job

completed OK) and exit to error handler

Load .A with a $0B (to indicate disk ID

mismatch) and exit to error handler Load .A with a $09 (to indicate a bad checksum) and exit, to error handler

Determine best sector on this track to

service (optimum is current sector + 2)

Store $7F as the current sector in $4C Load .A with the sector number from the

header just read from HEADER + 3 ($19) .

Add 2

Compare sum to the number of sectors on

this track in SECTR ($43). If sum is too big, subtract the number of sectors.

Store sum as next sector to be serviced in NEXTS ($4D).

JSR to SETJB ($F393) to set pointers. Check to be sure job is for this drive.

If not, branch to L470 ($F483).

Check to be sure job is for this track. If not, branch to L470 ($F483).

Compare job code in JOB ($45) with $60 to see if it is an execute job. If it is, branch to L465.

Load .A with job's sector, (HDRPNT),Y and subtract the upcoming sector from NEXTS ($4D) . If result, is positive, branch to L465 since sector coming up. Add value from NEXTS ($4D) back in. Compare to distance to other sector

request. If further away, branch to L470 since other job is closer.

Save distance to sector on the stack.

Check job code in JOB ($45). If a read job, branch to TSTRDJ.

407

-----------------------------------------------------Page 407-----------------------------------------------------
﻿
NAME

DOITT

TSTRDJ

L470

CNVRTN

REED

READ01

READ11

READ20

ADDRESS

$F46A

$F473

$F47E

$F483

$F487

SFdQ7.

$F4CA

$F4D1

$F4D4

$F4DF

$F4ED

$F4F0

$F4F4

DESCRIPTION OF WHAT ROM ROUTINE DOES

This is a write job. Pull distance to sector off the stack. Since a write job requires set up time, if sector is less

than 9 ahead or more than 12 ahead, we

are better off doing another job so

branch to L470.

This job is closer than others so set up by storing distance in CSECT ($4C) and setting BUFPNT to point, to the buffer. Branch always to L470

This is a read job. Pull distance to sector off the stack. Since a read job doesn't, need much set. up time, if sector is less than 6 ahead, we better do it.

so branch to DOITT.

Decrement, queue position in JOBN ($3F) by 1. If more to check branch to L480. No more to check. Test, if any jobs were found. If none, JMP to END ($F99C). If yes, set. up job and JMP to REED ($F4CA)

.Co-Ei-vert GCR- imac-e---o-f- -header into the

normal 8 bit binary and move the values into $16/7/8/9/A. The characters

decoded include:

-Header block ID code (usually $08)

-Hdr block checksum (EOR of T/S/ID1/ID2)

-Sector number -Track number

-ID2 (2nd ID chr given when formatted) -ID1 (1st. ID chr given when formatted) -The remaining characters are junk!

Read in the track and sector that is

specified in the header table

Check if this is a read job. If not, JMP to WRIGHT ($F4CE)

JSR to DSTRT ($F50A) find header and set up to the start of the data block

Loop to read first 256 data bytes and

store them in the data buffer.

Loop to read the last. 70 data bytes and

store them in the overflow buffer from

$01BA to $01FF.

JSR to GCRBIN ($F8E0) to convert the 3 26 GCR data bytes into 256 normal bytes

Compare the first byte in the data block from BID ($38) with the header block ID character (normally $07) in HDIB ($47) to check if this is a legal data block. If they match, branch to READ2 8.

408

-----------------------------------------------------Page 408-----------------------------------------------------
﻿
NAME
 ADDRESS

DESCRIPTION OF WHAT ROM ROUTINE DOES

READ28

DSTRT

$F5F6

$F4FB

$F4FE

$F502

$F504 $F5F6 $F507 $F50A

No match, so load .A with a

DATA BLOCK NOT FOUND error

ERRR ($F969).

JSR to CHKBLK ($F5E9) to co

checksum for the data block

all the 256 data bytes.

Compare the computed checks

with the checksum read from

CHKSUM ($3A). If equal, bra

No match, so load .A with a

DATA BLOCK CHECKSUM error

Byte $2C to skip over next.

Load .A with a 1 to indicat

JMP to ERRR ($F969) .

JSR to SRCH ($F510) to find

header block.

JMP to SYNC ($F556) to wait data block sync character.

4 to flag a

and JMP to

mpute the by EORing

urn in .A with

the disk in

nch to READ40

5 to flag a

LDA

e a good read

the desired

for the

SRCH

SRCH20

SRCH25

SRCH30

ERR

SYNC

$F510

$F529

$F533

$F536

$F538

$F53D

$F54D

$F54E

$F551

$F553

$F556

Find a specific header. The track and

sector desired must be stored in the header table

Use values from the header table and

the master disk ID ($12/3) to set up an image of the desired header $16-$19

EOR the track, sector, and ID characters

to calculate the header checksum and store it in $1A.

JSR to CONHDR ($F93 4) to convert, the header image into its GCR image.

Load .X with $5A as a counter of the number of sync marks checked.

JSR to SYNC ($F556) to wait for the next sync mark.

Loop to scan the 8 bytes following the sync mark to attempt, to find a match to the GCR image of the desired header. If any character does not match the image,

branch to SRCH30.

All characters match so exit with an RTS

Decrement the sync mark counter in .X If counter is not. 0 yet, branch back to SRCH20 to wait for next sync.

No match, so load .A with a 2 to flag a

BLOCK HEADER NOT FOUND error.

JMP to ERRR ($F969).

Wait, for SYNC mark

A SYNC mark is 10 or more consecutive l's bits written onto the disk. It is

used to identify the start of a block

of information recorded on disk. The

409

-----------------------------------------------------Page 409-----------------------------------------------------
﻿
NAME

ADDRESS

DESCRIPTION OF WHAT ROM ROUTINE DOES

first, character following

a SYNC mark

is used to determine whet

her this is

a header block ($08) or a

data block

($07).

SYNC10

$F556

$F55B

$F55D

$F562

$F567

Store $D0 in TIMER1 ($1805

maximum wait, of 20 millise

sync before timing out.

Load .A with $03 (the erro NO SYNC FOUND error)

Test bit. 7 of TIMER1 ($180

for a time-out. If time is

to ERR ($F553) to exit.

Test bit 7 of DSKCNT ($1C0 for a sync. If no sync, br

SYNC 10 to wait, some more. Load .A from DATA2 to rese clear the 6502's overflow

) to allow a

conds for a

r code for a

5) to check up, branch

0) to check

anch back to

t the PA latch

flag, and RTS

WRIGHT

WRT10

WRTSNC

$F56E

$F575

$F5 7A

$F586

$F589

$F58C

$F594

$F599

$F5A?

$F5AP

Write contents of data buffer to disk

Compare job code in .A with $10 to check if this is write job. If not, JMP to

VERIFY ($F691).

JSR to CHKBLK ($F5E9) to compute the

checksum for the data block. Store the

checksum in CHKSUM ($3A).

Load .A from DSKCNT and AND it. with $10

to check for write protect tab. If the result, is not. $00, OK to write so branch

to WRT10.

Load .A with $08 to flag a WRITE PROTECT

error and JMP to ERRR ($F969)

JSR to BINGCR ($F78F) to convert data

in the buffer into GCR form.

JSR to SRCH ($F510) to find the correct

header block

Wait for 8 more bytes to go by. This is the header gap.

NOTE: The header gap on the 1541 is 8 bytes long. The gap on the 4040 is 9 bytes long. This is the main reason why the drives are write incompatible!

Store $FF in DDRA2 ($1C03) to make Pert A an output port-

Load .A from PCR2 ($1C0C), AND the value with $1F, OR it with $C0, and store the

result, in PCR2 to turn on write mode. Store $FF in DATA2 ($1C01) as the SYNC

mark character

Loop to write out. 5 consecutive $FF bytes (5x8 =40 l's).

410

-----------------------------------------------------Page 410-----------------------------------------------------
﻿
NAME

WRT3 0

WRT4 0

CHKBLK

WTOBIN

ADDRESS

$F5B1

$F5B3

$F5BF

$F5CA $F5CC

$F5D4

$F5D9

$F5DC

$F5E6

$F5E9

$F5F2

$F5F2 $F5FE $F604

$F608

$F60A

DESCRIPTION OF WHAT ROM ROUTINE DOES

Load .Y with $BB to point into the overflow buffer ($01BB-01FF).

Load .A with byte from overflow buffer, wait, till last, byte is out, store new byte into DATA2 ($1C01) , increment .Y pointer, and if more characters to do,

branch back to WRT3 0.

Load .A with byte from data buffer, wait till last byte is out, store new byte into DATA2 ($1C01), increment .Y pointer, and if more characters to do,

branch back to WRT40.

Wait for final byte to clear

Load .A from PCR2 ($1C0C), OR the value with $E0, and store the result back in

PCR2 to shift to read mode.

Store $00 in data direction register DDRA2 to make port A an input port. JSR to WTOBIN ($F5F2) to convert. GCR

data in buffer back into its normal 8

bit form to prepare to verify it.

Convert the write job number in the job queue into a verify job.

JMP to SEAK ($F3B1) to scan the queue for the next job.

Calculate data block checksum

EOR the 256 data bytes. Return with the

checksum in .A

Convert the 10 bit image of the data to normal 8 bit binary. Since 5 encoded bytes (40 bits) are converted into 4 normal bytes (32 bits), the encoded form of 256 data bytes takes up 320 bytes. At the start of this routine the first 64 encoded bytes that were

read are stored in the overflow buffer

($01BA-FF) and the remaining 256 bytes

are in the normal data buffer. At the

end of the routine the decoded bytes

are stored in the normal data buffer.

Set. up pointers to the buffers

Do the overflow buffer ($01BA-FF) first. Store $BB in GCRPNT ($34) so it. points to the first byte in the overflow buffer ($01BB) that is to be processed by the

routine GET4GB.

Store $BB in BYTCNT ($52) so it. points

to the location where the first decoded

data byte is to be stored.

JSR to GET4GB ($F7E6) to convert the

411

-----------------------------------------------------Page 411-----------------------------------------------------
﻿
NAME

WTOB14

WTOB50 WTOB5 3

WTOB5 2

WTOB57

VRFY

ADDRESS

$F60D $F611

$F624

$F629

$F641 $F643 $F64F

$F629

$F66E

$F683

$F68E

$F690

$F691

DESCRIPTION OF WHAT ROM ROUTINE DOES

first five GCR bytes into 4 normal bytes (the data block ID + 3 data bytes). The

decoded bytes appear in $52-5

Store data block ID chr in BID ($38). Move decoded data b>tes from $53-$55 to the buffer ($01BB-D). Note that the decoded bytes are put. back into the

overflow buffer.

JSR to GET4BG ($F7E6) to convert the next. 5 GCR bytes to 4 normal bytes and

store them in $52-5.

Move decoded data bytes from $53-$55 to the buffer ($01BB-D). Note that the

decoded bytes are put back into the

overflow buffer.

If more in overflow, branch to WT0B14 Move last two data bytes into buffer Loop to convert the 256 bytes in data buffer. JSR to GET4BG ($F7E6) to convert the next. 5 GCR bytes to 4 normal bytes and store them in $52-5.

Move decoded data bytes from $53-$55 tc

the data buffer. Note that the decoded

bytes are put. back in the data buffer.

At this point the data bytes have all been decoded. Some bytes are in the

overflow buffer and some are in the

lower part of the data buffer. The following routines shift the bytes in the buffer up and then fill the lower part, of the buffer with the bytes from

the overflow buffer.

Move decoded bytes in lower part of the data buffer up into their proper places

in the buffer.

Move decoded bytes from the overflow

buffer to the bottom of the data buffer.

Set. GCRFLG ($50) to 0 to indicate that

the data in buffer is in normal form. Exit with an RTS.

Verify a data block

This routine converts the data in the data buffer into its 10 bit encoded

form (GCR). It then compares the GCR image with what is recorded on the

disk. The encoded data is then changed back into normal 8 bit binary form.

Compare job code in .A with $20 to check that this is a verify job. If not, JMP

to SECTSK (F6CA) to do a sector seek.

412

-----------------------------------------------------Page 412-----------------------------------------------------
﻿
NAME

VRF15

VRF30

VRF20

SECTSK

PUT4GB

ADDRESS

$F698

$F69D

$F6A0

$F6A3

$F6B3

$F6C2

$F6C5

$F6CA

$F6D0

DESCRIPTION OF WHAT ROM ROUTINE DOES

JSR to CHKBLK ($F5E9) to compute the

checksum for the data block. Store the

checksum in CHKSUM ($3A).

JSR to BINGCR ($F78F) to convert the data to its GCR image.

JSR to DSTRT ($F50A) to find the right.

sector and wait, for data.

Loop to read 64 data bytes from disk and compare them to those in the overflow buffer. If any bytes do not match, branch to VRF20 to report error.

Loop to read 254 data bytes from disk and compare them to those in the data buffer. If any bytes do not match, branch to VRF20 to report .error.

All bytes match so JMP to DONE ($F418)

Bad byte, so load .A with $07 to flag a WRITE-VERIFY error & JMP to ERRR ($F969)

JSR to SRCH to do a sector search

JMP to DONE ($F418)

Convert binary to GCR

This routine is used to convert. 4 normal

8 bit bytes into the 10 bit encoded form used for recording onto disk. Encoding involves breaking up each 8 bit normal byte into two 4-bit nybbles. The 5-bit equivalent for each nybble is found by looking in a table. The 10 bits that

result are stored in two consecutive

memory locations. When four 8-bit bytes are encoded, the resulting 40 bits are

stored like this:

Four normal 8 bit bytes stored in $52/3/4/5

AAAABBBB CCCCDDDd'EEEEFFFF GGGGHHHH

Four 10 bit. encoded bytes stored in buffer aaaaabbb bbcccccd ddddeeee efffffgg ggghhhhh

$F6D0

$F6D8

Clear critical areas of the buffer where

the encoded bytes are to be stored. GTAB to GTAB+4 ($56-5A)

Load first 8-bit byte ($52), AND it with $F0 (11110000) to mask off the low

nybble (AAAA0000), do four LSR's to convert, the hi nybble to a low nybble (0000AAAA), look up the corresponding five bit. GCR value (OOOaaaaa) in BGTAB BGTAB ($F77F+), do three ASL's on it (aaaaaOOO), and store it in the first position in the encoded data area ($56)

413

-----------------------------------------------------Page 413-----------------------------------------------------
﻿
NAME

ADDRESS

$F6E9

$F6FE

$F70F

$F725

$F73D

$F74D

DESCRIPTION OF WHAT ROM ROUTINE DOES

Load first. 8-bit byte ($52), AND it with $0F (00001111) to mask off the high

nybble (0000BBBB), find the five bit GCR equivalent (OOObbbbb) in BGTAB ($F77F+),

do two ROR's on it alternated with ROR's

on $57 ,A=(OOOOCbbb) $57=bb000000, AND the value in .A with $07 (00000111), OR the value in .A with the value in $52

(aaaaaOOO) , and store the result.

(aaaaabbb) in the first position of the

GCR data buffer (BUFPNT),Y ($30,Y). Load second 8-bit byte ($53) , AND it. with $F0 (11110000) to mask off the low

nybble (CCCC0000), do four LSR's to convert the hi nybble to a low nybble (0000CCCC), look up the five bit GCR

equivalent. (OOOccccc) in BGTAB ($F77F+) ,

do one ASL on it (OOcccccO), OR it with the contents of $57 (bbOOOOOO), and put the result (bbcccccO) in $57.

Load second 8-bit byte ($53), AND it

with $0F (00001111) to mask off the high nybble (0000DDDD), find the five bit GCR equivalent. (OOOddddd) in BGTAB ($F77F+) , do four ROL's on it. (ddddOOOO C = d) , store it. in $58 (ddddOOOO) , do one more ROL (dddOOOOd C=d), AND it with $01, OR it with the value in $57 (bbcccccO) and store the result (bbcccccd) into the second byte of the GCR buffer

Load third 8-bit byte ($54), AND it with $F0 (11110000) to mask off the low nybble (EEEE0000), do four LSR's to convert the hi nybble to a low nybble (0000EEEE), look up the five bit GCR

equivalent (OOOeeeee) in BGTAB ($F77F+),

do one FOR on it (OOOOeeee C = e) , OR it. with the contents of $58 (ddddOOOO),

store the result (ddddeeee) in the third byte of the GCR buffer, do another ROR (eC000eee)C = e, AND it. with $80(10000000) and store the result (eOOOOOOO) in $59.

Load third 8-bit byte ($54), AND it with $0F (00001111) to mask off the high

nybble (0000FFFF), find the five bit GCR equivalent (OOOfffff) in BGTAB ($F77F+), do two ASL's on it. (OfffffOO), AND it with $7C (01111100), OR it with the value in $59 (eOOOOOOO), and store the result (efffffOO) in $59

Load the fourth 8-bit byte ($55), AND it with $F0 (11110000) to mask off the low nybble (GGGG0000), do four LSR's to

414

-----------------------------------------------------Page 414-----------------------------------------------------
﻿
NAME

ADDRESS

DESCRIPTION OF WHAT ROM ROUTINE DOES

convert the hi nybble

to a low nybble

he five bit GCR

(0000GGGG), look up t

in BGTAB ($F77F+),

equivalent (OOOggggg)

do three ROR's on .A
 alternated with

ROR's on $5A .A=(0000
 Ogg) $5A= (gggOOOOO)

AND .A with $03 (0000

0011), OR .A with

the contents of $59 (

efffffOO), & store

result (efffffgg) in

the fourth byte of

the GCR buffer.

$F76F

Load the fourth 8-bit

with $0F (00001111) t nybble (0000HHHH), fi equivalent (OOOhhhhh)

OR it with the value and store the result.

fifth position of the

byte ($55), AND it o mask off the high

nd the five bit GCR

in BGTAB ($F77F+), in $59 (gggOOOOO), (ggghhhhh) in the

GCR buffer.

BGTAB

$F77F

Table of 5 bit GCR equivalents

4 bit nybble 5 bit GCR code

$00 $01 $02 $03 $04 $05 $06 $07 $08 $09 $0A $0B $0C $0D $0E $0F

0000 0001 0010 0011 0100 0101 0110 0111 1000 1001 1010 1011 1100 1101 1110 1111

$0A $0B $12 $13 $0E $0F $16 $17 $09 $19 $1A $1B $0D $1D $1E $15
 01010 01011 10010 10011 OHIO 01111 10110 10111 01001 11001 11010 11011 01101 11101 11110 10101

BINGCR

Ncte: 5 bits are used to ensure that

not more than 2 consecutive 0's are recorded on disk.

Create write image of data

This routine converts 260 normal 8-bit

bytes into their 10-bit equivalents to produce an image for writing to disk. A total of 325 GCR bytes are produced.

415

-----------------------------------------------------Page 415-----------------------------------------------------
﻿
NAME

BING07

GET4GB

ADDRESS

$F78F $F797 $F7A5

$F7BA

$F7BC

$F7BF

$F7D7

$F7D9

$F7E3

DESCRIPTION OF WHAT ROM ROUTINE DOES

The original 8-bit bytes are: 1 data block ID character ($07)

256 data bytes (stored in buffer X)

1 data checksum

2 off bytes ($00)

260 8-bit binary bytes

The first 69 GCR bytes are stored in the

overflow buffer ($10BB-FF). The rest of

the GCR bytes are stored in buffer X and replace the original data bytes

Initialize pointers to buffers

Set pointer to start of overflow $01bb

Move data block ID code from DBID ($47)

and first 3 data characters into a work

area ($52/3/4/5) for input by the PUT4GB routine ($F6D0)

Store pointer to next byte to convert

(in .Y) into BYTCNT ($36) .

JSR to PUT4GB ($F6D0) to convert the four bytes in $52/3/4/5 into their five GCR equivalents and store in buffer. Use

the overflow buffer first and then use the data buffer.

Move next four bytes into the work area

($52/3/4/5) .

If more bytes to convert (.Y is count)

branch back to BING07.

Move data block checksum from DBID ($3A)

and two off bytes ($00) into the work area ($53/4/5) NOTE: THE LAST DATA BYTE IS IN $52.

JSR to PUT4GB ($F6D0) to convert the

four bytes in $52/3/4/5 into their five GCR equivalents and store in buffer.

Convert. GCR to binary

This routine is used to decode 5 GCR

bytes (used for recording on disk) into 4 normal 8-bit binary bytes. Decoding involves extracting 5 bits from one or two GCR bytes. The 4-bit nybble that is equivalent to it. is found by looking in a table. The pattern of 5-bit segments in the 5 GCR bytes and the equivalent 4-bit nybbles in the four binary bytes

are indicated below:

Four 10 bit. encoded bytes stored in buffer aaaaabbb bbcccccd ddddeeee efffffgg ggghhhhh

416

-----------------------------------------------------Page 416-----------------------------------------------------
﻿
NAME

ADDRESS
 DESCRIPTION OF WHAT ROM ROUTINE DOES

Four normal 8 bit bytes stored in $56/7/8/9

AAAABBBB CCCCDDDD EEEEFFFF GGGGHHHH

$F7E6

$F7F1

$F7F9

$F802

$F80D

$F814

$F81F

$F82B

$F833

$F840

Load the first GCR byte (aaaaabbb) from (BUFPNT) ,Y, AND it. with $F8 (11111000) to mask off the low bits (aaaaOOO), do

three LSR's and store the result

(OOOaaaaa) in GTAB ($56)

Load the first GCR byte (aaaaabbb) from (BUFPNT),Y, AND it with $07 (00000111) to mask off the high bits (OOOOObbb), do two ASL's and store the result(OOObbbOO) in $57.

Increment Y and check if Y=0. If so, change BUFPNT so it points to the data

buffer rather than the overflow buffer.

Load the second GCR byte (bbcccccd) from (BUFPNT),Y, AND it with $C0 (11000000) to mask off the low bits (bbOOOOOO), do three ROL's (OOOOOObb), OR it with the value in $57 (OOObbbOO), and store the result (OOObbbbb) back in $57.

Load the second GCR byte(bbcccccd) from (BUFPNT),Y, AND it with $3E (00111110) to mask off unwanted bits (OOcccccO), do one LSR and store the result. (OOOccccc) in $58.

Load the second GCR byte (bbcccccd) from (BUFPNT),Y, AND it with $01 (00000001) to mask off unwanted bits (OOOOOOOd),

do four ASL's and store the result

(OOOdOOOO) in $58.

Load the third GCR byte (ddddeeee) from (BUFPNT),Y, AND it with $F0 (11110000) to mask off the low bits (ddddOOOO), do four LSR's (OOOOdddd) , OR it. with the value in $59 (OOOdOOOO), and store the result (OOOddddd) back in $59.

Load the third GCR byte (ddddeeee) from (BUFPNT) ,Y, AND it with $0F (00001111) to mask off hi bits (OOOOeeee), do one ASL and store the result (OOOeeeeO) in $5A. Load the fourth GCR byte (efffffgg) from (BUFPNT),Y, AND it with $80 (10000000) to mask off the low bits (eOOOOOOO), do two ROL's (OOOeOOOO), OR it with the value in $5A (OOOOeeee), and store the result. (OOOeeeee) back in $5A.

Load the fourth GCR byte (efffffgg) from (BUFPNT),Y, AND it with $7C (01111100) to mask off unwanted bits (OfffffOO), do two LSR's and store the result. (OOOfffff) in $5B.

417

-----------------------------------------------------Page 417-----------------------------------------------------
﻿
NAME

ADDRESS
 DESCRIPTION OF WHAT ROM ROUTINE DOES

$F848

$F854

$F85A

$F866

Load the

(BUFPNT)

to mask

do three

(OOOggOO

Incremen

point to

Load the

(BUFPNT)

to mask

four ROL value in

result (

Load the

(BUFPNT)

to mask

and stor

fourth GCR byt. ,Y, AND it. with

off unwanted bi LSR's and stor

0) in $5C.

t Y. If Y=0 cha the next, buffe

fifth GCR byte ,Y, AND it with

off the low bit

's (OOOOOggg), $5C (OOOggOOO) OOOggggg) back fifth GCR byte ,Y, AND it with off the high bi e in $5D

e (efffffgg) from

$03 (00000011) ts (OOOOOOgg),

e the result

nge BUFPNT to

r.

(ggghhhhh) from $E0 (11100000)

s (gggOOOOO), do

OR it with the

, and store the in $5C.

(ggghhhhh) from $1F (00011111) ts (OOOhhhhh),

$F86D

$F87B

$F887

$F893

At this point the 40 bits that made up the 5 GCR bytes have been separated into eight 5-bit values that, correspond to the eight 4-bit nybbles that will make up the four normal binary bytes. The 8 5-bit values are stored in $56-D. The following routines look up the 4-bit hi nybbles in GCRHI ($F8A0) and the low nybbles in GCRLO (starts at $F8C0)

Load .X with the first 5-bit value from

$56, load .A with 4-bit high nybble

from GCRHI,X, load X with a second five bit value from $57, OR .A with the four bit low nybble from GCRLO,X, and store

the result in $52.

Load X with the third 5-bit value from

$58, load .A with 4-bit high nybble from GCRHI,X, load X with the fourth 5-bit value from $59, OR .A with the 4-bit low nybble from GCRLO,X and store the result in $53.

Load X with the fifth 5-bit value from

$5A, load .A with 4-bit high nybble from from GCRHI,X, load X with the second five bit value from $5B, OR .A with the four bit low nybble from GCRLO,X, and store the result in $54.

Load .X with the seventh 5 value from

$5C, load .A with 4-bit high nybble from GCRHI,X, load X with the second 5-bit value from $5D, OR .A with the four bit low nybble from GCRLO,X, and store the result, in $55.

418

-----------------------------------------------------Page 418-----------------------------------------------------
﻿
NAME

ADDRESS
 DESCRIPTION OF WHAT ROM ROUTINE DOES

NOTE: The five bit to four bit tables below have many $FF

entries. These are the five bit codes that are not used.

If one of these is found, it causes a byte decoding error

GCRHI($F8A0) &

GCRLO($F8C0) Tables

of 5

bit GCR to binary

5 bit.

GCR code

High nybble
 ($F8A0+
 ) Low
 nybble ($F8C0+)

$00 $01 $02 $03 $04 $05 $06 $07 $08 $09 $0A $0B $0C $0D $0E $0F $10 $11 $12 $13 $14 $15 $16 $17 $18 $19 $1A $1B $1C $1D $1E $1F
 00000 00001 00010 00011 00100 00101 00110 00111 01000 01001 01010 01011 01100 01101 OHIO 01111 10000 10001 10010 10011 10100 10101 10110 10111 11000 11001 11010 11011 11100 11101 11110 11111
 $FF $FF $FF $FF $FF $FF $FF $FF $FF $80 $00 $10 $FF $C0 $40 $50 $FF $FF $20 $30 $FF $F0 $60 $70 $FF $90 $A0 $B0 $FF $D0 $E0 $FF

11111111 11111111 11111111 11111111 11111111 11111111 11111111 11111111 11111111 1000

0001

11111111 1100 0100 0101

11111111 11111111 0010 0011

11111111 1111 0110 0111

11111111 1001 1010 1011

11111111 1101 1110

11111111

ERROR ERROR ERROR ERROR ERROR ERROR ERROR ERROR ERROR

ERROR

ERROR ERROR

ERROR

ERROR

ERROR

ERROR

$FF $FF $FF $FF $FF $FF $FF $FF $FF $08 $00 $01 $FF $0C $04 $05 $FF $FF $02 $03 $FF $0F $06 $07 $FF $09 $0A $0B $FF $0D $0E $FF

11111111 11111111 11111111 11111111 11111111 11111111 11111111 11111111 11111111

---- ---- ---- 11111111

---- ---- ---- 11111111 11111111

---- ---- 11111111

---- ---- ---- 11111111

---- ---- ---- 11111111

---- ---- 11111111

ERROR ERROR ERROR ERROR ERROR ERROR ERROR ERROR ERROR

ERROR

ERROR ERROR

ERROR

ERROR

ERROR

ERROR

GCRBIN

Decode GCR data image

This routine decoded the 69 GCR bytes stored in the overflow buffer ($10BB-FF) into normal 8-bit bytes. The decoded bytes are stored in a data buffer.

$F8E0 $F8E8

Zero byte counter & lo bit of pointers Set. lo byte of pointer, NXTBF ($4E) to $BA and set the hi byte NXTPNT ($4F) to $01 so they point to the first byte of the GCR image in the overflow buffer.

419

-----------------------------------------------------Page 419-----------------------------------------------------
﻿
NAME

GCRB10

GCRB20

CONHDR

ADDRESS

$F8F0

$F8F4

$F8F7 $F8FB

$F90C

$F90E

$F913

$F918

$F91A

$F929

$F92B

$F92F

$F934

$F938 $F93C $F940 $F944 $F948 $F94C $F950

DESCRIPTION OF WHAT ROM ROUTINE DOES

Set SAVPNT+1 ($2F) to point to the data buffer where the 8-bit bytes are to be

stored.

JSR to GET4GB ($F7E6) to convert the

first five GCR bytes into binary, the

header block ID, the header checksum, the sector #, and the track #. The decoded bytes appear in $52-5.

Store header block ID code in BID ($38) Move the three decoded bytes from $53-55 into the buffer. Note that these bytes

are NOT stored in the overflow buffer

where the GCR image is stored.

Transfer byte pointer from .Y into BYTCNT ($36) .

JSR to GET4GB ($F7E6) to convert the next five GCR bytes to normal and store them in $52-5.

Move decoded data byte from $52 into the

data buffer.

Test. .Y to see if entire overflow buffer

has been done. If done, branch to GCRB20 Move decoded data bytes from $53-5 into

the data buffer.

If .Y is not $00, there is more to do

so branch back to GCRB10.

Move header block checksum from $53 to CHKSUM ($3A)

Restore buffer pointer and RTS.

Convert header to write image

This routine creates a GCR image of a

header block. It uses the header block

ID code from HBID ($39) and the header information stored in $1A (checksum), $19 (sector), $18 (track), $17 (ID2), and $16 (ID1). A final $00 byte is used as a final off byte. Four of the binary bytes are moved into a staging area and the subroutine PUT4GB ($F6D0) is used to convert these bytes to their GCR image and store them in the STAB buffer($24-D)

Save current value of the buffer pointer BUFPNT+1 ($31) in SAVPNT+1 ($2F).

Make BUFPNT+1 ($31) point to >STAB ($00) Make GCRPNT ($34) point to <STAB ($24)

Move hdr blk ID from HBID ($39) to $52 Move checksum from $1A to $53 Move sector from $19 to $54 Move track from $18 to $55

JSR to PUT4GB ($F6D0) to convert the four bytes in $52-5 to 5 GCR bytes and

store them at the start of STAB ($24-8).

420

-----------------------------------------------------Page 420-----------------------------------------------------
﻿
NAME

ADDRESS
 DESCRIPTION OF WHAT ROM ROUTINE DOES

ERRR

$F953 Move 2nd ID chr from $17 to $52 $F957 Move 1st. ID chr from $16 to $53 $F95B Store $00 off bytes into $54 & $55 $F961 JSR to PUT4GB ($F6D0) to convert, the

four bytes in $52-5 to 5 GCR bytes and store them in STAB ($29-D).

$F964 Restore the buffer pointer BUFPNT+1($31)

to its previous value and RTS.

UTILITY ROUTINES

Disk controller error handling

This routine is used to terminate all

of the major disk controller routines. The inputs to this routine are: the error code (see table) in .A, the job buffer number in JOBN ($3F), and the GCRFLG ($50) (tells if the data in the buffer has been left in write image (1) or binary (0) form). The routine stuffs the error code into the job queue, converts the data back to binary (if necessary), starts time-out to turn off the drive motor, resets the stack pointer, and exits to $F2BE to begin scanning the job queue again.

ERRR10

TURNON

TRNOFF

$F969 $F96E

$F972

$F96E

$F978

$F97B

$F97E

$F982

$F98A

$F98F $F991

Store error code in .A into job queue

Check GCRFLG ($50) to see if data left in GCR format. If not, branch to ERRR10. JSR to WTOBIN ($F5F2) to convert, data

from GCR to normal.

JSR to TRNOFF ($F98F) to start the time¬

out to turn off the drive motor.

Use value from SAVSP ($49) to reset the stack pointer.

JMP to TOP ($F2BE) to scan job queue.

Turn on disk drive motor

Store $A0 into drive status, DRVST ($20)

to indicate that the drive is ON but

not yet. up to speed (accelerating) . Set bit 2 (00000100) of DSKCNT ($1C00)

to turn ON the drive motor.

Store $3C into acceleration timer,ACLTIM ($48) to cause drive status to be set

to up-to-speed after 1.5 seconds. (60 interrupts at .025 seconds each)

Turn off disk drive motor

Load .X with current drive # (0)

Set. bit 4 (00010000) of the drive status DRVST ($20) to indicate DRIVE IS OFF!

421

-----------------------------------------------------Page 421-----------------------------------------------------
﻿
NAME

END

END33X

END 10

END 20

ADDRESS

$F997

$F99C

$F9A5

$F9B1

$F9CB

$F9CF

$F9D6

$F9D9

$F9E4

DESCRIPTION OF WHAT ROM ROUTINE DOES

Store $FF into acceleration timer to

cause the drive to be turned OFF after

6.4 seconds. (255 interrupts x .025 sec)

Drive motor and head stepper control This routine is the last part of the main IRQ routine. As a result, it. is executed every 10 milliseconds. Control is transferred to the routine by JMP

instructions at the conclusion of the main disk controller routines. The RTS at the end of the routine transfers

control to master IRQ routine at $FE7C. Move value in the 6522's timer #1 high latch ($1C07) into timer #l's high bit counter ($1C05)

Test if write protect, status has changed by loading the value from the 6522's data PORT B($1C00), ANDing it with $10 and comparing it to the value in LWPT ($1E). If not. equal, set flag for change

in status, WPSW ($1C) to $01.

Test whether the head stepper is in

(0 or 2) or out (1) of phase. The head's stepper motor moves half a track at a time. If the head is halfway between two tracks, the value stored in PHASE($02FE) is 1. If the value in PHASE is 0, branch to END40 ($F9CB) . If PHASE is 2, set it. to $00 and branch to END40. If it is $01 set. it to $02 & branch to DOSTEP ($FA2E)

to move head half a track.

Check CDRIVE ($3E) to see if the drive is active. If not active, branch to END3 3X to end the IRQ routine.

Load DRVST ($20) to see if the motor is

ON and compare value with $20. If there is anything to do (result not. equal),

then branch to END10.

JMP to END33 ($FABE) to end IRQ.

Something doing, so decrement, the

acceleration timer, ACLTIM ($48), and if drive is not yet up to speed, branch to

END3 0.

Since drive is up to speed, clear the not-up-to-speed bit (bit 7) of the drive status, DRVST ($20) .

AND the value of DRVST ($20) with $10 to test, whether a time-out has occurred and it is time to turn off the drive motor. If not, branch to END30 ($F9FA).

422

-----------------------------------------------------Page 422-----------------------------------------------------
﻿
NAME

END 3 0

INACT

INAC10

INAC20

DOSTEP

STPOUT

ADDRESS

$F9E8

$F9F0

$F9F4

$F9FA

$FA05

$FA0E

$FA12

$FA1C

$FA2E

$FA32

DESCRIPTION OF WHAT ROM ROUTINE DOES

Turn off drive motor by loading .A with the value of DRVCNT($1C00), ANDing it with $FB (to clear bit 2) and storing

the result back in DRVCNT.

Store $FF in CDRIVE ($3E) to indicate there is no currently active drive. Set DRVST ($20) to $0 to indicate that

the drive is switched OFF. Then branch

to END33X ($F9D6) to end IRQ routine. AND .A (contains drive status) with $40

to test if head must be moved. If the

result is 0 (no stepping needed) JMP to END33 ($FABE) to end the IRQ routine.

If stepping is required, do an indirect JMP via NXTST ($0062) to the proper head stepping routine:

SHORT - $FA3B - short step mode SETLE - $FA4E - settle head mode SSACL - $FA7B - accelerate mode

SSRUN - $FA97 - fast stepping mode

SSDEC - $FAA5 - decelerate mode

Set up to step the head:

Load .A with the number of steps to move the head from STEPS ($4A). If negative (>127), find the absolute value using

the 2's complement.

Compare the number of steps to the value (usually $C8)in MINSTP ($64) to see if the distance is big enough to use the fast stepping mode. If the distance is large enough, branch to INA20 ($FA1C). Not. big enough so set up the pointer in NXTST ($62/3) to point to the short step routine, SHORT ($FA3B) and branch to DOSTEP ($FA2E).

Calculate the number of steps to do in fast stepping mode by subtracting the

value in AS ($5E) from .A twice (for acceleration and deceleration). Store the result in RSTEPS ($61). Then move the number of steps needed for the head to accelerate from AS ($5E) to ACLSTP

($60). Finally set pointer in NXTST ($62/3) to point to the acceleration

mode routine SSACL ($FA7B)

Load value from STEPS ($4A). If positive (<127) , branch to STPIN ($FA63) to step

the head inwards.

Increment. STEPS ($4A) to reduce number left to do by 1, load .X with the value from DSKCNT ($1C00) decrement it by 1,

and branch to STP ($FA69).

423

-----------------------------------------------------Page 423-----------------------------------------------------
﻿
NAME

SHORT

SETLE

STPIN

STP

ADDRESS

$FA3B

$FA4E

$FA63

$FA69

DESCRIPTION OF WHAT ROM ROUTINE DOES

Short distance head stepping.

Load the number of steps left, to do from STEPS ($4A). If any left, branch to DOSTEP ($FA2E). If not, set NXTST

pointer($62/3) to point to the settle head routine SETLE ($FA4E) and store $05 in ACLSTP ($60) to set the settle time. Branch to END33 ($FABE) to end IRQ.

Settle head routine. Decrement. ACLSTP

($60) and if non-zero, brach to END33 ($FABE) to end IRQ. If zero, set. drive status, DRVST ($20), to indicate that the drive is available for use by

clearing bit 6. Set. NXTST pointer ($62/3) to point to the head inactive routine ($FA05) and branch to END33 ($FABE). Decrement STEPS ($4A) to reduce number left to do by 1, load .X with the value from DSKCNT ($1C00) and increment it by 1 Transfer the value in .X to .A (this is DSKCNT+1 for a step in and DSKCNT-1 for a step out), AND the value with $03, and store it in TMP ($4B). Load DSKCNT, AND it with $FC to mask off bits 0 & 1, OR it with TMP to set the new values for these bits, and store the result back in DSKCNT. JMP to END33 ($FABE) to end IRQ.

NOTE: cycling bits 0 & 1 of DSKCNT

($1C00) will move the head.

00/01/10/11/00 will move head in 00/11/10/01/00 will move head out

SSACL

SSA10

$FA7B

$FA88

$FA94

Accelerate head

Set. carry flag, latch T1HL2 ($1 in AF ($5F; ace

store the resul

hi counter). De

acceleration st

and if any step No steps left,

acceleration st

using the value NXTST pointer ( fast, stepping r

JMP to DOSTEP (

routine.

load the 6522 Timerl hi

C07), subtract the value eleration factor), and

t in T1HC2 ($1C05; timerl

crement the number of

eps left in ACLSTP ($60) s left, branch to SSA10.

so reset, the number of

eps left ACLSTP ($60)

in AS ($5E) and set. the $62/3) to point to the outine, SSRUN ($FA97). $FA2E)

SSRUN

$FA97

Fast, stepping mode routine.

Decrement, number of steps left to do in RSTEPS ($61). If any left, branch to DOSTEP ($FA2E). Since none left, set the

NXTST pointer ($62/3) to point to the

424

-----------------------------------------------------Page 424-----------------------------------------------------
﻿
NAME

SSDEC

END33

FORMT

ADDRESS

$FAA5

$FABE

$FAC7

DESCRIPTION OF WHAT ROM ROUTINE DOES

decelerate routine SSDEC ($FAA5) and branch to DOSTEP ($FA2E).

Decelerate head routine.

Load .A from the 6522 Timerl hi latch

T1HL2 ($1C07), clear the carry flag, add the acceleration factor AF ($5F), and store the result in T1HC2 ($1C05; timerl hi counter). Decrement the number of deceleration steps left ACLSTP ($60) and if any steps left, branch to SSA10. Since no steps left, set. the NXTST

pointer ($62/3) to point to the settle routine, SETLE ($FA4E). Set the number of acceleration steps left to $03 to allow settling time.

Terminate the motor and stepper control routine by clearing bit. 1 of the 6522's peripheral control register, PCR2($1C0C)

This force CA2 low which disables the

SO line to the 6502. Finally, do an RTS

to transfer control back to the main IRQ routine at. $FE7C.

This routine is used to format. (NEW) a diskette. The code is executed in place (rather than moved into RAM and then executed as in the 4040). The IP FORMAT

routine ($C8C6) sets up a JMP $FAC7 at the start of buffer #0, puts an EXECUTE ($E0) job into the job queue at $03, and then waits for the job to be completed.

FORMT

$FAC7

$FAD7

$FAE3

$FAE8

Load .A from FTNUM ($5 formatting has begun. formatting has begun s ($FAF5). If not, begin Setting DRVST($20) to stepping), storing $01

to set the current tra

($51; format begun fla Do BUMP to track 1 by

46 tracks. Store -92

STEPS ($4A) and clear DSKCNT ($1C00) to set. Set CNT ($0620) to $0A

10 errors before abort.

Set NUM($0621/2) to 40 first, guess at number

be recorded on half a Exit with a JMP to END

425

1) to check if If FTNUM>0, the

o branch to L213

formatting by:

$60 (head is now into DRVTRK ($22)

ck and into FTNUM

g) •

stepping head out 256-2*46) into

bits 0 & 1 of

head phase to 00.

to allow up to

00 ($0FA0) as a

of bytes that, can

track.

$F99C)

-----------------------------------------------------Page 425-----------------------------------------------------
﻿
NAME

L213

L214

TOPP

ADDRESS

$FAF5

$FB00

$FB0C

$FB0F

$FB12

DESCRIPTION OF WHAT ROM ROUTINE DOES

On re-entry .A holds the track number (loaded from FTNUM). Compare it to the track in HDRPNT($32). If they match, we

are on the correct track so branch to

L214 ($FB00). If different, put the .A value (track we want) into HDRPNT ($32) and exit with a JMP to END ($F99C). Test, bit 4 of DSKCNT ($1C00) to see if

write protect, is on. If 1, protect, is

not on so branch to TOPP ($FB0C). If 0, load .A with $08 to indicate a WRITE PROTECT error & JMP to FMTERR ($FDD3). JSR to SYNCLR ($FDA3) to erase the track by writing 28*256 SYNC marks.

JSR to WRTNUM ($FDC3) to write out NUM ($0621/22; value = 4000) SYNC marks. Store a non-sync character ($55) into the output port. DATA2 ($1C01) and JSR to WRTNUM ($FDC3) to write NUM ($0621/2; value = 4000) non-sync bytes.

At this point the track will have one

area that contains SYNC and another area

that, has non-sync characters like this:

1111111100110011001100110011001111111

SYNC 4000 non-sync bytes SYNC

The following routines time the SYNC and non-sync segments to determine how many

characters can be written on the track.

This is used to calculate the length of the gap between sectors (inter-sector).

$FB1A $FB1D

$FB20

JSR to KILL ($FE0 JSR to SYNC ($F55 start of the SYNC Set. bit 6 of the

set it up as a fr

second timer.

0) to kill write mode. 6) to wait, for the

section.

6522's ACR1 ($180B) to ee running 100 micro-

$FB35

Set. .X and .Y to

$00. Th.

ay will hold the

FWAIT

FWAIT2

$FB39 $FB3E

timer count. .X=l

.Y=most significa Loop to wait for Loop to wait for

east si<

gnificant byte

nt bit

SYNC area

not-sync area

F000

$FB43

Reset interrupt f

lags to

start the timer

F001
 $FB46

Loop to time the

Check if SYNC her to F005 ($FB5C). IFR1 ($1804) to s

out. If time not

F001 ($FB46). If .X by 1 (and .Y i to F000 ($FB43) t .Y is 0, we have

non-sync area.

If here, branch

e yet.

If no SYNC yet, check

ee if t

imer has timed branch back to

up yet,

time is

up, increment

f .X=0)

and branch back the timer. If

o reset

of 65535 which

a count

426

-----------------------------------------------------Page 426-----------------------------------------------------
﻿
NAME

F005

F006 F007

F009

COUNT

CNT10

CNT20

DS08

MAK10

ADDRESS

$FB5C

$FB64 $FB67

$FB7D

$FBB6

$FBBB

$FBCE

$FBE0

$FC36 $FC3F

DESCRIPTION OF WHAT ROM ROUTINE DOES

means we can't find a sync mark so abort. by loading .A with $02 and JMP to FMTERR Found a SYNC so store the non-sync times in T2 ($71/2) . Reset .X and .Y to $00

and begin timing the SYNC area.

Reset interrupt flags to start the timer Loop to time the SYNC area:

Check if not-sync here yet. If here, go to F009 ($FB7D). If still have a SYNC, check IFR1 ($1804) to see if timer has timed out. If not time yet, branch back to F007 ($FB67). If time up, increment .X by 1 (and .Y if .X=0) and loop back to F006 ($FB64) to reset the timer. If .Y is 0, we have a count of 65535 which

means we can't find no-SYNC. So abort: load .A with a $02 and JMP to FMTERR

Found non-sync. Calculate the difference between the SYNC and non-sync times. If the difference is less than 4, branch to COUNT ($FBB6). If the difference is more than 4, make NUM ($0261/2) the average

of the two times and branch to TOPP

($FB0C) to try again.

Set .X and .Y to $00 to prepare to count the number of characters in the non-sync

area.

Test, bit 7 of DSKCNT ($1C00) to see if SYNC is here yet. If SYNC here, branch to CNT20 ($FBCE). If not, test the timer If not time, branch back to CNT10. If time for one character is up, increment •X (and .Y if needed), clear the timer flag (.V) and branch back to CNT10. If

.Y=0 we have a count, of 65535 so abort:

load .A with $03 & JMP to FMTERR ($FDD3) Store the byte count (count*2) in TRAL ($0624/5) and turn off the 6522's timer Calculate the total number of bytes we

need to record on this track:

(282 chr/sect x 5/4 x #sect)

Subtract, this from the total we found

and divide by the number of sectors to get the size of the gap between sectors. If the calculated gap is less than 4, it-

is too small so load .A with $05 and JMP to FMTERR ($FDD3). If it is big enough, store inter-sector gap in DTRCK ($0626).

Set sector counter SECT ($0628) to $00.

Loop to create sector header images in buffer 0 ($0300+) .Y is the pointer

into the buffer (0 for sect. #1).

427

-----------------------------------------------------Page 427-----------------------------------------------------
﻿
NAME

ADDRESS
 DESCRIPTION OF WHAT ROM ROUTINE DOES

$FC3F

$FC44

$FC4C

$FC52

$FC58

$FC5E

$FC64

$FC68

$FC7A

$FC84

Move sector ID code fr

$0300+Y ($0300 for #1)

Increment .Y twice to and move sector number

to $0300+Y ($0302 for

Increment. .Y and move

from FTNUM ($51) to $0 sector #1)

Increment. .Y and move

($13) to $0300+Y ($030

Increment. .Y and move

($12) to $0300+Y ($030

Increment .Y and store

($0306 for #1) as off

Increment .Y and store

($0307 for #1) as off Increment .Y, calculat checksum and store it

($0302 for sector #1) Increment SECT ($0628)

number of sectors on t

If done all images, sa

sectors on this track Increment .X (becomes

it to .A (dummy data c

om HBID ($39) to

skip the checksum from SECT ($0628)

sector #1).

the track number

300+Y ($0303 for

ID2 from DSKID+1

4 for sector #1).

ID1 from DSKID

5 for sector #1).

$0F in $0300+Y

byte.

$0F in $0300+Y

byte.

e the header blk

in $02F9+Y

and compare it to rack SECTR ($43)

ve the number of onto the stack.

$01) and transfer haracter).

CRTDAT

$FC86

$FC8E

$FC95

$FC9E

NOTE: .X should really be $00. Since it

is $01, all the data blocks on a diskette formatted on a 1541 drive have 1 garbage character followed by 255 $01's rather than 256 $00's

Loop to put. 255 dummy data bytes ($01's) into data buffer #2 ($0500+)

Set. the buffer pointer BUFPNT ($30/1) to point, to the header block images ($0300) and JSR to FBTOG($FE30) to convert the header images to a GCR write image with

no header block ID code.

Pull # of sectors from stack, transfer the value to .Y, and JSR to MOVUP($FDE5) to move the GCR header image stored in in buffer #0 69 bytes up in memory. Then JSR to MOVOVR ($FDF5) to move the 69 header image bytes from the overflow

buffer into the low end of buffer #0.

Set the buffer pointer BUFPNT ($30/1) to point, to the dummy data block, JSR to CHKBLK($F5E9) to calculate the data blk checksum, store it in CHKSUM, and JSR to BINGCR($F78F) to convert, the dummy data block into its GCR write image.

428

-----------------------------------------------------Page 428-----------------------------------------------------
﻿
NAME

WRTSYN

WRTS10

WRTS20

WRTS30

DBSYNC

WRTS40

WRTS50

WGP2

COMP

ADDRESS

$FCAA

$FCAE $FCB1

$FCB8 $FCBE

$FCC2 $FCCF

$FCD1

$FCDC

$FCE0 $FCE9

$FCEB

$FCF9

$FD04

$FD09

$FD12

$FD19

$FD27

$FD2C

DESCRIPTION OF WHAT ROM ROUTINE DOES

Begin formatting the track now!

Set the pointer to the header GCR image HDRPNT ($32) to $00 so it points to the start of the first header image.

JSR to CLEAR ($FE0E) to wipe the track. Store $FF in PORT2 ($1C01) to be ready to write a sync character. Load .X with $05 (5 SYNC's coming up!) Write out 5 sync marks

Initialize .X to $0A (output 10 bytes)

and set .Y with the value from HDRPNT

($32) so it points to the start, of the

header GCR image.

Write out the 10 header characters

Load .X With $08 (HARD SET VALUE!)

NOTE: This means you can not easily

change the header gap size!

Loop to output eight $55 bytes to form the header gap (gapl).

Store $FF in PORT2 ($1C01) to be ready to write a sync mark. Load .X with $05

(5 SYNC's coming up!) Write out 5 sync marks

Initialize .X to $BB to point to the first byte of the overflow buffer (the start of the dummy data block)

Loop to write out the 69 GCR bytes in

the overflow buffer

Loop to write out the 256 GCR bytes in data buffer #2 ($0500+)

Load .A with $55 and .X with the tail (inter-sector) gap from DTRCK ($0626) Loop to write .X $55 characters to form the tail (inter-sector) gap.

Advance the header pointer HDRPNT($32/3) by 10 so it points to the start of the next header image.

Decrement, the sector counter SECT ($0628) by 1 and test to see if any more sectors to do. If more, branch back to WRTSYN to do the next, sector. If no more, wait. for the last byte to be written out and

then JSR to KILL ($FE00) to switch to

read mode.

Formatting done. Verify it!

Set TRYS ($0623) to $C8 to limit, the number of attempts to verify to 200.

Set BUFPNT ($30/1) to point to the start

of the headers in buffer #0 ($0300) and set SECT ($0628) with the # of sectors on this track from SECTR ($43).

429

-----------------------------------------------------Page 429-----------------------------------------------------
﻿
NAME

ADDRESS

DESCRIPTION OF WHAT ROM ROUTINE DOES

CMPR10 I $FD39

JSR to SYNC($F556) to wait, for a SYNC mark. Once found, set .X to $0A (there are 9 header characters to read) and .Y

$00 (point to character in header image)

CMPR15

CMPR20

TSTDAT

TST05

TST10

FMTEND

SYNCLR

$FD40

$FD4E

$FD55

$FD58

$FD62

$FD67

$FD75

$FD77

$FD86

$FD96

$FDA3

Loop to read header bytes and compare them to the image in the buffer. If any byte doesn't, match, branch to CMPR20.

Header reads back OK so add 10 to BUFPNT

($30) so it points to next header image.

JMP to TSTDAT ($FD62)

Bad verify. Decrement TRYS ($0623). If more attempts left, branch back to COMP ($FD2C) to try again. If we have tried 200 times, abort: load .A with $06 and JMP to FMTERR ($FDD3)

Header OK so check the data block.

JSR to SYNC ($F556) to wait for the data block SYNC mark. Once found, set .Y to

$BB to point to the start of the data block image in the overflow buffer

Loop to read and verify the 69 GCR bytes in the overflow buffer. If no match, branch to CMPR20 ($FD58) and try again.

Overflow buffer OK so set .X to $FC

(255-3; don't bother checking the OFF

bytes at the end).

Loop to read and verify the 253 GCR bytes in data buffer #3. If no match, branch to CMPR20 ($FD58) and try again.

Decrement the sector counter in SECT

($0628) by 1 and test to see if any more

to do. If more, branch back to CMPR10 to do next, sector. If no more, increment the track counter FTNUM ($51) and test if there are any more tracks to do. If all done, branch to FMTEND ($FD96). If more to do, JMP to END ($F99C) to step

the head to the next, track.

Set the track counter, FTNUM ($51) to

$FF and the GCRFLG ($50) to 0. To flag a successful completion load .A with $01

and JMP to ERRR ($F969).

Formatting and Verification Completed!

Formatting Subroutines

Wipe track by writing 40*256 SYNC marks Set. bits 6 & 7 of the 6522's peripheral control register PCR2 ($1C0C). This latches the signal on the CB2 line.

430

-----------------------------------------------------Page 430-----------------------------------------------------
﻿
NAME

SYC10

WRTNUM

WRTN10

FMTERR

FMTE10

MOVUP

MOVOVR

KILL

CLEAR

ADDRESS

$FDAD

$FDB5

$FDB9

$FDC2

$FDC3

$FDC9

$FDD2

$FDD3

$FDDB

$FDE5

$FDEE

$FDF5 $FDF7

$FE00

$FE0E

$FE18

$FE22

DESCRIPTION OF WHAT ROM ROUTINE DOES

Store $FF in the data direction register DDRA2 ($1C03) to make PORT A an output. port and put $FF in the data port DATA2

($1C01) to produce SYNC characters. Initialize .X to $28 (hi counter) and .Y to $00 (lo counter).

Loop to write out 40*256 SYNC marks using .X & .Y as counters

RTS -*- WARNING WRITE MODE LEFT ON -*-

Write out. NUM ($0621/2) bytes

Load .X with the LSB and .Y with the

MSB of NUM ($0621/2).

Loop to write out what ever is in the data port DATA2 ($1C03) NUM times using

.X and .Y as counters

RTS

Handles format errors

Decrement, the retry counter CNT ($0620) and, if no tries left, branch to FMTE10.

If any left, JMP to END($F99C) to do any stepping required and try again.

Set. the track counter FTNUM~($51) to $FF

and the GCRFLG ($50) to 0 and JMP to ERRR ($F969).

Move .Y bytes in buffer #0 up 6 9 bytes Loop to move .Y characters in buffer #0 ($0300+) up 69 memory locations in RAM.

Move byte from $0300 to $0345. RTS

Move 69 bytes from overflow buffer into the bottom of the data buffer pointed to by BUFPNT ($30/1)

Load .Y with $44 (68)

Loop to move 69 bytes from $01BB+ into

the data buffer. RTS

Disable write mode

Set bits 5, 6 and 7 of the 6522's PCR2 ($1C0C) to set CB2 high. Store 0 in the data direction register DDRA2 ($1C03) to make PORT A an input port. RTS

Wipe track with non-sync characters Clear (zero) bit 5 of the 6522's PCR2

($1C0C). This forces CB2 low.

Store $FF in the data direction register DDRA2 ($1C03) to set. output mode and put $55 in the data port DATA2 ($1C01) to write non-sync characters.

Initialize .X to $28 (hi counter) and .Y to $00 (lo counter).

431

-----------------------------------------------------Page 431-----------------------------------------------------
﻿
NAME

CLER10

FBTOG

FBG10

ADDRESS

$FE26

$FE2F

$FE30

$FE30

$FE38

$FE3C

$FE44

DESCRIPTION OF WHAT ROM ROUTINE DOES

Loop to write out. 40*256 non-sync

characters using .X & .Y as counters.

RTS -*- WARNING WRITE MODE LEFT ON -*-

Convert header images in buffer #0 into

GCR form without the header ID code.

Zero the low byte of the buffer pointers pointers BUFPNT($31) and SAVPNT ($2E) and the byte counter BYTCNT ($36) .

Set the GCR pointer GCRPNT ($34) to $BB so it points to the first character in the overflow buffer ($01BB+).

Save the hi byte of the buffer pointer

BUFPNT ($31) into SAVPNT ($2F) and then

set BUFPNT to $01 to point to the over¬

flow buffer.

Loop to move 4 bytes at a time into the

staging area $52-55 and then do a JSR to PUT4BG ($F6D0) to convert them into five GCR bytes and store them in the

overflow or data buffer. Terminate the routine with a JMP to PUT4BG to convert and store the last. four.

MAIN SYSTEM IRQ ROUTINE (IRQ VECTOR POINTS HERE)

SYSIRQ

IRQ10

IRQ2 0

$FE67

$FE67 $FE6C

$FE76

$FE7F

IRQ's are generated in two ways: 1) by an ATN signal from the VIC-20 or the C-64 on the serial bus, or 2) by a time out of the 6522's timer This happens every 10 milliseconds

This routine tests for the source of the

IRQ signal and branches to the correct.

ROM routine.

Save .A, .X, and .Y on the stack

Test if IRQ caused by an ATN signal on the serial bus by checking bit. 1 of the interrupt flag register of the 6522 that handles the bus IFR1 ($180D). If this bit is not. set (1), there was no ATN signal so branch to IRQ10 ($FE76). If it is set, JMP to the bus handling routine

ATNIRQ ($E85F).

Test if the 652 2 timer has timed out by testing bit. 7 of the interrupt flag register of the 6522 that serves as a disk controller IFR2 ($1C0D). If the bit is not set, branch to IRQ20 ($FE7F). If

it. is set, do a JSR to the floppy disk

controller routines, LCC($F2B0).

Pull .A, .X, and .Y from the stack and

do an RTI.

432

-----------------------------------------------------Page 432-----------------------------------------------------
﻿
ADDRESS

$FE85 $FE86 $FE87 $FE88

$FE89 $FE8A $FE8B $FE8C $FE8D $FE8E $FE8F $FE90 $FE91 $FE92 $FE93 $FE94

VALUE

$12 $04 $04 $90

$56 $49 $44 $4D $42 $55 $50 $26 $43 $52 $53 $4E

MISCELLANEOUS CONSTANTS & TABLES IN ROM

Directory track number (18) Number of bytes/track in BAM

Offset, of BAM in the sector

Offset of disk name in BAM sector

Command Search Table

V = Validate or collect, disk

I = Initialize BAM & directory

D = Duplicate or backup disk (N.A.) M = Memory operation (M-R,M-W,M-E) B = Block operation (B-R,B-A,B-W,etc) U = User jump commands (except. U+ & U-)

P = Position (for REL files)

& = Utility loader

C = Copy file (copy disk N.A. on 1541)

R = Rename file S = Scratch file

N = New or format a diskette

(Lo E iyte)

(Hi Byte) Command Jump Table

$FE95 $FE96 $FE97 $FE98 $FE99 $FE9A $FE9B $FE9C $FE9D $FE9E $FE9F $FEA0

$84 $05 $C1 $F8 $1B $5C $07 $A3 $F0 $88 $23 $0D
 $FEA1 $FEA2 $FEA3 $FEA4 $FEA5 $FEA6 $FEA7 $FEA8 $FEA9 $FEAA $FEAB $FEAC
 $ED $D0 $C8 $CA $CC $CB $E2 $E7 $C8 $CA $C8 $EE

V = Validate

I = Initialize BAM

D = Duplicate (N.A.) M = Memory operation B = Block operation

U = User jump commands

P = Position (for REL) & = Utility loader C = Copy file

R = Rename file S = Scratch file

N = New a diskette

$FEAD $FEAE $FEAF $FEB0

$51 $DD $1C $9E

STRUCTURE IMAGES FOR COMMANDS

%01010001 disk copy

%11011101 rename a file (not parsed) %00011100 scratch a file (not parsed) %10011110 new a diskette (not. parsed)

$FE31

$1C

%00011100 loac

a a file

$FEB2 $FEB3 $FEB4 $FEB5

$52 $57 $41 $4D

t greater than one file

PGDRPGDR No

FS1 FS2 Not default drive(s)

Required filename

MODE TABLE (R/W/A/M)

R = Read mode W = Write mode

A = Append

M = Modify (read improperly closed file)

433

-----------------------------------------------------Page 433-----------------------------------------------------
﻿
ADDRESS

VALUE

MISCELLANEOUS CONSTANTS & TABLES IN ROM

(1st Byte)
 (Hi Byte) File type table

$FEB6 $FEB7 $FEB8 $FEB9 $FEBA

$44 $53 $50 $55 $4C

D

S P U L

$FEBB $FEBC $FEBD $FEBE $FEBF
 $44 $53 $50 $55 $52
 $FEC0 $FEC1 $FEC2 $FEC3 $FEC4
 $45 $45 $52 $53 $45
 $FEC5 $FEC6 $FEC7 $FEC8 $FEC9

$4C $51 $47 $52 $4C

L

Q

G R L

DEL

SEQ

PRG USR REL

$FECA $FECB

$08 $00

LED mask for drive 0 LED mask for drive 1

(N.A. on 1541)

ERROR FLAG VARIABLES FOR USE BY BIT

$FECC $FECD $FECE $FECF $FED0

$00 $3F $7F $BF $FF

ER00 ERO ER1 ER2 ER3

NUMBER OF SECTORS/TRACK IN EACH ZONE

$FED1
 $11

17 sectors/track
 in

zone

4
 (31-

-35)

$FED2

$12

18 sectors/track
 in

zone

3
 (25-

-30)

$FED3

$13
 19 sectors/track
 in

zone

2

(18-

-24)

$FED4

$15

21 sectors/track

in

zone

1

(01-

-17)

$FED5 $FED6

$41 $04

DOS version number (65)

Number of different, zones

ZONE BOUNDARIES (HIGHEST TRACK # + 1)

$FED7 $FED8 $FED9 $FEDA

$24 $1F $19 $12

Track Track Track Track

#36 #31 #25 #18

end of zone 4 (31-35) end of zone 3 (25-30) end of zone 2 (18-24) end of zone 1 (01-17)

$FEDB $FEDC $FEDD $FEDE $FEDF

OFFSETS FOR ERROR RECOVERY

$01 $FF $FF $01 $00

HI BYTE OF POINTERS TO DATA BUFFERS

$FEE0
 $03

Data

buffer
 #0

($0300-

-03FF)

$FEE1

$04

Data

buffer

#1
 ($0400-

-04FF)

$FEE2

$05

Data

buffer

#2
 ($0500-

-05FF)

$FEE3

$06

Data

buffer
 #3

($0600-

-06FF)

$FEE4

$07

Data

buffer

#4
 ($0700-
 -07FF)

$FEE5

$07

Data

buffer
 #5

($0700-

-07FF)

$FEE6

$FD

Checksum for $E and $F ROMs

434

-----------------------------------------------------Page 434-----------------------------------------------------
﻿
ADDRESS

VALUE

MISCELLANEOUS CONSTANTS & TABLES IN ROM

NMI VECTOR POINTS HERE

$FEE7

NMI Do indirect jump to the address stored

in VNMI ($0065). This vector points to XXXXXX ($XXXX)

PATCH FOR POWER-ON ERRORS

$FEEA

PEA7A

Store the value that is in .A on entry

into the 6 522's data port 2, LEDPRT ($1C00; also called DSKCNT) and in the data direction register, LEDOUT ($1C02; also called DDRB2). Exit with a JMP to REA7D ($EA7D) to return to the LED blink

routine.

PATCH FOR 1541 DISK WITH SLOW SERIAL RECEIVE

$FEF3

SLOWD

Produce a 40 microseconds delay with a loop that counts .X down from 5 to 1.

Exit, with an RTS.

$FEFB $FEFE

JSR $E9AE JMP $E99C

unused junk unused junk

PATCH TO NMI ROUTINE TO CHECK FOR U+ AND U- COMMANDS

$FF01

$FF0D

NNMI

NNMI10

Load .A with the second character in the

command buffer CMDBUF + 2 ($0202) . Compare it with "-" and, if equal, branch to NNMI10 ($FF0D). If not a "-", subtract a " + " from it. If not zero, command must.

be a real Ul command so branch back to

NMI ($FEE7) to do normal NMI.

Store .A (contains zero or a "-") into

DRVTRK+1 ($23) and do an RTS to continue

$FF10 - $FFE6 UNUSED GARBAGE

TABLE OF JUMP VECTORS TO ROUTINES (LO BYTE/HI BYTE)

$FFE6 $FFE8 $FFEA $FFEC $FFEE $FFF0 $FFF2 $FFF4 $FFF6 $FFF8 $FFFA $FFFC $FFFE

$C6/$C8 $8F/$F9 $5F/$CD $97/$CD $00/$05 $03/$05 $06/$05 $09/$05 $0C/$05 $0F/$05 $01/$FF $A0/$EA $67/$FE

FORMAT ROM routine TRNOFF ROM routine UBLKRD ROM routine UBLKWT ROM routine Link to buffer #2 Link to buffer #2 Link to buffer #2 Link to buffer #2 Link to buffer #2 Link to buffer #2 NNMI ROM routine

DSKINT ROM routine

SYSIRQ ROM routine

$C8C6 $F98F $CD5F $CD97 $0500 $0503 $0506 $0509 $050C $050F $FF01 $EAA0 $FE67

435

-----------------------------------------------------Page 435-----------------------------------------------------
﻿

-----------------------------------------------------Page 436-----------------------------------------------------
﻿
APPENDIX C

PROGRAM LISTINGS

437

-----------------------------------------------------Page 437-----------------------------------------------------
﻿

-----------------------------------------------------Page 438-----------------------------------------------------
﻿
NOTE: Lines 830 and 930 contain a special character #166. This character can be typed by holding down the Commodore logo key in the lower left corner and pressing the + key.

lOO REM DISPLAY A BLOCK AVAILABILITY MAP

- 1541

110 DIMN*<16)

120 DEFFNS (I) =2'v (S-INT (S/8) *8) AND <B (INT (

S/8>>)

130 PRINT"{CLR*DISPLAY A BAM - 1541"

140 PRINT"<DOWN>INSERT DISKETTE IN DRIVE

II

150 PRINT"{DOWN>PRESS <RVS>RETURN{ROFF*

TO CONTINUE"

160 GETC*:IFC*=""THEN160 170 IFC*OCHR*<13)G0T0160 180 PRINT"OK"

190 0PEN15,8,15

200 PRINT#15,"10"

210 INPUT#15,EN*,EM*,ET*,ES*

220 IFEN*="00"OREN*="22"OREN*="23"G0T026

O

230 PRINT"<DOWN>"EN*", "EM*","ET*","ES*

240 CLOSE15 250 END

260 0PEN2,8,2,"#"

270 PRINT#15,"Ui";2;0;l8;o 280 INPUT#15,EN*,EM*,ET*,ES*

290 REM GET DOS

300 PRINT#15,"B-P";2;2 310 GET#2,B*

320 IFB*=""THENB*=CHR*(O) 330 DOS=ASC(B*)

340 IFD0S=65THEND0S*="V2.6":G0T0380 350 IFDOS=1THENDOS*="V1.2":G0T0380 360 DOS*="V?.?"

370 REM GET BLOCKS FREE 380 BF=0 390 B=4

400 F0RI=1T035

410 IFI=18THENI=I+l:B=B+4 420 PRINT#15,"B-P";2;B 430 GET#2,B*

440 1FB*=""THENB*=CHR*(O) 450 A=ASC(B*> 460 BF=BF+A 470 B=B+4 480 NEXTI

490 REM GET DISK NAME

439

-----------------------------------------------------Page 439-----------------------------------------------------
﻿
500 PRINT#15,"B-P";2;144

510 F0RI=1T016 520 GOSUB1140

530 N*(I>=CHR*(A) 540 NEXTI

550 REM GET COSMETIC ID 560 ID*=""

570 PRINT#15,"B-P";2;162

580 F0RI=1T02 590 GOSUB1140

600 ID*=ID*+CHR*(A> 610 NEXTI

620 PRINT"{CLRD CRVS3-TRACK{ROFF> 11 111111112222222222333333"

630 PRINT" 123456789012345678901234567 89012345"

640 PRINT"{RVS}S<:ROFF}0

"N*(l>;

650 PRINT"{RVS3ECROFF31

mn*(2);

660 PRINT"<RVS}C{R0FF>2

"N*<3>;

670 PRINT"{RVS}T{R0FF}3

"N*(4);

680 PRINT" {RVS>0<:R0FF}4

"N*(5);

690 PRINT"<RVS}R<R0FF}5

"N*(6);

700 PRINT" 6

"N*<7>;

710 PRINT" 7

"N*(8);

720 PRINT" 8

"N*(9)j

730 PRINT" 9

"N*(10);

740 PRINT"10

"N*(11);

750 PRINT"11

"N*(12>;

760 PRINT"12

"N*<13>;

770 PRINT"13

"N*(14);

780 PRINT"14

"N*(15);

790 PRINT"15

"N*<16>;

800 PRINT"16" 810 PRINT"17"

440

-----------------------------------------------------Page 440-----------------------------------------------------
﻿
820 PRINT"18

"jDOS*;" ";LEFT*(ID*,1);

830 PRINT"19 {R

VS> {R0FF}0R{#166}=EMPTY "; RIGHT* (ID*, 1)

840 PRINT"20 ";

850 BF*=RIGHT*(" "+RIGHT*(STR*(BF),LEN( STR*(BF))-l>,3>

860 IFBF=1THENPRINT" ";BF*;" BLOCK FREE"

:G0T0880

870 PRINTBF*;" BLOCKS FREE"

880 A*="."

890 CR*="BRIGHT 35}"

900 PRINT#15,"B-P";2;4

910 F0RT=1T035

920 IFT/2<>INT(T/2)THENF*="{RVS} {ROFF}" :G0TO94O

930 F*="{#166}" 940 GET#2,B*

950 F0RI=0T02

960 GET#2,B*

970 IFB*=""THENB*=CHR*(0) 980 B(I)=ASC(B*) 990 NEXTI

lOOO PRINT"{HOME*CDOWN 2}{RIGHT 2}";LEFT

*(CR*,T);

1010 NS=20+2*(T>17)+(T>24)+(T>30) 1020 FORS=OTONS

1030 IFFNS(S)=OTHENPRINTA*;:GOTO1050 1040 PRINTF*;

1050 PRINT"{DOWN}{LEFT}"; 1060 NEXTS 1070 NEXTT

1080 PRINT"{HOME}{DOWN 22}";

1090 CL0SE2

1100 INPUT#15,EN*,EM*,ET*,ES*

1110 CLOSE15 1120 END

1130 REM GET A BYTE

1140 GET#2,B*

1150 IFB*=""THENB*=CHR*(O) 1160 A=ASC(B*)

1170 IFA >127THENA=A-128 1180 IFA< 320RA >95THENA=63 1190 IFA=34THENA=63 1200 RETURN

441

-----------------------------------------------------Page 441-----------------------------------------------------
﻿

-----------------------------------------------------Page 442-----------------------------------------------------
﻿
100 REM VIRTUAL DIRECTORY - 1541 HO CLR

120 H*="0123456789ABCDEF" 130 FORI=OT05 140 READFT*(I> 150 NEXTI

160 PRINT"{CLR3VIRTUAL DIRECTORY - 1541"

170 PRINT"{DOWN}INSERT DISKETTE IN DRIVE

180 PRINT"{DOWN}PRESS {RVS}RETURN{ROFF}

TO CONTINUE"

190 GETC*:IFC*=""THEN190 200 IFC*< >CHR*(13)GOTO190 210 PRINT"OK"

220 0PEN15,8,15

230 PRINT#15,"10"

240 INPUT#15,EN*,EM*,ET*,ES*

250 IFEN*="00"G0T030O

260 PRINT"{DOWN}"EN*", "EM*","ET*","ES*

270 CLOSE15 280 END

290 REM FORMATTING ID

300 PRINT#15,"M-R"CHR*(22)CHR*(O)CHR*(2)

310 GET#15,B*

320 GOSUB1370

330 FI*=FI*+CHR*(A)

340 GET#15,B*

350 GOSUB1370

360 FI*=FI*+CHR*(A) 370 REM BLOCKS FREE

380 PRINT#15,"M-R"CHR*(250)CHR*(2)CHR*(3

)

390 GET#15,B*

400 L=ASC(B*+CHR*(O))

410 GET#15,B* 420 GET#15,B*

430 H=ASC(B*+CHR*(0)) 440 BF=L+(H*256) 450 BA=664-BF

460 OPEN4,3

470 0PEN2,8,2,"#"

480 0PEN3,8,3,"*0,P,R" 490 GET#3,B*

500 DOS=ASC(B*+CHR*(O)) 510 F0RI=3T0143

520 GET#3,B*

530 NEXTI

540 F0RI=144T0159

443

-----------------------------------------------------Page 443-----------------------------------------------------
﻿
550 GOSUB1360

560 DN*=DN*+CHR*(A) 570 NEXTI

580 GET#3,B* 590 GET#3,B*

600 F0RI=162T0163 61O GOSUB1360

620 ID*=ID*+CHR*(A) 630 NEXTI

640 F0RI=164T0255

650 GET#3,B*

660 NEXTI

670 F0RI=1T06 680 PRINT#4 690 NEXTI

700 PRINT#4,"DISK NAME: "DN* 710 PRINT#4,"DISK ID: "ID* 720 PRINT#4,"FORMATTING ID: "FI* 730 PRINT#4,"DOS TYPE: "DOS 740 PRINT#4,"BL0CKS ALLOCATED:"BA 750 PRINT#4,"BLOCKS FREE: "BF

760 PRINT#4

770 PRINT#4."BLOCKS FILE NAME TYP E T-S LOAD"

780 IFF/8=INT(F/8)THENPRINT#4

790 GET#3,B*

800 FT=ASC(B*+CHR*(O)) 810 FT*=FT*(7ANDFT)

820 GET#3,B*

830 T=ASC(B*+CHR*(O))

840 T*=RIGHT*("0"+RIGHT*(STR*(T),LEN(STR *(T))-1),2)

850 GET#3,B*

860 S=ASC(B*+CHR*(O)>

870 S*=RIGHT*("O"+RIGHT*(STR*(S),LEN(STR *(S))-1),2)

880 LA*=""

890 IF(7ANDFT)< >OAND(7ANDFT)<>2G0T01020

900 print#15,"U1";2;o;t;s 910 PRINT#15,"B-P";2;2 920 GET#2,B*

930 A=ASC(B*+CHR*(0)) 940 H=INT(A/16) 950 L=A-16*H

960 LA*=MID*(H*,H+1,1)+MID*(H*,L+1,1)

970 GET#2,B*

980 A=ASC(B*+CHR*(O)) 990 H=INT(A/16)

1000 L=A-16*H

1010 LA*=MID*(H*,H+l,1)+MID*(H*,L+l,1)+L

444

-----------------------------------------------------Page 444-----------------------------------------------------
﻿
A*

1020 F*="M

1030 NULL=0

1040 FORI=lT016 1050 GOSUB1360

1060 IFB*=CHR*(0)THENNULL=NULL+1 1070 F*=F*+CHR*(A) 1080 NEXTI

1090 IFNULL=16G0T01270 1100 F0RI=1T09

1110 GET#3,B*

1120 NEXTI

1130 GET#3,B*

1140 B=ASC(B*+CHR*(0))

1150 GET#3,B*

1160 B=B+256*ASC(B*+CHR*(O))

1170 B*=RIGHT*(" "+RIGHT*(STR*(B),LEN(S TR*(B))-l),3)

1180 IFST=64THENEOI=l

1190 IFFT<128THENPRINT#4,"{RVS}"j

1200 PRINT#4," "B*" "F*" "FT*" "T*"-"

S*" "LA*

1210 F=F+1

1220 IFF/8< >INT(F/8)THENGET#3,B*:GET#3,B

*

1230 GETC*:IFC*=""GOT01250 1240 GETC*:IFC*=""THEN1240 1250 IFE0I=1G0T01270 1260 G0T0780 1270 CL0SE4 1280 CLOSE3 1290 CL0SE2

1300 INPUT#15,EN*,EM*,ET*,ES*

1310 CL0SE15 1320 END

1330 REM FILE TYPES

1340 DATA DEL,SEQ,PRG,USR,REL,???

1350 REM GET A BYTE

1360 GET#3,B*

1370 IFB*=""THENB*=CHR*(O) 1380 A=ASC(B*)

1390 IFA>127THENA=A-128 1400 IFA<320RA>95THENA=63 1410 IFA=34THENA=63 1420 RETURN

445

-----------------------------------------------------Page 445-----------------------------------------------------
﻿

-----------------------------------------------------Page 446-----------------------------------------------------
﻿
100 REM FIND A FILE

110 PRINT"{CLR}FIND A FILE - 1541"

120 PRINT"{DOWN}INSERT DISKETTE IN DRIVE

• I

130 PRINT"{DOWN}PRESS {RVS}RETURN{ROFF}

TO CONTINUE"

140 GETC*:IFC*=""THEN140 150 IFC*OCHR*(13)G0T0140 160 PRINT"OK"

170 0PEN15,8,15

180 PRINT#15,"10"

190 INPUT#15,EN*,EM*,ET*,ES*

200 IFEN*="0O"G0T024O

210 PRINT"{DOWN}"EN*", "EM*","ET*","ES*

220 CLOSE15 230 END

240 INPUT"{DOWN}FILENAME";F*

250 IFLEN(F*)< >OANDLEN(F* X17G0T0280

260 CLOSE15 270 END

280 0PEN2,8,2."0:"+F*+",?,R" 290 INPUT#15,EN*,EM*,ET*,ES*

300 IFEN*="00"G0T0320 310 G0T0530

320 PRINT#15,"M-R"CHR*(97)CHR*(2) 330 GET#15,D*

340 D=ASC(D*+CHR*(O))

350 PRINT#15,"M-R"CHR*(24)CHR*(O)CHR*(2)

360 GET#15,T*

370 T=ASC(T*+CHR*(0>) 380 GET#15,S*

390 S=ASC(S*+CHR*(0)>

400 D*=RIGHT*(STR*(D),LEN(STR*(D))-1)

410 IFD<10THEND*="0"+D*

420 T*=RIGHT*(STR*(T),LEN(STR*(T))-l)

430 IFT<1OTHENT*="O"+T*

440 S*=RIGHT*(STR*(S),LEN(STR*(S))-1)

450 IFS<1OTHENS*="O"+S*

460 PRINT"{DOWN}TRACK 18 - SECTOR "D* 470 PRINT"{DOWN}TRACK "T*" - SECTOR "S* 480 CL0SE2

490 INPUT#15,EN*,EM*,ET*,ES*

500 CLOSE15

510 PRINT"{DOWN}DONE!" 520 END

530 PRINT"{DOWN}"EN*", "EM*","ET*","ES*

540 CL0SE2

550 INPUT#15,EN*,EM*,ET*,ES*

560 CLOSE15

570 PRINT"{DOWN}{RVS}FAILED{ROFF}" 580 END

447

-----------------------------------------------------Page 447-----------------------------------------------------
﻿
100 REM DISPLAY TRACK «< SECTOR - 1541 110 CLR

120 HD*="0123456789ABCDEF"

130 PRINT"{CLR}DISPLAY TRACK & SECTOR - 1541"

140 PRINT"{DOWN}INSERT DISKETTE IN DRIVE

ii

150 INPUT"{DOWN}DISPLAY TRACK & SECTOR (

T,S)";T,S

160 IFT<10RT>35THENEND

170 180 190 TER 200 210

;q*

220 230 240 250 260 270 280 290 300 310 320 330 340 350 360

NS=20+2*(T>17)+(T>24)+(T>30)

IFS< OORS >NSTHENEND

INPUT"{DOWN}OUTPUT TO SCREEN OR PRIN

(S/P) S{LEFT 3}";0*

IFO*< >"S"ANDO*< >"P"THENEND

INPUT"{DOWN}ARE YOU SURE Y{LEFT 31"

IFQ*< >"Y"THENEND

OPEN15,8,15

T*=RIGHT*(STR*(T),LEN(STR*(T))-1)

IFT<1OTHENT*="0"+T*

S*=RIGHT*(STR*(S),LEN(STR*(S))-1)

IFS<10THENS*="0"+S* REM SEEK JOB=176

G0SUB850

IFEO1G0T0360 REM READ J0B=128

G0SUB850

IFE=1G0T0470

IFE >1ANDE<12THENEN*=RIGHT*(STR*(E+18

),2)

':G0T0380

370 380 390 400 410 420 430 440 450 460 470 480 490 500 510 520
 EN*="02":EM*="?TIMEOUT":GOT0390 EM*="READ ERROR" ET*=T* ES*=S*

PRINT"{DOWN}"EN*", "EM*","ET*","ES*

IFE< >4ANDE< >5GOT0450 GOSUB1020 GOT0470 CLOSE15 END

IF0*="S"GOT055O

0PEN4,4

F0RI=1T06 PRINT#4 NEXTI

PRINT#4," DISPLAY TRACK & SE

CTOR"

448

-----------------------------------------------------Page 448-----------------------------------------------------
﻿
530 PRINT#4," TRACK "T*" - SECT

OR "S*

540 PRINT#4

550 F0RK=0T01

560 PRINT"{CLR}{RVS} DISPLAY TRA CK & SECTOR {ROFF}"

570 PRINT"{HOME}{DOWN}{RVS} TRA CK "T*" - SECTOR "S*" {ROFF}" 580 PRINT"{HOME}{DOWN 2}" 590 FORJ=OT015 600 D=K*128+J*8 610 G0SUB970

620 BP*=" . "+DH*+": " 630 H*="" 640 A*=""

650 F0RI=0T07

660 PRINT#15,"M-R"CHR*(K*128+J*8+I)CHR*(

4)

670 GET#15,B*

680 D=ASC(B*+CHR*(0)) 690 G0SUB970

700 H*=H*+DH*+" "

710 IFD>127THEND=D-128 720 IFD<320RD>90THEND=46 730 A*=A*+CHR*(D) 740 NEXTI

750 PRINTBP*;H*;A*

760 IFO*="P"THENPRINT#4,BP*;H*;A* 770 NEXTJ

780 IF0*="P"G0T0800 790 GOSUB1020 800 NEXTK

810 IFO*="P"THENCLOSE4 820 CLOSE15 830 GOT0110

840 REM JOB QUEUE 850 TRY=0

860 PRINT#15,"M-W"CHR*(8)CHR*(0)CHR*(2)C

HR*(T)CHR*(S)

870 PRINT#15,"M-W"CHR*(1)CHR*(0)CHR*(DC

HR*(JOB)

880 TRY=TRY+1

890 PRINT#15,"M-R"CHR*(1)CHR*(O) 900 GET#15,E*

91O IFE*=""THENE*=CHR*(0) 920 E=ASC(E*)

930 IFTRY=5O0GOT0950 940 IFEM27GOT0880 950 RETURN

960 REM DECIMAL TO HEXADECIMAL

449

-----------------------------------------------------Page 449-----------------------------------------------------
﻿
970 H=INT(D/16)+1 980 L=D-(H-1)*16+1

990 DH*=MID*(HD*,H,1)+MID*(HD*,L,1)

1000 RETURN

1010 REM DELAY

1020 PRINT"{DOWN}PRESS {RVS}RETURN{ROFF}

TO CONTINUE"

1030 GETC*:IFC*=""THEN1030 1040 IFC*< >CHR*(13)GOTO1030 1050 PRINT"OK" 1060 RETURN

450

-----------------------------------------------------Page 450-----------------------------------------------------
﻿
100 REM DISPLAY A CHAIN - 1541 110 CLR

120 PRINT"{CLR}DISPLAY A CHAIN - 1541" 130 PRINT"{DOWN}INSERT DISKETTE IN DRIVE

■ I

140 INPUT" {DOWN}TRACK 8< SECTOR (T,S)"?T,

S

150 IFT<1ORT >35THENEND

160 NS=20+2*(T>17)+(T>24)+(T>30) 170 IFS<OORS>NSTHENEND

180 INPUT"{DOWN}OUTPUT TO SCREEN OR PRIN TER (S/P) S{LEFT 3>";O*

190 1F0*< >"S"ANDO*< >"P"THENEND

200 INPUT"{DOWN}ARE YOU SURE Y{LEFT 3}" ;q*

210 IFQ*< >"Y"THENEND

220 0PEN15,8,15

230 PRINT#15,"10"

240 INPUT#15,EN*,EM*,ET*,ES*

250 IFEN*="O0"G0T029O

260 PRINT"{DOWN}"EN*", "EM*","ET*","ES*

270 CLOSE15 280 END

290 IF0*="S"G0T0390

300 PRINT"{DOWN}{RVSJPRINTING{ROFF} A CH AIN"

310 0PEN4,4

320 F0RI=1T06 330 PRINT#4 340 NEXTI

350 PRINT#4," DISPLAY A CHAI

N"

360 PRINT#4," BLOCK TRACK - SE

CTOR"

370 PRINT#4 380 G0T0420

390 PRINT"{CLR}{RVS} DISPLAY

A CHAIN {ROFF}"

400 PRINT"{HOME}{DOWN}{RVS} BLOC K TRACK - SECTOR {ROFF}" 410 PRINT"{HOME}{DOWN 2}" 420 B=B+1

430 GOSUB1030 440 REM SEEK 450 J0B=176 460 G0SUB910

470 IFE01GOT0520 480 REM READ 490 J0B=128 500 G0SUB910

451

-----------------------------------------------------Page 451-----------------------------------------------------
﻿
510 IFE=1G0T0630

520 IFE >1ANDE<12THENEN*=RIGHT*(STR*(E+18

),2):G0T0540

530 EN*="02":EM*="?TIMEOUT":G0T0550 540 EM*="READ ERROR" 550 ET*=T* 560 ES*=S*

570 IF0*="P"THENPRINT#4," "EN*" , "EM*","ET*","ES*:G0T0590

580 PRINT" "EN*", "EM*","ET*","

ES*

590 IFE=40RE=5G0T0630 600 IFO*="P"GOT0810 610 GOSUB1090 620 G0T0820

630 B*=RIGHT*(STR*(B),LEN(STR*(B))-1)

640 IFB<10THENB*=" "+B* 650 IFB<100THENB*=" "+B*

660 IFO*="P"THENPRINT#4," "B*"

"T*" - "S*:G0T0680

670 PRINT" "B*" "T*" - "S *

680 PRINT#15,"M-R"CHR*(O)CHR*(4)CHR*(2) 690 GET#15,T*

700 T=ASC(T*+CHR*(0)) 710 IFT=0G0T0760

720 GET#15,S*

730 S=ASC(S*+CHR* < O))

740 IFT >350RS >20+2*(T >17) + (T>24) + (T >30)G 0T0850

750 IF0*="S"ANDB/16OINT(B/16)G0T0420 760 IF0*="P"G0T0780 770 GOSUB1090

780 IFT=0G0T0810

790 IF0*="S"G0T0390 800 G0T0420

810 IF0*="P"THENCL0SE4 320 CLOSE15 830 G0T0110

840 REM ILLEGAL TRACK OR SECTOR 850 GOSUB1030

860 IF0*="P"THENPRINT#4," 66, IL LEGAL TRACK OR SECTOR,"T*","S*:GOTOS10 870 PRINT"{DOWN}66, ILLEGAL TRACK OR SEC TOR,"T*","3*

880 GOSUB1090 890 G0T0820

900 REM JOB QUEUE 910 TRY=0

920 PRINT#15,"M-W"CHR*(8)CHR*(O)CHR*(2)C

452

-----------------------------------------------------Page 452-----------------------------------------------------
﻿
HR*(T)CHR*(S)

930 PRINT#15, "M-W"CHR*(1)CHR*(0) CHR* (DC

HR*(J0B)

940 TRY=TRY+1

950 PRINT#15,"M-R"CHR*(1)CHR*(0) 960 GET#15,E*

970 IFE*=""THENE*=CHR*(0) 980 E=ASC(E*)

990 IFTRY=5OOGOT01O10 1000 IFEM27G0T0940 1010 RETURN

1020 REM STR*(T,S)

1030 T*=RIGHT*(STR*(T),LEN(STR*(T))-1)

1040 IFT<1OTHENT*="O"+T*

1050 S*=RIGHT*(STR*(S),LEN(STR*(S))-1)

1060 IFS<10THEN3*="0"+S* 1070 RETURN

1080 REM DELAY

1090 PRINT"{DOWN}PRESS {RVS}RETURN{R0FF3

TO CONTINUE"

1100 GETC*:IFC*=""THEN1100 1110 IFC*OCHR*(13)GOTOHOO 1120 RETURN

453

-----------------------------------------------------Page 453-----------------------------------------------------
﻿

-----------------------------------------------------Page 454-----------------------------------------------------
﻿
100 REM EDIT TRACK & SECTOR - 1541

110 P0KE56,159

120 CLR

130 HD*="01234567S9ABCDEF" 140 CD*="{HOME}{DOWN 20}"

150 PRINT"{CLR}EDIT A SECTOR - 1541"

160 PRINT"{DOWN}REMOVE {RVS}WRITE PROTEC T TAB{ROFF}"

170 PRINT"{DOWN}INSERT DISKETTE IN DRIVE

ii

180 INPUT"{DOWN}EDIT TRACK & SECTOR (T,S

)";t,s

190 IFT<10RT>35GOT015SO

200 NS=20+2*(T>17)+(T>24)+(T>30) 210 IFS<00RS>NSG0T01580

220 INPUT"{DOWN}STARTING BYTE (00/80)";S

B*

230 IFLEN(SB*)=OGOTO1580 240 SB=VAL(SB*)

250 IFSB< >OANDSB< >SOGOTO1530 260 IFSB=OTHENBP=0:G0T02S0 270 BP=128

280 INPUT"{DOWN}ARE YOU SURE Y{LEFT 3}" ;Q*

290 IFQ*0"Y"GOT01580

300 OPEN15,8,15

310 T*=RIGHT*(STR*(T),LEN(STR*(T))-1)

320 IFT<1OTHENT*="O"+T*

330 S*=RIGHT*(STR*(S),LEN(STR*(S))-l)

340 IFS<1OTHENS*="0"+S* 350 REM SEEK 360 J0B=176

370 GOSUB1620

380 IFE01GOT0430 390 REM READ 400 J0B=128

410 GOSUB1620

420 IFE=1G0T0520

430 IFE>1ANDE<12THENEN*=RIGHT*(STR*(E+18

),2):G0T0450

440 EN*="02":EM*="?TIMEOUT":GOT0470

450 IFE=70RE=8THENEM*="WRITE ERROR":GOTO

470

460 EM*="READ ERROR" 470 ET*=T* 480 ES*=S*

490 PRINT"{DOWN}"EN*", "EM*","ET*","ES*

500 CLOSE15 510 GOTO1530

520 PRINT"{CLR}{RVS} EDIT TRACK

455

-----------------------------------------------------Page 455-----------------------------------------------------
﻿
S< SECTOR {ROFF}"

530 PRINT"{HOME}{DOWN}{RVS} TRA CK "T*" - SECTOR "S*" {ROFF}" 540 PRINT"{HOME}{DOWN 2}" 550 FORJ=OT015 560 D=J*8+BP 570 GOSUB1740

580 BP*=" . "+DH*+": " 590 H*="" 600 A*=""

610 FORI=OT07

620 PRINT#15, "M-R"CHR*(J*8-i-I+BP)CHR*(4)

630 GET#15,B*

640 D=ASC(B*+CHR*(0))

650 POKE(40704+J*8+I),D

660 GOSUB1740

670 H*=H*+DH*+" "

680 IFD>127THEND=D-128 690 IFD<320RD>95THEND=46 700 IFD=34THEND=46 710 A*=A*+CHR*(D) 720 NEXTI

730 PRINTBP*H*"{RVS}"A*"{ROFF}" 740 NEXTJ

750 PRINT"{DOWN}{RVS}EDIT{ROFF} TRACK "T *" - SECTOR "S*" (Y/N)?" 760 GOSUB1790

770 IFQ*0"Y"GOT01390

780 PRINTCD*"PRESS {RVS}CLR{ROFF} TO EX I

T

790 PRINT"{HOME}{DOWN 3}{RIGHT 7}";

800 S=1151 810 C=l

820 A=PEEK(S):IFA >127THENA=A-128 330 M=S

340 P0KEM,A+128

850 GETI*:IFI*=""THENS50 860 I=ASC(I*)

870 IFI=147THENPOKEM,A:GOT01360 380 IFI=19THENP0KEM,A:G0T0790

890 IFI=141THENI=13 900 IFI013GOT0930

910 IFC=23ANDS<>1773THENPRINT"{RIGHT}";: G0T01230

920 IFS<1751THENPOKEM,A:FORI=CT023:PRINT

"{RIGHT}";:S=S+1:NEXTI:S=S-1:C=23:G0T012

30

930 IFI=32THENI=29:I*=CHR*(29) 940 IFI<>29G0T0970

950 IFC< >23THENC=C+1:S=S+1:GOTO1290

456

-----------------------------------------------------Page 456-----------------------------------------------------
﻿
960 IF3< M773THENPRINT"{RIGHT}";:GOTO123

0

970 IFI<>157G0T01OOO

980 IFCO1 THENC=C-1: S=S-1: GOTO 1290

990 IFC=1ANDS< >1151THENFORI = 1TO18:PRINT"

{LEFT}";:NEXTI:C=23:S=S-18:G0T01300 1000 IFI< >17G0T01020

1010 IFS+40<1774THENS=S+40:GOTO1290 1020 IFI0145GOT01040

1030 IFS-40M150THENS=S-40:GOTO1290 1040 IFA=320RA=160G0T0B50

1050 IFI<480RI>57ANDI<650RI>70G0T0320

1060 PRINTI*;

1070 A=I:IFI>64THENA=A-64 1080 IFA<7THENL=A+9 1090 IFA>47THENL=A-48

1100 IFINT((C+1)/3)=(C+1)/3THENR=PEEK(S- 1):G0T01120

1110 R=PEEK(S+1)

1120 IFR >127THENR=R-123

1130 IFR<7THENR=R+9 1140 IFR >47THENR=R-48

1150 IFINT( (C+1)/3X>(C+1)/3THENI=L*16+R :GOTO1170

1160 I=R*16+L

1170 P0KE40704+8*INT((M-l151)/40)+INT(C/

3), I

1180 IFI>127THENI=I-128 1190 IFK320RI>95THENI=46 1200 IFI=34THENI=46

1210 IFI>64THENPOKEM+25-C+INT(C/3),1-64+

128:GOTO1230

1220 P0KEM+25-C+INT(C/3),1+128

1230 IFC=23ANDS< >1773THENF0R1 = 1TO17:PRIN T"{RIGHT}";:NEXTI:C=l:S=S+18:G0T01300 1240 IFS=1773THENPRINT"{LEFT}";:G0T01300

1250 S=S+1 1260 C=C+1

1270 POKEM,A

1280 G0T0820 1290 PRINTI*;

1300 A=PEEK(M):IFA>127THENA=A-128 1310 P0KEM,A

1320 G0T0820

1330 PRINTCD*"EXIT (Y/N)?" 1340 GOSUB1790

1350 IF0*="N"G0T0780

1360 PRINTCD*"{RVS}REWRITE{ROFF} TRACK "

T*" - SECTOR "S*" (Y/N)?"

1370 GOSUB1790

457

-----------------------------------------------------Page 457-----------------------------------------------------
﻿
1380 IFQ*="Y"G0T01450 1390 CLOSE15

1400 PRINTCD*"ATTEMPT TO EDIT A SECTOR {

RVS}FAILED{ROFF}

1410 PRINT"{DOWN}PRESS {RVS}RETURN{ROFF}

TO CONTINUE"

1420 GETC*:IFC*=""THEN1420 1430 IFC*OCHR*(13)G0T01420 1440 GOTO120

1450 PRINTCD*"{RVS}REWRITING{ROFF} TRACK

"T*" - SECTOR "S*"

1460 F0RI=0T0127

1470 PRINT#15,"M-W"CHR*(I+BP)CHR*(4)CHR*

(1)CHR*(PEEK(40704+1)) 1480 NEXTI

1490 REM WRITE 1500 T=VAL(T*) 1510 S=VAL(S*) 1520 JOB=144

1530 GOSUB1620 1540 CLOSE15

1550 IFE< >1GOTO1400

1560 PRINTCD*"ATTEMPT TO EDIT A SECTOR C

OMPLETE"

1570 G0T0141O

1580 P0KE56,160

1590 CLR 1600 END

1610 REM JOB QUEUE 1620 TRY=0

1630 PRINT#15,"M-W"CHR*(8)CHR*(0)CHR*(2)

CHR*(T)CHR*(S)

1640 PRINT#15,"M-W"CHR*(1)CHR*(0)CHR*(D

CHR*(JOB)

1650 TRY=TRY+1

1660 PRINT#15,"M-R"CHR*(1)CHR*(O)

1670 GET#15,E*

1680 IFE*=""THENE*=CHR*(0) 1690 E=ASC(E*)

1700 IFTRY=500G0T0172O 1710 IFEM27G0T01650 1720 RETURN

1730 REM DECIMAL TO HEXADECIMAL 1740 H=INT(D/16)+1 1750 L=D-(H-1)*16+1

1760 DH*=MID*(HD*,H,1)+MID*(HD*,L,1)

1770 RETURN

1780 REM QUERY

1790 GETQ*:IFQ*=""THEN1790

1800 IFQ*< >"Y"ANDQ*< >"N"GOTO1790 1810 RETURN

458

-----------------------------------------------------Page 458-----------------------------------------------------
﻿
100 REM EDIT DOS VERSION

110 PRINT"{CLR3EDIT DOS VERSION - 1541" 120 PRINT"{DOWN}REMOVE {RVS}WRITE PROTEC

T TAB{ROFF}"

130 PRINT"{DOWN}INSERT DISKETTE IN DRIVE

II

140 PRINT"{DOWN}PRESS {RVS}RETURN{ROFF}

TO CONTINUE"

150 GETC*:IFC*=""THEN150 160 IFC*OCHR*(13)G0T0150 170 PRINT"OK"

180 0PEN15,8,15

190 PRINT#15,"10"

200 INPUT#15,EN*,EM*,ET*,ES*

210 IFEN*="00"G0T0250

220 PRINT"{DOWN}"EN*", "EM*","ET*","ES*

230 CLOSE15 240 END

250 PRINT#15,"M-R"CHR*(1)CHR*(1)

260 GET#15,D0S*

270 IFDCS*=""THENDOS*=CHR*(O) 280 0DV=ASC(DOS*)

290 PRINT"{DOWN}QLD DOS VERSION:";ODV 300 NDV=-1

310 INPUT"{DOWN}NEW DOS VERSION";NDV 320 IFNDV< OORNDV >255G0T0500

330 INPUT"{DOWN}ARE YOU SURE (Y/N) Y{LE FT 3}";Q*

340 IFQ*< >"Y"G0T0500 350 T=18 360 S=0

370 REM SEEK 330 JOB=176 390 G0SUB530 400 REM READ 410 J0B=12S 420 G0SUB53C)

430 PRINT#15,"M-W"CHR*(2)CHR*(4)CHR*(1)C

HR*(NDV)

440 REM WRITE 450 JOB=144 460 G0SUB530 470 CLOSE15

430 PR I NT " {DOWN) DONE .' " 490 END

500 CLOSE15 510 END

520 REM JOB QUEUE 530 TRY=0

540 PRINT#15,"M-W"CHR*(8)CHR*(O)CHR*(2)C

459

-----------------------------------------------------Page 459-----------------------------------------------------
﻿
HR*(T)CHR*(S)

550 PRINT#15, "M-WCHR* (1) CHR* (0) CHR* (1) C

HR*(JOB)

560 TRY=TRY+1

570 PRINT#15,"M-R"CHR*(1)CHR*(0)

580 GET#15,E*

590 IFE*=""THENE*=CHR*(O) 600 E=ASC(E*)

610 IFTRY=500G0T0630 620 IFEM27G0T0560 630 IFE=1THENRETURN 640 CLOSE15

650 PRINT"{DOWN}{RVS}FAILED{ROFF}" 660 END

460

-----------------------------------------------------Page 460-----------------------------------------------------
﻿
100 REM VALIDATE A DISKETTE - 1541 110 CLR

120 CD*="{D0WN 21}"

130 DIMF*(143) , TV. (143) ,SZ(143)

140 PRINT"{CLR}VALIDATE A DISKETTE - 154 1"

150 PRINT"{DOWN}INSERT DISKETTE IN DRIVE

II

160 PRINT"{DOWN}PRESS {RVS}RETURN{ROFF}

TO CONTINUE"

170 GETC*:IFC*=""THEN170 180 IFC*< >CHR*(13)GOTO170 190 PRINT"OK"

200 0PEN15,8,15

210 PRINT#15,"I0"

220 INPUT#15,EN*,EM*,ET*,ES*

230 IFEN*="00"GOT027b

240 PRINT"{DOWN}"EN*", "EM*","ET*","ES*

250 CLOSE15 260 END

270 PRINT"{DOWN}{RVS}FETCHING{ROFF} DIRE CTORY"

230 0PEN2,8,2,"*0,S,R"

290 INPUT#15,EN*,EM*,ET*,ES*

300 IFEN*="00"G0T0320 310 G0T0240

320 F0RI=0T0253

330 GET#2,B*

340 NEXTI 350 N=0

360 F0RJ=0TO7

370 GET#2,B*

380 IFB*=""THENB*=CHR*(O) 390 A=ASC(B*)

400 IFA >127ANDA<133G0T0510 410 F0RI=0T02

420 GET#2,B*

430 NEXTI

440 IFB*=""THENB*=CHR*(O > 450 A=ASC(B*>

460 IFA=0THENJ=7:NEXTJ:G0T0820 470 F0RI=0T025

480 GET#2,B*

490 NEXTI

500 G0T0750

510 GET#2,B*

520 IFB*=""THENB*=CHR*(O) 530 T7.(N)=ASC(B*)

540 GET#2,B*

550 IFB*=""THENB*=CHR*(O >

461

-----------------------------------------------------Page 461-----------------------------------------------------
﻿
560 S7. (N)=ASC(B*) 570 F*=""

580 NULL=0

590 F0RI=0T015 600 GET#2,B*

610 IFB*=""THENB*=CHR*(0) 620 A=ASC(B*)

630 IFA=0THENNULL=NULL+1 640 IFA>127THENA=A-128 650 IFA<320RA>95THENA=63 660 IFA=34THENA=63 670 F*=F*+CHR*(A) 680 NEXTI

690 IFNULL=16THENJ=7:NEXTJ:G0T0820 700 F*(N)=F* 710 N=N+1

720 F0RI=0T010

730 GET#2,B*

740 NEXTI

750 IFJ=7G0T0790 760 F0RI=0T01

770 GET#2,B*

780 NEXTI 790 NEXTJ

800 IFST=64G0T0820 810 G0T0360 820 CL0SE2

830 INPUT#15,EN*,EM*,ET*,ES*

840 IFN>0G0T0880

850 PRINT"CDOWN}NO CLOSED FILES ARE IN T HE DIRECTORY" 860 CLOSE15 370 END 880 1=0

890 PRINT"{CLR}"

900 N*=RIGHT*("00"+RIGHT*(STR*(N) ,LEN(ST R*(N))-l),3)

910 F0RJ=0T0N-1

920 J*=RIGHT*("00"+RIGHT*(STR*(J+l),LEN( STR*(J+1))-l),3)

930 PRINT"{HOME}{RVS}VALIDATING{ROFF} #" J*"/"N*": "F*(J)

940 PRINT"{HOME}";LEFT*(CD*,1+2);F*(J);"

H -

9

950 NB=1

960 T=T7.(J) 970 S=S7. (J)

980 GOSUB1640

990 PRINT"{HOME}"LEFT*(CD*,I+2)F*(J)NB

1000 J0B=176

462

-----------------------------------------------------Page 462-----------------------------------------------------
﻿
1010 GOSUB1520

1020 IFE=1G0T01040 1030 GOTO1170 1040 JOB=128

1050 GOSUB1520

1060 IFE=1G0T01080 1070 GOTO1170

1030 PRINT#15,"M-R"CHR*(0)CHR*(4)CHR*(2)

1090 GET#15,B*

1100 T=ASC(B*+CHR*(O)) 1110 IFT=OGOT01170

1120 GET#15,B*

1130 S=ASC(B*+CHR*(O))

1140 IFT >350RS >20+2*(T >17) + (T>24) + (T >30)

THENI=I+2:R*="{RVSJ":GOTO1230

1150 NB=NB+1 1160 GOT0980 1170 1=1+2

1180 R*="{ROFF}"

1190 IFE=1G0T01240 1200 R*="{RVS}" 1210 GOSUB1700 1220 GOTO1250

1230 E*="ILLEGAL TRACK OR SECTOR{LEFT}":

G0T0125O

1240 E*="00, OK,00,00"

1250 PRINT"{HOME}"R*;LEFT*(CD*,I);F*(J)"

"E*"{ROFF}"

1260 F*(J)="{HOME}{RVS}"+J*+"{R0FF3"+R*+ LEFT*(CD*,I)+"{LEFT 3}"+F*(J)+" "+E*+"{R OFF} "

1270 IFI=20ANDJ< >N-1THENF0RD=1T01000:NEX TD:PRINT"{CLR}":1=0

1280 NEXTJ

1290 CLOSE15

1300 IFN<11THENS=N:GOTO1500

1310 INPUT"{DOWN}SUMMARY INFORMATION (Y/ N) Y{LEFT 3}";Q*

1320 IFQ*0"Y"GOT0110

1330 SI*="{CLR}{RVS} /"+N*+" SUMMAR

Y INFORMATION {ROFF}"

1340 S=0

1350 PRINTSI* 1360 F0RI=0T09 1370 PRINTF*(S) 1380 S=S+1

1390 IFS=NTHENI=9 1400 NEXTI

1410 IFS< >NGOTO1460

463

-----------------------------------------------------Page 463-----------------------------------------------------
﻿
1420 IFS=NTHENPRINT"{DOWN}{RVS}

TYPE >C TO CONTINUE {ROFF}"

1430 GETC*:IFC*=""THEN1430 1440 IFC*< >"C"GOTO1430 1450 GOT0110

1460 PRINT"{DOWN}{RVS} TYPE 7C TO CONT INUE OR 'S' TO STOP {ROFF}" 1470 GETC*:IFC*=""THEN1470

1430 IFC*< >"C"ANDC*< >"S"GOTO1470 1490 IFC*="C"G0T01350 1500 GOTOllO

1510 REM JOB QUEUE 1520 TRY=0

1530 PRINT#15,"M-W"CHR*(8)CHR*(O)CHR*(2)

CHR*(T)CHR*(S)

1540 PRINT#15,"M-W"CHR*(1)CHR*(O)CHR*(1)

CHR*(JOB)

1550 TRY=TRY+1

1560 PRINT#15,"M-R"CHR*(1)CHR*(0) 1570 GET#15,E*

1580 IFE*=""THENE*=CHR*(0) 1590 E=ASC(E*>

1600 IFTRY=5OOGOT01620 1610 IFEM27GOT01550 1620 RETURN

1630 REM STR*(T,S)

1640 T*=RIGHT*(STR*(T),LEN(STR*(T))-l) 1650 IFT<1OTHENT*="O"+T*

1660 S*=RIGHT*(STR*(S),LEN(STR*(S))-1) 1670 IFS<1OTHENS*="O"+S* 1680 RETURN

1690 REM EN*,EM*,ET*,ES*

1700 IFE >1ANDE<12THENEN*=RIGHT*(STR*(E+1

8),2):G0TO1720

1710 EN*="02":EM*="?TIME OUT":GOTO1730 1720 EM*="READ ERROR" 1730 ET*=T* 1740 ES*=S*

1750 E*=EN*+", "+EM*+","+ET*+","+ES*

1760 RETURN

464

-----------------------------------------------------Page 464-----------------------------------------------------
﻿
100 REM DUPLICATE TRACK 8c SECTOR - 1541 110 PRINT" {CLR}DUPLICATE TRACK 8c SECTOR - 1541"

120 PRINT"{DOWN}INSERT DISKETTE IN DRIVE

ii

130 INPUT"{DOWN}SOURCE TRACK AND SECTOR

(T,S)";T,S

140 G0SUB580 150 TR=T:T=0 160 SR=S:S=0

170 INPUT"{DOWN}TARGET TRACK AND SECTOR

(T,S)";T,S

180 GOSUB580 190 TW=T 200 SW=S

210 INPUT"{DOWN}ARE YOU SURE Y{LEFT 3}" ;Q*

220 IFQ*<>"Y"THENEND

230 0PEN15,8,15

240 PRINT#15,"10"

250 INPUT#15,EN*,EM*,ET*,ES*

260 IFEN*="00"G0T0310

270 PRINT"{DOWN}"EN*", "EM*","ET*","ES*

280 CLOSE15 290 END

300 REM SEEK 310 T=TR 320 S=SR

330 J0B=176 340 G0SUB630

350 IFE=1G0T0380 360 GOT075O 370 REM READ 380 J0B=128 390 G0SUB630

400 IFE=1G0T0430 410 G0T0750 420 REM SEEK 430 T=TW 440 S=SW

450 J0B=176 460 G0SUB630

470 IFE=1G0T0500 430 G0T0750

490 REM WRITE 500 J0B=144 510 G0SUB630

520 IFE=1G0T0540 530 G0T0750 540 CLOSE15

465

-----------------------------------------------------Page 465-----------------------------------------------------
﻿
550 PRINT"{DOWN}DONE!" 560 END

570 REM ILLEGAL TRACK OR SECTOR 530 IFT<1ORT >35THENEND

590 NS=20+2*(T >17) + (T >24) + (T >30) 600 IFS<OORS>NSTHENEND 610 RETURN

620 REM JOB QUEUE 630 TRY=0

640 PRINT#15,"M-W"CHR*(8)CHR*(0)CHR*(2)C

HR*(T)CHR*(S)

650 PRINT#15,"M-W"CHR*(1)CHR*(0)CHR*(1)C

HR*(JOB)

660 TRY=TRY+1

670 PRINT#15,"M-R"CHR*(1)CHR*(0)

680 GET#15,E*

690 IFE*=""THENE*=CHR*(0) 700 E=ASC(E*)

710 IFTRY=500G0T0750 720 IFE>127G0T0660 730 RETURN

740 REM ERROR HANDLER

750 ET*=RIGHT*(STR*(T >,LEN(STR*(T))-1)

760 IFT<10THENET*="0"+ET*

770 ES*=RIGHT*(STR*(S),LEN(STR*(S))-l)

730 IFS<1OTHENES*="O"+ES*

790 IFE >1ANDE<12THENEN*=RIGHT*(STR*(E+18

),2):G0T0810

800 EN*="02":EM*="?TIME 0UT":G0T0830

810 IFE=70RE=8THENEM*="WRITE ERROR":GOTO 830

820 EM*="READ ERROR"

330 PRINT"CDOWN}"EN*", "EM*","ET*","ES*

840 PRINT"CDOWN}{RVS}FAILED{ROFF}" 850 CLOSE15 860 END

466

-----------------------------------------------------Page 466-----------------------------------------------------
﻿
100 REM COPY TRACK 8< SECTOR - 1541

110 PRINT" {CLR}COPY TRACK 8c SECTOR - 154

1"

120 PRINT"{DOWN}INSERT MASTER IN DRIVE"

130 INPUT"{DOWN}TRACK AND SECTOR (T,S)"; T,S

140 IFT<1ORT >35THENEND

150 NS=20+2*(T>17)+(T>24)+(T>30) 160 IFS<OORS>NSTHENEND

170 INPUT"CDOWN}ARE YOU SURE Y{LEFT 3}" ;q*

180 IFQ*< >"Y"THENEND

190 0PEN15,8,15

200 PRINT#15,"10"

210 INPUT#15,EN*,EM*,ET*,ES*

220 IFEN*="00"G0T0270

230 PRINT"{DOWN}"EN*", "EM*","ET*","ES*

240 CLOSE15 250 END

260 REM SEEK 270 J0B=176 280 G0SUB570

290 IFE=lGOT0320 300 G0T0690 310 REM READ 320 J0B=128 330 G0SUB570

340 IFE=1G0T0360 350 GOT0690 360 CLOSE15

370 PRINT"{DOWN}INSERT CLONE IN DRIVE" 380 PRINT"PRESS {RVS}RETURN{ROFF} TO CON TINUE"

390 GETC*:IFC*=""THEN390 400 IFC*< >CHR*(13)G0T0390 410 PRINT"OK"

420 OPEN15,8,15

430 REM SEEK 440 J0B=176 450 G0SUB570

460 IFE=1G0T0490 470 G0T0690

480 REM WRITE 490 J0B=144 500 GOSUB570

510 IFE=1G0T0530 520 G0T0690 530 CLOSE15

540 PRINT"{DOWN}DONE!" 550 END

467

-----------------------------------------------------Page 467-----------------------------------------------------
﻿
560 REM JOB QUEUE 570 TRY=0

580 PRINT#15,"M-W'CHR*(8)CHR*(O)CHR*(2)C

HR*(T)CHR*(S)

590 PRINT#15, "M-W"CHR* (1) CHR* (O) CHR* (DC

HR*(JOB)

600 TRY=TRY+1

610 PRINT#15, "M-R"CHR*(DCHR*(0)

620 GET#15,E*

630 IFE*=""THENE*=CHR*(O) 640 E=ASC(E*)

650 IFTRY=500G0T0690 660 IFEM27G0T0600 670 RETURN

680 REM ERROR HANDLER

690 ET*=RIGHT*(STR*(T),LEN(STR*(T))-1)

700 IFT<1OTHENET*="O"+ET*

710 ES*=RIGHT*(STR*(S),LEN(STR*(S))-1) 720 IFS<1OTHENES*="O"+ES*

730 IFE>1ANDE<12THENEN*=RIGHT*(STR*(E+18

),2):G0T0750

740 EN*="02":EM*="?TIME 0UT":G0T0770 750 IFE=70RE=8THENEM*="WRITE ERROR":GOTO

770

760 EM*="READ ERROR"

770 PRINT"{DOWN}"EN*", "EM*","ET*","ES*

780 PRINT"{DOWN}{RVS}FAILED{ROFF}" 790 CLOSE15 800 END

468

-----------------------------------------------------Page 468-----------------------------------------------------
﻿
100 REM RECOVER TRACK 8c SECTOR - 1541 110 PRINT" {CLR}RECOVER TRACK Sc SECTOR -

1541"

120 PRINT"{DOWN}INSERT DISKETTE IN DRIVE

ll

130 INPUT"{DOWN}RECOVER TRACK AND SECTOR

(T,S) ";T,S

140 IFT<1ORT >35THENEND

150 NS=20+2*(T>17)+(T>24)+(T>30) 160 IFS<OORS>NSTHENEND

170 INPUT"{DOWN}ARE YOU SURE Y{LEFT 3}" ;Q*

180 IFQ*<>"Y"THENEND

190 0PEN15,8,15

200 PRINT#15,"10"

210 INPUT#15,EN*,EM*,ET*,ES*

220 IFEN*="00"G0T0290

230 PRINT"{DOWN}"EN*", "EM*","ET*","ES*

240 PRINT"{DOWN}PRESS {RVS}RETURN{ROFF} TO CONTINUE"

250 GETC*:IFC*=""THEN250 260 IFC*OCHR*(13)G0T0250 270 PRINT"OK" 280 REM SEEK 290 J0B=176 300 G0SUB520

310 IFE=1G0T0340 320 G0T0640 330 REM READ 340 JOB=128 350 G0SUB520

360 IFE=4G0T0420 370 IFE=5G0T0440 380 IFEO1G0T0640

390 PRINT"{DOWN}00, OK,00,00"

400 CLOSE15 410 END

420 PRINT#15,"M-W"CHR*(71)CHR*(O)CHR*(1)

CHR*(7)

430 REM WRITE 440 J0B=144 450 G0SUB520

460 IFE=1G0T0480 470 G0T0640 480 CLOSE15

490 PRINT"{DOWN}DONE!"

500 END

510 REM JOB QUEUE

520 TRY=0

530 PRINT#15,"M-W"CHR*(8)CHR*(0)CHR*(2)C

469

-----------------------------------------------------Page 469-----------------------------------------------------
﻿
HR*(T)CHR*(S)

540 PRINT#15, "M-W"CHR*(DCHR*(0)CHR*(DC HR*(JOB)

550 TRY=TRY+1

560 PRINT#15,"M-R"CHR*(1)CHR*(0) 570 GET#15,E*

580 IFE*=""THENE*=CHR*(0) 590 E=ASC(E*)

600 IFTRY=500G0T0640 610 IFEM27GOT0550 620 RETURN

630 REM ERROR HANDLER

640 ET*=RIGHT*(STR*(T),LEN(STR*(T))-1)

650 IFT<1OTHENET*="O"+ET*

660 ES*=RIGHT*(STR*(S),LEN(STR*(S))-1)

670 IFS<1OTHENES*="O"+ES*

680 IFE >1ANDE<12THENEN*=RIGHT*(STR*(E+18

),2):G0T0700

690 EN*="02":EM*="?TIME 0UT":G0T0720

700 IFE=70RE=8THENEM*="WRITE ERROR":GOTO 720

710 EM*="READ ERROR"

720 PRINT"{DOWN}"EN*", "EM*","ET*","ES*

730 PRINT"{DOWN}{RVS}FAILED{ROFF}" 740 CLOSE15 750 END

470

-----------------------------------------------------Page 470-----------------------------------------------------
﻿
100 REM LAZARUS - 1541

110 PRINT"{CLR}LAZARUS - 1541"

120 PRINT"{DOWN}INSERT DISKETTE IN DRIVE

II

130 INPUT"{HOME}{DOWN 4}ATTEMPT A RESURR

ECTION (Y/N) Y{LEFT 3}";Q*

140 IFQ*< >"Y"THENEND

150 0PEN15,8,15

160 REM SEEK

170 FORT=lTC35

180 NS=20+2*(T >17) + (T >24) + (T >30 >

190 T*=RIGHT*(STR*(T),LEN(STR*(T))-1)

200 IFT<10THENT*="0"+T* 210 JOB=176 220 G0SUB510

230 IFE=1G0T0250

240 BD=BD+1:R=R+NS:G0T0420 250 REM READ

260 FORS=OTONS

270 S*=RIGHT*(STR*(S),LEN(STR*(S))-1)

280 IFS<1OTHENS*="O"+S*

290 PRINT"{HOME}{DOWN 6}{RVS}RESURRECTIN G{ROFF} TRACK "T*" - SECTOR "S* 300 J0B=128 310 G0SUB510

320 IFE=1G0T0410 330 R=R+1

340 IFE< >4ANDE< >5G0T0410 350 IFE=5G0T0330

360 PRINT#15,"M-W"CHR*(71)CHR*(0)CHR*(D

CHR*(7)

370 REM WRITE 380 JOB=144 390 G0SUB510

400 IFE<>1THENW=W+1 410 NEXTS 420 NEXTT

430 CLOSE15

440 PRINT"{HOME}{DOWN 6}

II

450 IFBD=35THENPRINT"{HOME}{DOWN 6}?BAD DISK":END

460 PRINT"{HOME}{DOWN 6}READ ERRORS :"R 470 PRINT"{D0WN3WRITE ERRORS:"W 480 PRINT"{D0WN3 DONE!" 490 END

500 REM JOB QUEUE 510 TRY=0

520 PRINT#15,"M-W"CHR*(8)CHR*(0)CHR*(2)C

HR*(T)CHR*(S)

471

-----------------------------------------------------Page 471-----------------------------------------------------
﻿
530 PRINT#15, "M-WCHR* (1) CHR* (0) CHR* (DC

HR*(JOB)

540 TRY=TRY+1

550 PRINT#15,"M-R"CHR*(1)CHR*(O) 560 GET#15,E*

570 IFE*=""THENE*=CHR*(0) 580 E=ASC(E*>

590 IFTRY=500G0T0610 600 IFE>127G0T0540 610 RETURN

472

-----------------------------------------------------Page 472-----------------------------------------------------
﻿
10O REM INTERROGATE FORMATTING ID'S - 15

41

110 DIMT(35)

120 F0RI=1T035 130 T(I)=1 140 NEXTI

ISO PRINT"{CLR}INTERROGATE FORMATTING ID 'S - 1541"

160 PRINT"{DOWN}INSERT MASTER IN DRIVE" 170 PRINT"{DOWN}PRESS {RVS}RETURN{ROFF} TO CONTINUE"

180 GETC*:IFC*=""THEN180 190 IFC*OCHR*(13)G0T0180

200 0PEN15,8,15

210 PRINT"{CLR}" 220 REM SEEK

230 F0RT=1T035

240 IFT(T)=0G0T0440 250 G0SUB550

260 IFEO1G0T0410

270 PRINT#15,"M-R"CHR*(22)CHR*(O)

280 GET#15,I*

290 IFI*=""THENI*=CHR*(O) 300 I=ASC(I*)

310 I*=RIGHT*(STR*(I),LEN(STR*(D)-l) 320 PRINT#15,"M-R"CHR*(23)CHR*(O) 330 GET#15,D*

340 IFD*=""THEND*=CHR*(O) 350 D=ASC(D*)

360 D*=RIGHT*(STR*(D),LEN(STR*(D))-1)

370 I*="CHR*("+I*+")" 380 D*="CHR*("+D*+")" 390 ID*=I*+" + "+D* 400 G0TO45O

410 IFE=3THENID*="?NO SYNC MARKS":G0T045

O

420 IFE=2THENID*="?HEADER BLOCKS NOT PRE SENT":GOT0450

430 IFE=9THENID*="?CHECKSUM ERROR IN HEA DERS":G0T0450

440 ID*="?TIME OUT"

450 T*=RIGHT*(STR*(T),LEN(STR*(T))-1)

460 IFT<10THENT*=" "+T*

470 PRINT"TRACK "T*" = "ID* 480 REM PAUSE

490 GETC*:IFC*=""G0T051O 500 GETC*:IFC*=""THEN500 510 NEXTT

520 CLOSE15 530 END

473

-----------------------------------------------------Page 473-----------------------------------------------------
﻿
540 REM JOB QUEUE 550 TRY=0

560 PRINT#15,"M-W"CHR*(8)CHR*(0)CHR*(2)C

HR*(T)CHR*(0)

570 PR I NT# 15," M-W " CHR* (1) CHR* (0) CHR* (DC

HR*(176)

580 TRY=TRY+1

590 PRINT#15,"M-R"CHR*(1)CHR*(0)

600 GET#15,E*

61O IFE*=""THENE*=CHR*(0)

620 E=ASC(E*)

630 IFTRY=500G0T0650 640 IFEM27G0T0580 650 RETURN

474

-----------------------------------------------------Page 474-----------------------------------------------------
﻿
100 no i"

120 130 140 150

;q*

160 170 180 190 200 210 220 230 240 250 260 270 280 290 300

0330 310

REM INTERROGATE A TRACK - 1541

PRINT"{CLR}INTERROGATE A TRACK - 154

PRINT"{DOWN}INSERT MASTER IN DRIVE" INPUT"{DOWN}INTERROGATE TRACK";T IFT<1ORT >35THENEND

INPUT"{DOWN}ARE YOU SURE Y{LEFT 3}"

IFQ*<>"Y"THENEND

0PEN15,8,15

NS=20+2*(T>17)+(T>24)+(T>30) REM SEEK J0B=176

G0SUB370 REM READ

PRINT"{CLR}" FORS=OTONS J0B=12S

G0SUB370

S*=RIGHT*(STR*(S),LEN(STR*(S))-1)

IFS<10THENS*=" "+S*

print"TRACK";t;"- ";

IFE=1THENPRINT"SECTOR "S*" = OK":GOT

IFE >1ANDE<12THENEM*=STR*(E+18)+" REA

D ERROR"

320 330 340 350 360 370 380
 PRINT"SECTOR "S*" ="EM* NEXTS

CLOSE15 END

REM JOB QUEUE TRY=0

PRINT#15,"M-W"CHR*(8)CHR*(0)CHR*(2)C

HR*(T)CHR*(S)

390
 PRINT#15, "M-W"CHR* (1) CHR* (0) CHR* (DC

HR*(JOB)

400 410 420 430 440 450 460 470 480 490
 TRY=TRY+1

PRINT#15, "M-R"CHR*(DCHR*(0)

GET#15,E*

IFE*=""THENE*=CHR*(0)

E=ASC(E*)

IFTRY=500G0T0480 IFEM27G0T0400 RETURN

EM*="?TIME OUT" RETURN

475

-----------------------------------------------------Page 475-----------------------------------------------------
﻿

-----------------------------------------------------Page 476-----------------------------------------------------
﻿
100 REM SHAKE, RATTLE, 8c ROLL - 1541

110 PRINT" {CLR}SHAKE, RATTLE, 8c ROLL - 1

541"

120 PRINT"{DOWN}INSERT DISKETTE IN DRIVE

■I

130 INPUT"{DOWN}CLATTER TRACK";T 140 IFT<1ORT >35THENEND

150 INPUT"{DOWN}ARE YOU SURE Y{LEFT 3}" ;Q*

160 IFQ*<>"Y"THENEND

170 0PEN15,S,15

180 0PEN2,8,2,"#"

190 PRINT"{CLR}" 200 REM SEEK 210 G0SUB360

220 NS=20+2*(T>17> + (T>24) + (T>30>

230 FORS=OTONS 240 REM READ

250 PRINT#15,"U1";2;0;T;S

260 INPUT#15,EN*,EM*,ET*,ES*

270 PRINT"TRACK";T;"- ";

280 IFEN*="OO"THENPRINT"SECTOR";S;"= OK" :G0T0300

290 PRINT"SECTOR "ES*" = "EN*" "EM* 300 NEXTS

310 CL0SE2

320 INPUT#15,EN*,EM*,ET*,ES*

330 CLOSE15 340 END

350 REM JOB QUEUE 360 TRY=0

370 PRINT#15,"M-W"CHR*(8)CHR*(0)CHR*(2)C

HR*(T)CHR*(S)

380 PRINT#15, "M-WCHR* (15 CHR* (O) CHR* {DC

HR*(176)

390 TRY=TRY+1

400 PRINT#15, "M-R"CHR*(DCHR*(0) 410 GET#15,E*

420 IFE*=""THENE*=CHR*(O) 430 IFTRY=500G0T0460

440 IFASC(E*)>127G0T0390 450 RETURN 460 CL0SE2

470 INPUT#15,EN*,EM*,ET*,ES*

480 CLOSE15

490 PRINT"{DOWN}{RVS}FAILED{ROFF}" 500 END

477

-----------------------------------------------------Page 477-----------------------------------------------------
﻿

-----------------------------------------------------Page 478-----------------------------------------------------
﻿
lOO REM INTERROGATE A DISKETTE - 1541 110 DIMT(35)

120 F0RI=1T035 130 T(D=1 140 NEXTI

150 PRINT"{CLR}INTERROGATE A DISKETTE - 1541"

160 PRINT"{DOWN}INSERT MASTER IN DRIVE" 170 PRINT"{D0WN3PRESS {RVS}RETURN{ROFF} TO CONTINUE"

180 GETC*:IFC*=""THEN1SO 190 IFC*< >CHR*(13)GOTO180

200 PRINT"OK" 210 PRINT

220 0PEN15,8,15

230 F0RT=1T035

240 IFT(T)=0G0T0390

250 NS=20+2*(T >17) + (T >24) + (T >30) 260 REM SEEK 270 J0B=176 280 G0SUB430 290 REM READ

300 FORS=OTONS 310 J0B=128 320 G0SUB430

330 IFE=1G0T0380

340 S*=R IGHT*(STR*(S),LEN(STR*(S))-1)

350 IF3<10THENS*=" "+S*

360 IFE >1ANDE<12THENEM*=STR*(E+18)+" REA

D ERROR"

370 PRINT"TRACK";T;"- SECTOR "S*" ="EM*

380 NEXTS 390 NEXTT

400 CLOSE15 410 END

420 REM JOB QUEUE 430 TRY=0

440 PRINT#15,"M-W"CHR*(8)CHR*(0)CHR*(2)C

HR*(T)CHR*(S)

450 PRINT#15, "M-W"CHR* (1) CHR* (O) CHR* (DC

HR*(JOB)

460 TRY=TRY+1

470 PRINT#15,"M-R"CHR*(1)CHR*(O)

480 GET#15,E*

490 IFE*=""THENE*=CHR*(0) 500 E=ASC(E*)

510 IFTRY=500G0T0540 520 IFE>127G0T0460 530 RETURN

540 EM*="?TIME OUT" 550 RETURN

479

-----------------------------------------------------Page 479-----------------------------------------------------
﻿

-----------------------------------------------------Page 480-----------------------------------------------------
﻿
100 REM DUMP TRACK 8c SECTOR - 1541

110 P0KE56,159

120 CLR

130 PRINT" {CLR}DUMP TRACK 8< SECTOR - 154

1"

140 PRINT"{DOWN}INSERT DISKETTE IN DRIVE

II

150 I NPUT "{DOWN} TRACK 8c SECTOR (T,S)";T,

S

160 IFT<1ORT >35G0T0630

170 NS=20+2*(T>17)+(T>24)+(T>30) 180 IFS<00RS>NSG0T0630

190 INPUT"{DOWN}ARE YOU SURE Y{LEFT 3}" ;Q*

200 IFQ*O"Y"G0T0630

210 0PEN15,8,15

220 PRINT#15,"IO"

230 INPUT#15,EN*,EM*,ET*,ES*

240 IFEN*="00"G0T0290

250 PRINT"{DOWN}"EN*","EM*","ET*","ES*

260 PRINT"{DOWN}PRESS {RVS}RETURN{ROFF} TO CONTINUE"

270 GETC*:IFC*=""THEN270 280 IFC*< >CHR*(13)G0T0270

290 T*=RIGHT*(STR*(T),LEN(STR*(T))-l)

300 IFT<1OTHENT*="O"+f*

310 S*=RIGHT*(STR*(S),LEN(STR*(S))-1) 320 IFS<1OTHENS*="0"+S* 330 REM SEEK 340 J0B=176 350 G0SUB670

360 IFE=01GOT0410 370 REM READ 380 J0B=128 390 G0SUB670

400 IFE=10RE=4ORE=5G0TO510

410 IFE >1ANDE<12THENEN*=RIGHT*(STR*(E+18

),2):G0T0430

420 EN*="02":EM*="?TIME OUT":G0T0440 430 EM*="READ ERROR" 440 ET*=T* 450 ES*=S*

460 PRINT"{DOWN}"EN*","EM*","ET*","ES*

470 CLOSE15

480 P0KE56,160

490 CLR 500 END

510 F0RJ=0T031 520 F0RI=0T07

530 PRINT#15,"M-R"CHR*(J *8+1)CHR*(4)

481

-----------------------------------------------------Page 481-----------------------------------------------------
﻿
540 GET#15,D*

550 D=ASC(D*+CHR*(0))

560 POKE(40704+J*8+I),D

570 NEXTI 580 NEXTJ

590 CL0SE15

600 FRINT"{D0WN}D0NE!"

610 PRINT"{D0WN3P0KE56,160:CLR"

620 END

630 POKE56,160

640 CLR 650 END

660 REM JOB QUEUE 670 TRY=0

680 PRINT#15,"M-W"CHR*(8)CHR*(O)CHR*(2)C

HR*(T)CHR*(S)

690 PRINT#15, " M-W" CHR* (1) CHR* (O) CHR* (DC

HR*(JOB)

700 TRY=TRY+1

710 PRINT#15, "M-R"CHR*(DCHR*(0) 720 GET#15,E*

730 IFE*=""THENE*=CHR*(0) 740 E=ASC(E*)

750 IFTRY=500G0T0770 760 IFE>127G0T0700 770 RETURN

482

-----------------------------------------------------Page 482-----------------------------------------------------
﻿
100 REM BULK ERASER - 1541

110 PRINT"{CLR}BULK ERASER - 1541"

120 PRINT"{DOWN}INSERT DISKETTE IN DRIVE

■l

130 INPUT"{DOWN}{RVS}ERASE{ROFF} THIS Dl

SKETTE Y{LEFT 3}";Q*

140 1FQ*< >"Y"THENEND

150 INPUT"{DOWN}ARE YOU SURE Y{LEFT 3>"

;Q*

160 IFQ*< >"Y"THENEND

170 0PEN15,8,15

180 F0RI=0T023 190 READD

200 D*=D*+CHR*(D) 210 NEXTI

220 PRINT#15,"M-W"CHR*(O)CHR*(4)CHR*(24)

D*

230 F0RT=1T035

240 PRINT"{HOME}{DOWN 8}{RVS}ERASING{ROF F} TRACK"T

250 REM SEEK 260 J0B=176 270 G0SUB360

280 REM EXECUTE 290 J0B=224 300 G0SUB360 310 NEXTT

320 PRINT"{HOME}{DOWN 8}D0NE!

II

330 CLOSE15 340 END

350 REM JOB QUEUE 360 TRY=0

370 PRINT#15,"M-W"CHR*(8> CHR*(O)CHR*(2)C

HR*(T)CHR*(0)

380 PRINT#15, "M-W"CHR* (1) CHR* (O) CHR* (DC

HR*(JOB)

390 TRY=TRY+1

400 PRINT#15, "M-R"CHR*(DCHR*(0) 410 GET#15,E*

420 IFE*=""THENE*=CHR*(0) 430 E=ASC(E*)

440 IFTRY=500G0T0470 450 IFEM27GOT0390 460 RETURN 470 CLOSE15

480 PRINT"{DOWN}{RVS}FAILED{ROFF}"

490 END

500 REM 21 ERROR

483

-----------------------------------------------------Page 483-----------------------------------------------------
﻿
510 DATA 32,163,253,169, 85,141, 1, 28

520 DATA 162,255,160, 48, 32,201,253, 32

530 DATA 0,254,169, 1, 76,105,249,234

484

-----------------------------------------------------Page 484-----------------------------------------------------
﻿
APPENDIX D

MATHEMATICAL CONVERSION ROUTINES

485

-----------------------------------------------------Page 485-----------------------------------------------------
﻿

-----------------------------------------------------Page 486-----------------------------------------------------
﻿
100 REM DECIMAL TO HEXADECIMAL 11O H*="0123456789ABCDEF"

120 PRINT"{CLR}DECIMAL TO HEXADECIMAL"

130 D=-l

140 INPUT"{DOWN}DECIMAL ";D 150 IFD<00RD>255THENEND 160 H=INT(D/16) 170 L=D-(H*16)

180 HD*=MID*(H*,H+1,1)+MID*(H*,L+l,1)

190 PRINT"{DOWN}HEXADECIMAL: "HD* 200 GOTO130

487

-----------------------------------------------------Page 487-----------------------------------------------------
﻿

-----------------------------------------------------Page 488-----------------------------------------------------
﻿
100 REM HEXADECIMAL TO DECIMAL 110 H*="0123456789ABCDEF"

120 PRINT"{CLR}HEXADECIMAL TO DECIMAL"

130 HD*=""

140 INPUT"{DOWN}HEXADECIMAL";HD*

150 IFLEN(HD*)=OTHENEND 160 1FLEN(HD*)< >2THENEND 170 H=0

180 F0RI=1T016

190 IFLEFT*(HD*,1)=MID*(H*,1,1)THENH=I:I

= 16

200 NEXTI

210 IFH=0G0T0130 220 H=H-1 230 L=0

240 F0RI=1T016

250 IFRIGHT*(HD*,1)=MID*(H*,1,1)THENL=I:

1 = 16

260 NEXTI

270 IFL=0G0T0130 280 L=L-1

290 D=H*16+L

300 PRINT"{D0WN3DECIMAL :"D 310 G0T0130

489

-----------------------------------------------------Page 489-----------------------------------------------------
﻿

-----------------------------------------------------Page 490-----------------------------------------------------
﻿
100 REM DECIMAL TO BINARY

110 DEFFNB(B)=2"(B-INT(B/8)*8)ANDD 120 PRINT"{CLR}DECIMAL TO BINARY" 130 D=-l

140 INPUT"{DOWN}DECIMAL";D 150 IFD<00RD>255THENEND

160 PRINT"{DOWN}BINARY : "; 170 FORB=7TOO STEP-1

180 IFFNB(B)=OTHENPRINT"O";:G0T0200 190 PRINT"1"; 200 NEXTB 210 PRINT

220 G0T0130

491

-----------------------------------------------------Page 491-----------------------------------------------------
﻿

-----------------------------------------------------Page 492-----------------------------------------------------
﻿
100 REM BINARY TO DECIMAL

110 PRINT"{CLR}BINARY TO DECIMAL" 120 B*=""

130 INPUT"{D0WN3BINARY (E.G., 10101010)" ;B*

140 IFLEN(B*)=OTHENEND 150 IFLEN(B* X >8THENEND 160 B=0 170 D=0

180 F0RI=1T08

190 IFMID*(B*,I,1)="1"THENB=B+1:D=D+2�(8

-I):G0T0210

200 IFMID* (B*, I, D="0"THENB=B+1

210 NEXTI

220 IFBO8G0T0120

230 PRINT"{DOWN}DECIMAL :

"D

240 GOTO120

493

-----------------------------------------------------Page 493-----------------------------------------------------
﻿

-----------------------------------------------------Page 494-----------------------------------------------------
﻿
100 REM HEXADECIMAL TO GCR 110 H*="0123456789ABCDEF" 120 DIMS*(15)

130 B*(0)="01010" 140 B*(l)="01011" 150 B*(2)="10010" 160 B*(3)="10011" 170 B*(4)="OH10" 180 B*(5)="01111" 190 B*(6)="10110" 200 B*(7)="10111" 210 B*(8)="01001" 220 B*(9)="11001" 230 B*(10)="11010" 240 B*(ll)="11011" 250 B*(12)="01101" 260 B*(13)="11101" 270 B*(14)="llHO" 280 B*(15)="10101"

290 PRINT"{CLR}HEXADECIMAL TO GCR" 300 HG*=""

310 INPUT"{DOWN5HEXADECIMAL (E.G., 034A0 023)";hg*

320 IFLEN(HG*)=0THENEND 330 IFLEN(HG*)<>8THENEND 340 F0RI=1T04

350 HG*(I)=MID*(HG*,1*2-1,2)

360 NEXTI

370 F0RJ=1T04 380 H(J)=0

390 F0RI=1T016

400 IFLEFT*(HG*(J),D=MID*(H*,I,1)THENH( J)=l:1=16 410 NEXTI

420 IFH(J)=OG0TO3OO 430 H(J)=H(J)-1 440 L(J)=0

450 FORI=1TO16

460 IFRIGHT*(HG*(J),D=MID*(H*,I,1)THENL

(J)=l:1=16 470 NEXTI

480 IFL(J)=OGOT0300 490 L(J)=L(J)-1 500 NEXTJ

510 F0RI=1T04

520 IMAGE*=IMAGE*+B*(H(I)) 530 IMAGE*=IMAGE*+B*(L(I)) 540 NEXTI

550 PRINT"{DOWN}"IMAGE* 560 PRINT"{UP}";

495

-----------------------------------------------------Page 495-----------------------------------------------------
﻿
570 580 590 600 610 620 630 640 650 660
 F0RI=1T08

PRINT"A ";

NEXTI

PRINT"{UP}" FORI=lT05

BD*(I)=MID*(IMAGE*,1*8-7.8)

NEXTI

F0RJ=1T05 F0RI=1T08

IFMID*(BD*(J) , I, D="1"THEND(J)=D(J)

2~(8-I)

670 680 690 70O 710 720 730 740 750 760 770 780 790 800 810 820 830 840 850
 NEXTI NEXTJ

F0RI=1T05

H=INT(D(I)/16)+1 L=D(I)-(H-D*16+1

DH*(I)=MID*(H*,H, D+MID*(H*,L,D

NEXTI

PRINT"{DOWN}HEXADECIMAL: ";

F0RI=1T04

PRINTHG*(I);" ";

NEXTI FRINT

PRINT"{DOWN}GCR : "; F0RI=1T05

PRINTDH*(I);" ";

NEXTI PRINT

PRINT"{DOWN}DONE!" END

496

-----------------------------------------------------Page 496-----------------------------------------------------
﻿
100 REM GCR TO HEXADECIMAL 110 H*="0123456789ABCDEF"

120 DEFFNB (B) =2'x (B-INT (B/8) *S) ANDD 130 DIMB*(15)

140 B*(0)="01010" 150 B*(l)="01011" 160 B*(2)="10010" 170 B*(3)="10011" 180 B*(4)="01110" 190 B*(5)="01111" 200 B*(6)="10110" 210 B*(7)="10111" 220 B*(3)="01001" 230 B*(9)="11001" 240 B*(10)="11010" 250 B*(ll)="11011" 260 B*(12)="01101" 270 B*(13)="11101" 280 B*(14)="11110" 290 B*(15)="10101"

300 PRINT"CCLR}GCR TO HEXADECIMAL" 310 GH*=""

320 INPUT"{DOWN}GCR (E.G. GH*

330 IFLEN(GH*)=0THENEND 340 IFLEN(GH*)<>1OTHENEND 350 F0RI=1T05

360 GH*(I)=MID*(GH*,1*2-1,2)

370 NEXTI

380 F0RJ=1T05 390 H(J)=0

400 FOR1=1TO16

410 IFLEFT*(GH*(J),D=MID*(H*,I,1)THENH(

J)=l:1=16 420 NEXTI

430 IFH(J)=0G0T0310 440 H(J)=H(J)-1 450 L(J)=0

460 FORI=lT016

470 IFRIGHT*(GH*(J) , D=MID*(H*, I, 1) THENL

(J)=l:1=16 480 NEXTI

490 IFL(J)=0G0T0310 500 L(J)=L(J)-1 510 NEXTJ

520 F0RI=1T05

530 HD(I)=H(I)*16+L(I) 540 NEXTI

550 IMAGE*="" 560 F0RI=1T05

497

-----------------------------------------------------Page 497-----------------------------------------------------
﻿
570 D=HD(I)

530 F0RB=7T00 STEP-1

590 IFFNB(B)=0THENIMAGE*=IMAGE*+"0":GOTO 610

600 IMAGE*=IMAGE*+"1" 610 NEXTB 620 NEXTI

630 PRINT"{DOWN}"IMAGE* 640 PRINT"{UP}";

650 F0RI=1T05

660 PRINT"'" ";

670 NEXTI

680 PRINT"{UP}" 690 F0RI=1T08

700 H*(I)=MID*(IMAGE*,1*5-4,5)

710 NEXTI

720 F0RJ=1T08 730 F0RI=0T015

740 IFH*(J)=B*(I)THEND(J)=I+l:1=15 750 NEXTI 760 NEXTJ

770 F0RI=1T08

780 IFD(I)=OTHENBDE=1 790 NEXTI

800 IFBDE=1G0T0940

810 PRINT"{DOWN}GCR : "; 820 F0RI=1T05

830 PRINTGH*(D" "; 840 NEXTI 850 PRINT

860 PRINT"{DOWN}HEXADECIMAL: ";

870 F0RI=1T08

880 PRINTMID*(H*,D(I),1);

890 IFI/2=INT(1/2)THENPRINT" ";

900 NEXTI 910 PRINT

920 PRINT"{DOWN}DONE!" 930 END

940 F0RI=1T08

950 IFD(I)=OTHENPRINT"{RVS}"H*(I)"{ROFF}

";:G0T0970

960 PRINTH*(I);

970 NEXTI

980 PRINT"{DOWN}{RVS}BYTE DECODING ERROR

{ROFF}" 990 END

498

-----------------------------------------------------Page 498-----------------------------------------------------
﻿
INDEX

499

-----------------------------------------------------Page 499-----------------------------------------------------
﻿

-----------------------------------------------------Page 500-----------------------------------------------------
﻿
INDEX

aborted validate routine asterisks in file names autoinitialization feature

B

B-A BE B-F B-P

bad sectoring

backup of a protected diskette

BAM 21, 26, binary to GCR conversion bit copying

bit manipulation

block allocate map

block availability map block, data

header

block-allocate command 89,

block-write command 71, 77,

buffer 82

buffer areas, organization of buffer-pointer command 71, 75 bugs in DOS 2.6 bump

byte separation

bytes, determining 1 bytes in the header block bytes per diskette 31

C 23

carriage return as a delimiter chaining

checksum, header block 32

501

cards, wild 23,

characters, sychronization 113- 14

72,

-----------------------------------------------------Page 501-----------------------------------------------------
﻿
checksums clock rates

close - 19 coda obscura

command channel

command, validate commands,

block-allocate block-execute block-free

block-read — 98

block-write 77,

copy

direct-access

DOS 15 initialize LOAD

memory-execute 96 memory-write 85

rename 22-23

SAVE 16 scratch 24 validate

VERIFY 16

Commodore encoding scheme Commodore file types

communications, computer-disk drive controller, floppy disk 103 coping a locked file 70 copy command 23

data block 113

data communication channel 16 DEL

deleted file 69-70 delimiter 55

determining bytes 116

DIR 49, 51 direct access 89

direct-access commands 71-72 direct-access data channel 72

disk commands, execution 83-184 disk drives, incompatability 208 disk, full 91

disk ID 21

502

buffer-pointer ...

codes, FDC job 109,

-----------------------------------------------------Page 502-----------------------------------------------------
﻿
disk interrogation disk management

disk protection schemes

diskette, recovering a physically damaged diskette, recovering an entire DOS bugs

DOS, definition of

DOS error messages

DOS protection 1 DOS, tasks of

DOS 2.6 sync mark

duplicating a protection scheme

encoding scheme, Commodore end or identify

EOI

EOR

EOR truth table

error messages, DOS 104, error, illegal track or sector

illegal quantity

no channel

recovery hard recovery soft

time out write

errors, hard

read

read/write soft

write

execute

execution of disk commands 183-184

FDC formatting routine FDC job codes 109,112 FDC main loop

FDC major entry points 190

FDC read routine ....... 191

FDC routines, major FDC routines, using 193-199

FDC write routine _____________ 192

fields of a directory 36

503

FDC 103,

-----------------------------------------------------Page 503-----------------------------------------------------
﻿
1541 binary to GCR look up table file, deleted

file name limits

file open error file padding

file, random access

relative

sequential data

side sector

user storage

file storage, program

sequential

file types, Commodore files, locked

fixed record length

formatting a diskette

full disk

full new, recovering from

GCR conversion

group coded recording

H

hard error, recovery

hard errors

header block 31,

header block, byte makeup

header block checksum header block ID

header block layout 32

I

I

ID character -2 ID HI

illegal quantity error 74

illegal track or sector error .......................... 91

initialize command 2

initializing a disk

504

floppy disk controller 103,

forward pointer 42,

incompatability, write ... ................................. 208-209

file management 184-

-----------------------------------------------------Page 504-----------------------------------------------------
﻿
inter-sector gap 34,

inter-sector tail

IP error codes IP routines

job codes job queue jobs

jump

last block signal

layout of a header block length, fixed record 66

LOAD

load address

locating particular relative files locked file, coping

locked file, renaming 70

locked files

M

ME

M-mode 177 MR

M-W

magnetic domains

major FDC routines

merging sequential files with copy command

N

N 21

naming a file 20-21

NEW

newing a diskette

no channel error

null directory entry 47

505

memory-execute command 72,

memory-read command 71,

memory-write command 71,

103,

-----------------------------------------------------Page 505-----------------------------------------------------
﻿
o

organization of buffer areas

P

padding the last block in a file parser routine

PRG

processor, interface program file storage programmer's aid

protected diskette, analyzing protected diskette, backup of a protection, DOS

protection scheme, duplication

Q

question marks in file names

R

random access file read errors read mode

read/write errors

reallocating sectors 173

record size

recording process

recovering a hard error

recovering a physically damaged diskette 177 recovering a relative file recovering a scratched file recovering a soft error

recovering an entire diskette

recovering from a full new

recovering scratched files recovery, relative file 176

relative file

relative file entries relative files

relative file, recovery

rename command

renaming a locked file

reset, warm ______

506

recovering an unclosed file ....................................... 177-178

recovering from a short new ....................................... 178-179

pointer, forward 42,

-----------------------------------------------------Page 506-----------------------------------------------------
﻿
SAVE

save and replace operation

scratch command scratched files

scratched files, recovering scratching a file

scratching an unclosed file

sector

sector filling sequence sector layout

sector number sectors

sequential data file

sequential file storage

short new, recovering from

side sector

side sector file

signal, last block

soft error, recovery 175

soft errors 175

ST 99 status variable

stopgap measure

sychronization characters 113-114 sync mark 115

sync mark, placement 114 sync mode

tail gap 34, 117

time out error 112

tracing a file 26-27

track number 32

tracks 29 tracks on a formatted diskette 29

U

U2 71 Ul 71

unclosed file, recovering

177-178unclosed files 27

unscratching a file 173 user file storage 69 using IP routines 185

using the FDC routines 193-199

507

USR ...

-----------------------------------------------------Page 507-----------------------------------------------------
﻿
V

validate command 25,

validate routine, aborted variable, status

VERIFY

W

warm reset

wild cards

wild cards in file names

508

114,

-----------------------------------------------------Page 508-----------------------------------------------------
﻿
WHEN IT COMES TO BOOKS,

WE'VE GOT YOU COVERED!

NOW THAT YOU'VE GOTTEN "INSIDE" COMMODORE DOS...

1541 User's Guide — Written by one of the authors of Inside

Commodore DOS, this book proves to be the perfect complement to Inside Commodore DOS. This book shows you how to make more effective use of your 1541 disk drive. It expands the documentation that came with your 1541 disk drive. Practical information on setting up and operating the disk drive as well as the DOS which came with your drive is included. Diskette housekeeping is throughly discussed including how to format or initialize a disk, and renaming, copying, and combining files. Complete your knowledge of the 1541 with the

1541 User's Guide. $19.95

The Elementary Commodore

Explains the Commodore 64 in

simple, everyday language. How to hook it up, use the keyboard, and program in BASIC. Teaches about word processing, utilities and peripherals. 114.95

Games Commodores Play

A collection of classic computer games that teaches BASIC using a games and graphics approach.

Simply type them in and make your

own modifications, f 14.95

Intermediate Commodore

Takes you from being a fledging programmer and teaches important principles so you can handle more complicated problems. Helps you take that step from elementary BASIC programming to machine language programming. $14.95 The Musical Commodore

Introduces you to music theory and computing at the same time. For beginners as well as pros, this book helps you turn your C-64 into a

musical instrument. $14.95

Computers & Writing

An innovative approach to teaching children to write using the

computer. Topics discussed include computers in the classroom, adapting traditional teaching methods to include computers,

setting up a creative environment at home and more. For both parents

and teachers. $9.95

A Shortcut Through

Adventureland, Volume I

Contains answers to 14 of the most

popular hi-res puzzle solving

adventures including Wizard and the Princess. Cranston Manor, The Dark

Crystal, Escape from Rungistan,

Time Zone and more. $9.95

Available at better book and

computer stores, or contact Datamost

The C-64 Home Companion

This is the book that should have

come with your Commodore 64. Straight answers to home computing

questions, dozens of software

reviews, BASIC and more! $19.95

C-64 Game Construction Kit Shows you how to write your own

BASIC games! This unique book gives examples of different games

and teaches fundemental lessons of

quality game programming. $14.95

Super Computer Snooper (C-64)

Learn how the computer "thinks."

Investigate memory, screens, programs and variables, keyboards, printers, and expansion boards, and

much more! $14.95

Programming for Profit

Aimed at the programmer who wants to get his or her software

published. This is a unique guidebook through the maze of

traditions, rules and standards in the

software industry. Contains hints

and tricks of the trade and much more! $14.95

C-64 Logo Workbook

Teaches children in grades 2-6 how the Logo language can be used for problem solving. Learn about the

"turtle," variables, geometry and

recursion. $12.95

Kids to Kids on the C-64 Written by kids for kids, explains BASIC programming in simple, straightforward language. Two chapters arc devoted to sound and graphics, and another shows how to

write an original game. $9-95

A Shortcut Through Adventureland, Volume II

The cheater's guide to all of

Infocom's text adventures to date:

The Zork Trilogy, Infidel, The

Witness, Deadline and Enchanter to

name a few. $9-95

-----------------------------------------------------Page 509-----------------------------------------------------
﻿
SMART PERIPHERALS FOR THE COMMODORE 64!

KWIK-LOAD!

KWIK-PAD!

$19.95 Each

KWIK-WRITE!

KWIK-PHONE!

Tired of paying 850, $75 or even $100 for quality products for your Commodore 64? If so, try our

KWIK-WARE! line. At just $ 19.95, each KWIK-WARE! product delivers high quality at an unbeatable price, and all KWIK-WARE! products are fully compatable

with one another.

KWIK-LOAD!, winner of Softsel's award for the hottest selling new utility of 1984, is the basis for all KWIK-WARE! products, all of which have the extra speed of KWIK-LOAD'. built-in. KWIK-LOAD'. loads and copies files over 300% faster than normal Commodore DOS. It includes KWIK-COPY'., a menu driven group of utilities which lets you perform DOS commands, check drive speed, edit sectors on disk, and alphabetize disk directories.

KWIK-PAD!, a co-resident secretary program. This handy utility features a built-in calculator mode, memo pad, appointment book, calendar, address book and more!

KWIK-WRITE! offers all the features of more costly word processors for a fraction of the price. Fully menu driven, KWIK-WRITE'. features full fledged help screens, cut and paste, search and replace, print preview, screen displays up to 132

characters wide, a full range of embedded printer commands,

and much more.

KWIK-PHONE!, a complete telecommunications package featuring simple command menus. It is compatible with

acoustic or direct-connect modems. The exclusive, built-in

KWIK-MAIL'. feature will answer your phone automatically to send or receive text, programs or hi-res graphics and a built-in phone book stores thousands of phone numbers. Be sure to watch for KWIK-CALC!, a complete spreadsheet package with over 2,500,000 available cells. KWIK-CALC! offers the versatility of the more expensive spreadsheet programs. KWIK-CALC! is priced at 824.95.

At DATAMOST, we didn't just ask why software is so expensive, we did something about it. KWIK-WARE! only 819-95 per package.

EIGHT FUN WAYS TO START ENJOYING YOUR C-64

AIM!,

»7%=ne»�B>-*5

4j .-•.»*,- licioHQ Mi !%»"*

\r l *'*»******* (taiwrtfMiMiii "Pi , i list .'.;|

*■; 1 $*%* .. I'll * ■:■-:

jsssir- i

Ankh — Dare to adventure in the MetaReal world, guiding

your "Surrogate Other" through a maze of 64 rooms. Test your reasoning, logic, and intellect in this hi-res arcade-action puzzle. Can you find the answer, using only your "other" and your wits? $19.95

AzteC — Guide your intrepid adventurer through eight levels

of an ancient Aztec ruin, in quest of the elusive golden idol. Use your wit, dexterity, and weapons to fight off spiders, scorpions, cobras, natives, and worse. $19.95

Jet-Boot Jack — Help Jack gather up all the notes using only

his custom Jet-Boots and your dexterity, in his adventure through the wonderous Music Machine. A 10-screen, multi- skill level obstacle course guaranteed to test the expertise of even the most seasoned game player. $19.95

Mabel'S Mansion — In this hires, real time adventure,

Barney the Bellhop must find his inheritance in his Aunt Mabel's haunted house. Hidden among the 90 rooms of her house are numerous treasures, guarded by hundreds of ghosts, ghouls, and monsters. $19-95

Available at better computer stores, or

contact Datamost.

Mr. Robot and His Robot Factory — a 11 screen

challenge. Jump from the treadmill to ladder to trampoline gathering power pills and bonus robots by avoiding bombs and the dreaded alienfire. Design and save up to 26 screens per

disk. $1995

MycheSS II — The only chess program with stunning 3-D,

B&W or color graphics! Play against your C-64 or another person. Includes possible moves, search for checkmate, hint, and examine square (to check for safe moves). Includes 128 games on disk as played by former masters. $29.95

Paint Magic — The ultimate graphics utility. Quickly draw

circles, lines and boxes with one command. Infinite fills. Grab and draw any image, shrink and enlarge, or use the micro¬ scopic mode. 16 colors. $39-95

Polar Pierre — The first two player game where two players

can play at the same time! Guide Pierre or Jacques through a multiple screen obstacle course, avoiding snowballs, lightning, stompers, and deadly falls. $19.95

Commodore 64 and 1541 arc registered trademarks of Commodore Business Maehines,

Inc. KWIK-LOAD!. KWIK-COPY!. KWIK-WRITE!. KWIK-MAIL!. KWIK-PAD!,

KWIK-PHONE!, KWIK-CALC!, and KWIK-WARE! are all registered trademarks of

DATAMOST, Inc.

iy&«

-----------------------------------------------------Page 510-----------------------------------------------------
﻿

-----------------------------------------------------Page 511-----------------------------------------------------
﻿
Inside

Commodore DOS

All the programs listed in Inside Commodore DOS on one diskette! Save yourself hours of typ¬ ing and de-bugging.

Only S 24.95 with this coupon!

Available only to readers of this book. Send $24.95 plus $2.00 for shipping and handling (California residents add QV%% sales tax) to:

DATAMOST

19821 Nordhoff Street, Northridge, CA 91324

Please RUSH me Inside Commodore DOS diskette. I

have enclosed my check or money order for $24.95 plus $2.00 shipping and handling (California residents add $1.62

for sales tax).

Name

Address

City

Phone ( )

State

X

-----------------------------------------------------Page 512-----------------------------------------------------
